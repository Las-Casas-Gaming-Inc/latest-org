{"ast":null,"code":"/**\r\n* Heap result object\r\n* @class HeapResult\r\n* @property {string} key Key\r\n* @property {number} priority Priority\r\n* @property {Object} item Context object\r\n*/\nexport function HeapResult(node) {\n  this.key = node.key;\n  this.priority = node.priority;\n  this.item = node.item;\n}\n\n/**\r\n * Creates Fibonacci Heap structure\r\n * @class FibonacciHeap\r\n * \r\n * @param {boolean} isMaximum Is maximum heap\r\n * @returns {FibonacciHeap} Returns new FibonacciHeap object\r\n */\nexport default function FibonacciHeap(isMaximum) {\n  var root = null,\n    count = 0,\n    nodes = {};\n  function Node(key, priority, item) {\n    this.key = key;\n    this.priority = priority;\n    this.item = item;\n    this.degree = 0;\n    this.marked = false;\n    this.parent = null;\n    this.child = null;\n    this.left = null;\n    this.right = null;\n  }\n\n  /**\r\n   * Validates internal structure consistency.\r\n   * \r\n   * @returns {boolean} Returns true if structure pass data consistency check.\r\n   */\n  function validate() {\n    var totalNodes = 0;\n    for (var key in nodes) {\n      if (nodes.hasOwnProperty(key)) {\n        var node = nodes[key];\n        totalNodes += 1;\n        if (node.child != null) {\n          if (!nodes.hasOwnProperty(node.child)) {\n            throw \"Child does not exists\";\n          }\n          var ref = nodes[node.child];\n          if (ref.parent != node.key) {\n            throw \"Child references wrong parent\";\n          }\n        }\n        if (node.parent != null) {\n          if (!nodes.hasOwnProperty(node.parent)) {\n            throw \"Parent does not exists\";\n          }\n        }\n        if (node.left != null) {\n          if (!nodes.hasOwnProperty(node.left)) {\n            throw \"Left does not exists\";\n          }\n          ref = nodes[node.left];\n          if (ref.right != node.key) {\n            throw \"Left references wrong right\";\n          }\n        }\n        if (node.right != null) {\n          if (!nodes.hasOwnProperty(node.right)) {\n            throw \"Right does not exists\";\n          }\n          ref = nodes[node.right];\n          if (ref.left != node.key) {\n            throw \"Right references wrong left\";\n          }\n        }\n      }\n    }\n    if (root == null && totalNodes > 0) {\n      throw \"Orphans\";\n    }\n    if (root != null) {\n      if (!nodes.hasOwnProperty(root)) {\n        throw \"Root node does not exists\";\n      }\n      node = nodes[root];\n      if (node.parent != null) {\n        throw \"Root node has parent reference\";\n      }\n      var children = [root];\n      var processed = {};\n      var totalChildren = 0;\n      while (children.length > 0) {\n        var newChildren = [];\n        for (var index = 0, len = children.length; index < len; index += 1) {\n          var child = nodes[children[index]];\n          while (!processed.hasOwnProperty(child.key)) {\n            processed[child.key] = true;\n            totalChildren += 1;\n            if (child.child != null) {\n              newChildren.push(child.child);\n            }\n            child = nodes[child.right];\n          }\n        }\n        children = newChildren;\n      }\n      if (totalNodes != totalChildren) {\n        throw \"Tree has loops or orpants\";\n      }\n    }\n  }\n\n  /**\r\n   * Adds a new item into the heap\r\n   * @param {string} key A key of the new element \r\n   * @param {number} priority A priority of the new element\r\n   * @param {object} item A context object of the new element \r\n   */\n  function add(key, priority, item) {\n    if (nodes.hasOwnProperty(key)) {\n      throw \"Duplicate keys are not supported!\";\n    }\n    var newNode = new Node(key, priority, item);\n    nodes[key] = newNode;\n    if (root == null) {\n      newNode.left = key;\n      newNode.right = key;\n      root = key;\n    } else {\n      var rootNode = nodes[root];\n      _insert(rootNode, newNode);\n      if (isMaximum ? rootNode.priority < newNode.priority : rootNode.priority > newNode.priority) {\n        root = key;\n      }\n    }\n    count += 1;\n  }\n  function _insert(node, newNode) {\n    var rightNode = nodes[node.right];\n    newNode.right = node.right;\n    newNode.left = node.key;\n    node.right = newNode.key;\n    rightNode.left = newNode.key;\n  }\n  function _exclude(node) {\n    var prevNode = nodes[node.left],\n      nextNode = nodes[node.right];\n    prevNode.right = nextNode.key;\n    nextNode.left = prevNode.key;\n    node.right = node.key;\n    node.left = node.key;\n  }\n\n  /**\r\n   * Gets priority of element by key\r\n   * @param {string} key The element key\r\n   * @returns {number} Returns priority of the element\r\n   */\n  function getPriority(key) {\n    var result = null;\n    if (nodes.hasOwnProperty(key)) {\n      result = nodes[key].priority;\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns heap root element\r\n   * \r\n   * @returns {HeapResult} Returns root element of the heap \r\n   */\n  function heapRoot() {\n    var result = null;\n    if (root != null) {\n      result = new HeapResult(nodes[root]);\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns heap root element with removal\r\n   * \r\n   * @returns {HeapResult} Returns root element of the heap \r\n   */\n  function extractRoot() {\n    var result = heapRoot();\n    if (result != null) {\n      var rootNode = nodes[root],\n        nextNode = nodes[rootNode.right];\n      if (rootNode.child != null) {\n        var childNode = nodes[rootNode.child],\n          childNodeLeft = nodes[childNode.left];\n        rootNode.right = childNode.key;\n        nextNode.left = childNodeLeft.key;\n        childNode.left = rootNode.key;\n        childNodeLeft.right = nextNode.key;\n        _exclude(rootNode);\n        delete nodes[rootNode.key];\n        root = null;\n        _consolidate(childNode.key);\n      } else {\n        _exclude(rootNode);\n        delete nodes[rootNode.key];\n        root = null;\n        if (nextNode.key != rootNode.key) {\n          _consolidate(nextNode.key);\n        }\n      }\n      count -= 1;\n    }\n    return result;\n  }\n  function _consolidate(startKey) {\n    var pairs = [],\n      pairedNode,\n      processed = {},\n      key = startKey;\n    while (!processed.hasOwnProperty(key)) {\n      var node = nodes[key],\n        nextKey = node.right;\n      processed[key] = true;\n      node.parent = null;\n      while ((pairedNode = pairs[node.degree]) != null) {\n        if (isMaximum ? node.priority > pairedNode.priority : node.priority < pairedNode.priority) {\n          _union(node, pairedNode);\n        } else {\n          _union(pairedNode, node);\n          node = pairedNode;\n        }\n        pairs[node.degree - 1] = null;\n      }\n      pairs[node.degree] = node;\n      if (root == null || nodes[root] == null || (isMaximum ? nodes[root].priority <= node.priority : nodes[root].priority >= node.priority)) {\n        root = node.key;\n      }\n      key = nextKey;\n    }\n  }\n  function _union(node1, node2) {\n    node1.degree += 1;\n    _exclude(node2);\n    var child = nodes[node1.child];\n    if (child != null) {\n      _insert(child, node2);\n      if (isMaximum ? child.priority < node2.priority : child.priority > node2.priority) {\n        node1.child = node2.key;\n      }\n    } else {\n      node1.child = node2.key;\n    }\n    node2.parent = node1.key;\n  }\n\n  /**\r\n   * Sets priority of an element by key\r\n   * @param {string} key The key of the element \r\n   * @param {number} priority Priority\r\n   */\n  function setPriority(key, priority) {\n    var node = nodes[key];\n    if (isMaximum ? node.priority > priority : node.priority < priority) {\n      throw \"Priority increase is not supported\";\n    }\n    node.priority = priority;\n    if (node.parent != null) {\n      var parentNode = nodes[node.parent];\n      if (isMaximum ? parentNode.priority < node.priority : parentNode.priority > node.priority) {\n        _cut(parentNode, node);\n        _cascadeCut(parentNode);\n      }\n    }\n    if (isMaximum ? nodes[root].priority < node.priority : nodes[root].priority > node.priority) {\n      root = node.key;\n    }\n  }\n  function _cut(parentNode, node) {\n    node.marked = false;\n    node.parent = null;\n    if (node.right == node.key) {\n      parentNode.child = null;\n    } else {\n      parentNode.child = node.right;\n      _exclude(node);\n    }\n    parentNode.degree -= 1;\n    _insert(nodes[root], node);\n  }\n  function _cascadeCut(node) {\n    if (node.parent != null) {\n      if (node.marked) {\n        var parentNode = nodes[node.parent];\n        _cut(parentNode, node);\n        _cascadeCut(parentNode);\n      } else {\n        node.marked = true;\n      }\n    }\n  }\n\n  /**\r\n   * Deletes heap element by key\r\n   * @param {string} key The Key \r\n   */\n  function deleteKey(key) {\n    setPriority(key, isMaximum ? Infinity : -1);\n    extractRoot();\n  }\n  return {\n    add: add,\n    getPriority: getPriority,\n    setPriority: setPriority,\n    heapRoot: heapRoot,\n    extractRoot: extractRoot,\n    deleteKey: deleteKey,\n    validate: validate\n  };\n}\n;","map":{"version":3,"names":["HeapResult","node","key","priority","item","FibonacciHeap","isMaximum","root","count","nodes","Node","degree","marked","parent","child","left","right","validate","totalNodes","hasOwnProperty","ref","children","processed","totalChildren","length","newChildren","index","len","push","add","newNode","rootNode","_insert","rightNode","_exclude","prevNode","nextNode","getPriority","result","heapRoot","extractRoot","childNode","childNodeLeft","_consolidate","startKey","pairs","pairedNode","nextKey","_union","node1","node2","setPriority","parentNode","_cut","_cascadeCut","deleteKey","Infinity"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/FibonacciHeap.js"],"sourcesContent":["/**\r\n* Heap result object\r\n* @class HeapResult\r\n* @property {string} key Key\r\n* @property {number} priority Priority\r\n* @property {Object} item Context object\r\n*/\r\nexport function HeapResult (node) {\r\n  this.key = node.key;\r\n  this.priority = node.priority;\r\n  this.item = node.item;\r\n}\r\n\r\n/**\r\n * Creates Fibonacci Heap structure\r\n * @class FibonacciHeap\r\n * \r\n * @param {boolean} isMaximum Is maximum heap\r\n * @returns {FibonacciHeap} Returns new FibonacciHeap object\r\n */\r\nexport default function FibonacciHeap(isMaximum) {\r\n  var root = null,\r\n    count = 0,\r\n    nodes = {};\r\n\r\n  function Node(key, priority, item) {\r\n    this.key = key;\r\n    this.priority = priority;\r\n    this.item = item;\r\n    this.degree = 0;\r\n    this.marked = false;\r\n\r\n    this.parent = null;\r\n    this.child = null;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n\r\n  /**\r\n   * Validates internal structure consistency.\r\n   * \r\n   * @returns {boolean} Returns true if structure pass data consistency check.\r\n   */\r\n  function validate() {\r\n    var totalNodes = 0;\r\n    for (var key in nodes) {\r\n      if (nodes.hasOwnProperty(key)) {\r\n        var node = nodes[key];\r\n\r\n        totalNodes += 1;\r\n\r\n        if (node.child != null) {\r\n          if (!nodes.hasOwnProperty(node.child)) {\r\n            throw \"Child does not exists\";\r\n          }\r\n          var ref = nodes[node.child];\r\n          if (ref.parent != node.key) {\r\n            throw \"Child references wrong parent\";\r\n          }\r\n        }\r\n        if (node.parent != null) {\r\n          if (!nodes.hasOwnProperty(node.parent)) {\r\n            throw \"Parent does not exists\";\r\n          }\r\n\r\n        }\r\n        if (node.left != null) {\r\n          if (!nodes.hasOwnProperty(node.left)) {\r\n            throw \"Left does not exists\";\r\n          }\r\n          ref = nodes[node.left];\r\n          if (ref.right != node.key) {\r\n            throw \"Left references wrong right\";\r\n          }\r\n        }\r\n\r\n        if (node.right != null) {\r\n          if (!nodes.hasOwnProperty(node.right)) {\r\n            throw \"Right does not exists\";\r\n          }\r\n          ref = nodes[node.right];\r\n          if (ref.left != node.key) {\r\n            throw \"Right references wrong left\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (root == null && totalNodes > 0) {\r\n      throw \"Orphans\";\r\n    }\r\n\r\n    if (root != null) {\r\n      if (!nodes.hasOwnProperty(root)) {\r\n        throw \"Root node does not exists\";\r\n      }\r\n\r\n      node = nodes[root];\r\n      if (node.parent != null) {\r\n        throw \"Root node has parent reference\";\r\n      }\r\n\r\n      var children = [root];\r\n      var processed = {};\r\n      var totalChildren = 0;\r\n      while (children.length > 0) {\r\n        var newChildren = [];\r\n        for (var index = 0, len = children.length; index < len; index += 1) {\r\n          var child = nodes[children[index]];\r\n          while (!processed.hasOwnProperty(child.key)) {\r\n            processed[child.key] = true;\r\n            totalChildren += 1;\r\n            if (child.child != null) {\r\n              newChildren.push(child.child);\r\n            }\r\n            child = nodes[child.right];\r\n          }\r\n        }\r\n        children = newChildren;\r\n      }\r\n\r\n      if (totalNodes != totalChildren) {\r\n        throw \"Tree has loops or orpants\";\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new item into the heap\r\n   * @param {string} key A key of the new element \r\n   * @param {number} priority A priority of the new element\r\n   * @param {object} item A context object of the new element \r\n   */\r\n  function add(key, priority, item) {\r\n    if (nodes.hasOwnProperty(key)) {\r\n      throw \"Duplicate keys are not supported!\";\r\n    }\r\n\r\n    var newNode = new Node(key, priority, item);\r\n    nodes[key] = newNode;\r\n\r\n    if (root == null) {\r\n      newNode.left = key;\r\n      newNode.right = key;\r\n      root = key;\r\n    } else {\r\n      var rootNode = nodes[root];\r\n      _insert(rootNode, newNode);\r\n      if (isMaximum ? rootNode.priority < newNode.priority : rootNode.priority > newNode.priority) {\r\n        root = key;\r\n      }\r\n    }\r\n    count += 1;\r\n  }\r\n\r\n  function _insert(node, newNode) {\r\n    var rightNode = nodes[node.right];\r\n    newNode.right = node.right;\r\n    newNode.left = node.key;\r\n    node.right = newNode.key;\r\n    rightNode.left = newNode.key;\r\n  }\r\n\r\n  function _exclude(node) {\r\n    var prevNode = nodes[node.left],\r\n      nextNode = nodes[node.right];\r\n\r\n    prevNode.right = nextNode.key;\r\n    nextNode.left = prevNode.key;\r\n    node.right = node.key;\r\n    node.left = node.key;\r\n  }\r\n\r\n  /**\r\n   * Gets priority of element by key\r\n   * @param {string} key The element key\r\n   * @returns {number} Returns priority of the element\r\n   */\r\n  function getPriority(key) {\r\n    var result = null;\r\n    if (nodes.hasOwnProperty(key)) {\r\n      result = nodes[key].priority;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns heap root element\r\n   * \r\n   * @returns {HeapResult} Returns root element of the heap \r\n   */\r\n  function heapRoot() {\r\n    var result = null;\r\n    if (root != null) {\r\n      result = new HeapResult(nodes[root]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns heap root element with removal\r\n   * \r\n   * @returns {HeapResult} Returns root element of the heap \r\n   */\r\n  function extractRoot() {\r\n    var result = heapRoot();\r\n    if (result != null) {\r\n      var rootNode = nodes[root],\r\n        nextNode = nodes[rootNode.right];\r\n\r\n      if (rootNode.child != null) {\r\n        var childNode = nodes[rootNode.child],\r\n          childNodeLeft = nodes[childNode.left];\r\n\r\n        rootNode.right = childNode.key;\r\n        nextNode.left = childNodeLeft.key;\r\n        childNode.left = rootNode.key;\r\n        childNodeLeft.right = nextNode.key;\r\n\r\n        _exclude(rootNode);\r\n        delete nodes[rootNode.key];\r\n\r\n        root = null;\r\n        _consolidate(childNode.key);\r\n      } else {\r\n        _exclude(rootNode);\r\n        delete nodes[rootNode.key];\r\n\r\n        root = null;\r\n        if (nextNode.key != rootNode.key) {\r\n          _consolidate(nextNode.key);\r\n        }\r\n      }\r\n      count -= 1;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function _consolidate(startKey) {\r\n    var pairs = [], pairedNode,\r\n      processed = {},\r\n      key = startKey;\r\n    while (!processed.hasOwnProperty(key)) {\r\n      var node = nodes[key],\r\n        nextKey = node.right;\r\n\r\n      processed[key] = true;\r\n      node.parent = null;\r\n\r\n      while ((pairedNode = pairs[node.degree]) != null) {\r\n        if (isMaximum ? node.priority > pairedNode.priority : node.priority < pairedNode.priority) {\r\n          _union(node, pairedNode);\r\n        } else {\r\n          _union(pairedNode, node);\r\n          node = pairedNode;\r\n        }\r\n        pairs[node.degree - 1] = null;\r\n      }\r\n      pairs[node.degree] = node;\r\n\r\n      if (root == null || nodes[root] == null || (isMaximum ? nodes[root].priority <= node.priority : nodes[root].priority >= node.priority)) {\r\n        root = node.key;\r\n      }\r\n\r\n      key = nextKey;\r\n    }\r\n  }\r\n\r\n  function _union(node1, node2) {\r\n    node1.degree += 1;\r\n    _exclude(node2);\r\n    var child = nodes[node1.child];\r\n    if (child != null) {\r\n      _insert(child, node2);\r\n      if (isMaximum ? child.priority < node2.priority : child.priority > node2.priority) {\r\n        node1.child = node2.key;\r\n      }\r\n    } else {\r\n      node1.child = node2.key;\r\n    }\r\n    node2.parent = node1.key;\r\n  }\r\n\r\n  /**\r\n   * Sets priority of an element by key\r\n   * @param {string} key The key of the element \r\n   * @param {number} priority Priority\r\n   */\r\n  function setPriority(key, priority) {\r\n    var node = nodes[key];\r\n    if (isMaximum ? node.priority > priority : node.priority < priority) {\r\n      throw \"Priority increase is not supported\";\r\n    }\r\n    node.priority = priority;\r\n\r\n    if (node.parent != null) {\r\n      var parentNode = nodes[node.parent];\r\n      if (isMaximum ? parentNode.priority < node.priority : parentNode.priority > node.priority) {\r\n        _cut(parentNode, node);\r\n        _cascadeCut(parentNode);\r\n      }\r\n    }\r\n    if (isMaximum ? nodes[root].priority < node.priority : nodes[root].priority > node.priority) {\r\n      root = node.key;\r\n    }\r\n  }\r\n\r\n  function _cut(parentNode, node) {\r\n    node.marked = false;\r\n    node.parent = null;\r\n    if (node.right == node.key) {\r\n      parentNode.child = null;\r\n    } else {\r\n      parentNode.child = node.right;\r\n      _exclude(node);\r\n    }\r\n    parentNode.degree -= 1;\r\n    _insert(nodes[root], node);\r\n  }\r\n\r\n  function _cascadeCut(node) {\r\n    if (node.parent != null) {\r\n      if (node.marked) {\r\n        var parentNode = nodes[node.parent];\r\n        _cut(parentNode, node);\r\n        _cascadeCut(parentNode);\r\n      } else {\r\n        node.marked = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes heap element by key\r\n   * @param {string} key The Key \r\n   */\r\n  function deleteKey(key) {\r\n    setPriority(key, isMaximum ? Infinity : -1);\r\n    extractRoot();\r\n  }\r\n\r\n  return {\r\n    add: add,\r\n    getPriority: getPriority,\r\n    setPriority: setPriority,\r\n    heapRoot: heapRoot,\r\n    extractRoot: extractRoot,\r\n    deleteKey: deleteKey,\r\n    validate: validate\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}