{"ast":null,"code":"/**\r\n * Callback for finding distance for a collection item\r\n *\r\n * @callback funcDistance\r\n * @param {Object} item A collection item\r\n * @param {number} index An index of the collection item\r\n * @returns {number} Returns a distance for the item \r\n */\n\n/**\r\n* @typedef {Object} BinarySearchResult\r\n* @property {number} index The index of the nearest item in the collection\r\n* @property {Object} item The nearest item\r\n*/\n\n/**\r\n * Search sorted list of elements for the nearest item.\r\n *\r\n * @param {Object[]} items - The collection of elements.\r\n * @param {funcDistance} callback - A callback function to get distance for the collection item. \r\n * @param {number} [startMinimum=undefined] - The minimum index in the array to start search from\r\n * @param {number} [startMaximum=undefined] - The maximum index in the array to start search from\r\n * @returns {BinarySearchResult} Returns an item of the collection, which is nearest to optimal measured by callback function\r\n*/\nexport default function binarySearch(items, callback, startMinimum, startMaximum) {\n  var result = null,\n    distance,\n    bestDistance,\n    minimum = startMinimum || 0,\n    maximum = startMaximum || items.length - 1,\n    middle,\n    item;\n  if (items.length > 0) {\n    item = items[minimum];\n    result = {\n      index: minimum,\n      item: item\n    };\n    distance = callback(item, minimum);\n    if (distance > 0) {\n      bestDistance = Math.abs(distance);\n      item = items[maximum];\n      distance = callback(item, maximum);\n      if (distance >= 0) {\n        result = {\n          index: maximum,\n          item: item\n        };\n      } else {\n        distance = Math.abs(distance);\n        if (bestDistance > distance) {\n          bestDistance = distance;\n          result = {\n            index: maximum,\n            item: item\n          };\n        }\n        while (minimum + 1 < maximum) {\n          middle = Math.round((minimum + maximum) / 2.0);\n          item = items[middle];\n          distance = callback(item, middle);\n          if (distance === 0) {\n            result = {\n              index: middle,\n              item: item\n            };\n            break;\n          } else {\n            if (distance > 0) {\n              minimum = middle;\n            } else {\n              maximum = middle;\n            }\n            distance = Math.abs(distance);\n            if (bestDistance > distance) {\n              bestDistance = distance;\n              result = {\n                index: middle,\n                item: item\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n;","map":{"version":3,"names":["binarySearch","items","callback","startMinimum","startMaximum","result","distance","bestDistance","minimum","maximum","length","middle","item","index","Math","abs","round"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/binarySearch.js"],"sourcesContent":["/**\r\n * Callback for finding distance for a collection item\r\n *\r\n * @callback funcDistance\r\n * @param {Object} item A collection item\r\n * @param {number} index An index of the collection item\r\n * @returns {number} Returns a distance for the item \r\n */\r\n\r\n/**\r\n* @typedef {Object} BinarySearchResult\r\n* @property {number} index The index of the nearest item in the collection\r\n* @property {Object} item The nearest item\r\n*/\r\n\r\n/**\r\n * Search sorted list of elements for the nearest item.\r\n *\r\n * @param {Object[]} items - The collection of elements.\r\n * @param {funcDistance} callback - A callback function to get distance for the collection item. \r\n * @param {number} [startMinimum=undefined] - The minimum index in the array to start search from\r\n * @param {number} [startMaximum=undefined] - The maximum index in the array to start search from\r\n * @returns {BinarySearchResult} Returns an item of the collection, which is nearest to optimal measured by callback function\r\n*/\r\nexport default function binarySearch(items, callback, startMinimum, startMaximum) {\r\n  var result = null,\r\n    distance,\r\n    bestDistance,\r\n    minimum = startMinimum || 0,\r\n    maximum = startMaximum || (items.length - 1),\r\n    middle,\r\n    item;\r\n\r\n  if (items.length > 0) {\r\n    item = items[minimum];\r\n    result = { index: minimum, item: item };\r\n    distance = callback(item, minimum);\r\n    if (distance > 0) {\r\n      bestDistance = Math.abs(distance);\r\n\r\n      item = items[maximum];\r\n      distance = callback(item, maximum);\r\n      if (distance >= 0) {\r\n        result = { index: maximum, item: item };\r\n      } else {\r\n        distance = Math.abs(distance);\r\n        if (bestDistance > distance) {\r\n          bestDistance = distance;\r\n          result = { index: maximum, item: item };\r\n        }\r\n        while (minimum + 1 < maximum) {\r\n          middle = Math.round((minimum + maximum) / 2.0);\r\n          item = items[middle];\r\n          distance = callback(item, middle);\r\n          if (distance === 0) {\r\n            result = { index: middle, item: item };\r\n            break;\r\n          } else {\r\n            if (distance > 0) {\r\n              minimum = middle;\r\n            } else {\r\n              maximum = middle;\r\n            }\r\n            distance = Math.abs(distance);\r\n            if (bestDistance > distance) {\r\n              bestDistance = distance;\r\n              result = { index: middle, item: item };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,YAAYA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,YAAY,EAAE;EAChF,IAAIC,MAAM,GAAG,IAAI;IACfC,QAAQ;IACRC,YAAY;IACZC,OAAO,GAAGL,YAAY,IAAI,CAAC;IAC3BM,OAAO,GAAGL,YAAY,IAAKH,KAAK,CAACS,MAAM,GAAG,CAAE;IAC5CC,MAAM;IACNC,IAAI;EAEN,IAAIX,KAAK,CAACS,MAAM,GAAG,CAAC,EAAE;IACpBE,IAAI,GAAGX,KAAK,CAACO,OAAO,CAAC;IACrBH,MAAM,GAAG;MAAEQ,KAAK,EAAEL,OAAO;MAAEI,IAAI,EAAEA;IAAK,CAAC;IACvCN,QAAQ,GAAGJ,QAAQ,CAACU,IAAI,EAAEJ,OAAO,CAAC;IAClC,IAAIF,QAAQ,GAAG,CAAC,EAAE;MAChBC,YAAY,GAAGO,IAAI,CAACC,GAAG,CAACT,QAAQ,CAAC;MAEjCM,IAAI,GAAGX,KAAK,CAACQ,OAAO,CAAC;MACrBH,QAAQ,GAAGJ,QAAQ,CAACU,IAAI,EAAEH,OAAO,CAAC;MAClC,IAAIH,QAAQ,IAAI,CAAC,EAAE;QACjBD,MAAM,GAAG;UAAEQ,KAAK,EAAEJ,OAAO;UAAEG,IAAI,EAAEA;QAAK,CAAC;MACzC,CAAC,MAAM;QACLN,QAAQ,GAAGQ,IAAI,CAACC,GAAG,CAACT,QAAQ,CAAC;QAC7B,IAAIC,YAAY,GAAGD,QAAQ,EAAE;UAC3BC,YAAY,GAAGD,QAAQ;UACvBD,MAAM,GAAG;YAAEQ,KAAK,EAAEJ,OAAO;YAAEG,IAAI,EAAEA;UAAK,CAAC;QACzC;QACA,OAAOJ,OAAO,GAAG,CAAC,GAAGC,OAAO,EAAE;UAC5BE,MAAM,GAAGG,IAAI,CAACE,KAAK,CAAC,CAACR,OAAO,GAAGC,OAAO,IAAI,GAAG,CAAC;UAC9CG,IAAI,GAAGX,KAAK,CAACU,MAAM,CAAC;UACpBL,QAAQ,GAAGJ,QAAQ,CAACU,IAAI,EAAED,MAAM,CAAC;UACjC,IAAIL,QAAQ,KAAK,CAAC,EAAE;YAClBD,MAAM,GAAG;cAAEQ,KAAK,EAAEF,MAAM;cAAEC,IAAI,EAAEA;YAAK,CAAC;YACtC;UACF,CAAC,MAAM;YACL,IAAIN,QAAQ,GAAG,CAAC,EAAE;cAChBE,OAAO,GAAGG,MAAM;YAClB,CAAC,MAAM;cACLF,OAAO,GAAGE,MAAM;YAClB;YACAL,QAAQ,GAAGQ,IAAI,CAACC,GAAG,CAACT,QAAQ,CAAC;YAC7B,IAAIC,YAAY,GAAGD,QAAQ,EAAE;cAC3BC,YAAY,GAAGD,QAAQ;cACvBD,MAAM,GAAG;gBAAEQ,KAAK,EAAEF,MAAM;gBAAEC,IAAI,EAAEA;cAAK,CAAC;YACxC;UACF;QACF;MACF;IACF;EACF;EACA,OAAOP,MAAM;AACf;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}