{"ast":null,"code":"import SortedList from './SortedList';\n/**\r\n * Callback function to iterate over pairs of crossing rectangles\r\n * \r\n * @callback onCrossingRectanglesItemCallback\r\n * @param {Rect} rect1 First rectangle\r\n * @param {Rect} rect2 Second rectangle\r\n */\n\n/**\r\n * Finds pairs of crossing rectangles.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Rect[]} rectangles Collection of rectangles.\r\n * @param {onCrossingRectanglesItemCallback} onCrossing Callback function to pass pair of crossing rectangles.\r\n */\nexport default function getCrossingRectangles(thisArg, rectangles, onCrossing) {\n  function Action(isStart, index, x, rect) {\n    this.isStart = isStart;\n    this.index = index;\n    this.x = x;\n    this.rect = rect;\n  }\n  function Level() {\n    this.count = 0;\n    this.rectangles = {};\n    this.add = function (index) {\n      this.count += 1;\n      this.rectangles[index] = true;\n    };\n    this.remove = function (index) {\n      this.count -= 1;\n      delete this.rectangles[index];\n      return this.count == 0;\n    };\n  }\n  function _findCrossedRectangles(buffer, from, to, rectIndex, rect) {\n    buffer.loopForward(this, from, function (value, level) {\n      if (value > to) {\n        return true;\n      }\n      for (var index in level.rectangles) {\n        if (level.rectangles.hasOwnProperty(index)) {\n          var key = rectIndex > index ? rectIndex + \"-\" + index : index + \"-\" + rectIndex;\n          if (!processed.hasOwnProperty(key)) {\n            processed[key] = true;\n            onCrossing.call(thisArg, rect, rectangles[index]);\n          }\n        }\n      }\n    });\n  }\n  if (onCrossing != null) {\n    // Create action items out of rectangles\n    var actions = [];\n    for (var index = 0; index < rectangles.length; index += 1) {\n      var rect = rectangles[index];\n      actions.push(new Action(1, index, rect.x, rect));\n      actions.push(new Action(0, index, rect.right(), rect));\n    }\n    actions.sort(function (a, b) {\n      if (a.x == b.x) {\n        return b.isStart - a.isStart;\n      }\n      return a.x - b.x;\n    });\n\n    /* find intersections */\n    var buffer = SortedList();\n    var levels = {};\n    var processed = {};\n    for (index = 0; index < actions.length; index += 1) {\n      var action = actions[index];\n      var actionLevels = [action.rect.y, action.rect.bottom()];\n      if (action.isStart == 1) {\n        // Search for intersections of the left side of the rectangle with existing horizontal segments\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\n\n        // add rectangle's horizontal segments\n        for (var index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          var value = actionLevels[index2];\n          var level = levels[value];\n          if (level == null) {\n            level = new Level();\n            levels[value] = level;\n            buffer.add(value, level);\n          }\n          level.add(action.index);\n        }\n      } else {\n        // remove rectangle's horizontal segments\n        for (index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          value = actionLevels[index2];\n          level = levels[value];\n          if (level.remove(action.index)) {\n            delete levels[value];\n            buffer.remove(value);\n          }\n        }\n\n        // Search for intersections of the right side of rectangle with existing horizontal segments\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\n      }\n    }\n  }\n}\n;","map":{"version":3,"names":["SortedList","getCrossingRectangles","thisArg","rectangles","onCrossing","Action","isStart","index","x","rect","Level","count","add","remove","_findCrossedRectangles","buffer","from","to","rectIndex","loopForward","value","level","hasOwnProperty","key","processed","call","actions","length","push","right","sort","a","b","levels","action","actionLevels","y","bottom","index2","len2"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/getCrossingRectangles.js"],"sourcesContent":["import SortedList from './SortedList';\r\n/**\r\n * Callback function to iterate over pairs of crossing rectangles\r\n * \r\n * @callback onCrossingRectanglesItemCallback\r\n * @param {Rect} rect1 First rectangle\r\n * @param {Rect} rect2 Second rectangle\r\n */\r\n\r\n/**\r\n * Finds pairs of crossing rectangles.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Rect[]} rectangles Collection of rectangles.\r\n * @param {onCrossingRectanglesItemCallback} onCrossing Callback function to pass pair of crossing rectangles.\r\n */\r\nexport default function getCrossingRectangles(thisArg, rectangles, onCrossing) {\r\n  function Action(isStart, index, x, rect) {\r\n    this.isStart = isStart;\r\n    this.index = index;\r\n    this.x = x;\r\n    this.rect = rect;\r\n  }\r\n\r\n  function Level() {\r\n    this.count = 0;\r\n    this.rectangles = {};\r\n\r\n    this.add = function (index) {\r\n      this.count += 1;\r\n      this.rectangles[index] = true;\r\n    };\r\n\r\n    this.remove = function (index) {\r\n      this.count -= 1;\r\n      delete this.rectangles[index];\r\n      return this.count == 0;\r\n    };\r\n  }\r\n\r\n  function _findCrossedRectangles(buffer, from, to, rectIndex, rect) {\r\n    buffer.loopForward(this, from, function (value, level) {\r\n      if (value > to) {\r\n        return true;\r\n      }\r\n      for (var index in level.rectangles) {\r\n        if (level.rectangles.hasOwnProperty(index)) {\r\n          var key = rectIndex > index ? rectIndex + \"-\" + index : index + \"-\" + rectIndex;\r\n          if (!processed.hasOwnProperty(key)) {\r\n            processed[key] = true;\r\n            onCrossing.call(thisArg, rect, rectangles[index]);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (onCrossing != null) {\r\n\r\n    // Create action items out of rectangles\r\n    var actions = [];\r\n    for (var index = 0; index < rectangles.length; index += 1) {\r\n      var rect = rectangles[index];\r\n\r\n      actions.push(new Action(1, index, rect.x, rect));\r\n      actions.push(new Action(0, index, rect.right(), rect));\r\n    }\r\n\r\n    actions.sort(function (a, b) {\r\n      if (a.x == b.x) {\r\n        return b.isStart - a.isStart;\r\n      }\r\n      return a.x - b.x;\r\n    });\r\n\r\n    /* find intersections */\r\n    var buffer = SortedList();\r\n    var levels = {};\r\n    var processed = {};\r\n\r\n    for (index = 0; index < actions.length; index += 1) {\r\n      var action = actions[index];\r\n      var actionLevels = [action.rect.y, action.rect.bottom()];\r\n\r\n      if (action.isStart == 1) {\r\n        // Search for intersections of the left side of the rectangle with existing horizontal segments\r\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\r\n\r\n        // add rectangle's horizontal segments\r\n        for (var index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\r\n          var value = actionLevels[index2];\r\n          var level = levels[value];\r\n          if (level == null) {\r\n            level = new Level();\r\n            levels[value] = level;\r\n\r\n            buffer.add(value, level);\r\n          }\r\n          level.add(action.index);\r\n        }\r\n      } else {\r\n        // remove rectangle's horizontal segments\r\n        for (index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\r\n          value = actionLevels[index2];\r\n          level = levels[value];\r\n          if (level.remove(action.index)) {\r\n            delete levels[value];\r\n            buffer.remove(value);\r\n          }\r\n        }\r\n\r\n        // Search for intersections of the right side of rectangle with existing horizontal segments\r\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}