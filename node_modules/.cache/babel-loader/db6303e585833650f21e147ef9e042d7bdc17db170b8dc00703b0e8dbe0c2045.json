{"ast":null,"code":"import { isObject, cloneObject, isEmptyObject } from '../common';\n/**\r\n * Creates tree structure\r\n * @class Tree\r\n * \r\n * @param {Tree} source A source tree structure to clone properties from\r\n * @returns {Tree} Returns new tree structure\r\n */\nexport default function Tree(source) {\n  var _nodes = {},\n    // objects attached to nodes\n    _parents = {},\n    // parent node id for every node id. Both of them should exists in the tree.\n    _children = {},\n    // children node ids for every node id. All children and node itself should be in the tree.\n    _roots = {},\n    // id of non existing parent. If parent does not exists in the tree this hash contains its id.\n    _rootChildren = {},\n    // children of non existing parent. If parent id does not exists in the tree this collection contains it existing children.\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\n    BREAK = 1,\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\n    SKIP = 2;\n  _init(source);\n  function _init(source) {\n    if (isObject(source)) {\n      _nodes = cloneObject(source.nodes, true);\n      _parents = cloneObject(source.parents, true);\n      _children = cloneObject(source.children, false);\n      _roots = cloneObject(source.roots, false);\n      _rootChildren = cloneObject(source.rootChildren, true);\n    }\n  }\n\n  /**\r\n   * Callback for iterating tree nodes\r\n   * \r\n   * @callback onTreeItemCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @returns {boolean} Returns true to break the loop\r\n   */\n\n  /**\r\n   * Loops through nodes of tree structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeItemCallback} onItem Callback function to call for every tree node \r\n   */\n  function loop(thisArg, onItem) {\n    var item;\n    if (onItem != null) {\n      for (item in _nodes) {\n        if (_nodes.hasOwnProperty(item)) {\n          if (onItem.call(thisArg, item, _nodes[item])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback for iterating the tree nodes level by level\r\n   * \r\n   * @callback onTreeItemWithLevelCallback\r\n   * @param {string} nodeid The node id\r\n   * @param {object} node The node context object\r\n   * @param {number} levelIndex The node level index\r\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n   */\n\n  /**\r\n   * Loops through child nodes of the tree structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} arg0 The node id to start children traversing\r\n   * @param {onTreeItemWithLevelCallback} arg1 Callback function to call for every child node \r\n   */\n  function loopLevels(thisArg, arg0, arg1) {\n    var levelIndex = 0,\n      items = [],\n      itemid,\n      onItem,\n      newItems,\n      key,\n      index,\n      len;\n    switch (arguments.length) {\n      case 2:\n        onItem = arg0;\n        break;\n      case 3:\n        itemid = arg0;\n        onItem = arg1;\n        break;\n    }\n    if (onItem != null) {\n      if (itemid == null) {\n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            items = items.concat(_rootChildren[key]);\n          }\n        }\n      } else {\n        if (_children[itemid] != null) {\n          items = items.concat(_children[itemid]);\n        }\n      }\n      while (items.length > 0) {\n        newItems = [];\n        for (index = 0, len = items.length; index < len; index += 1) {\n          itemid = items[index];\n          switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n            case BREAK:\n              newItems = [];\n              break;\n            case SKIP:\n              break;\n            default:\n              if (_children[itemid] != null) {\n                newItems = newItems.concat(_children[itemid]);\n              }\n              break;\n          }\n        }\n        items = newItems;\n        levelIndex += 1;\n      }\n    }\n  }\n\n  /**\r\n   * Callback for iterating nodes and providing parent in parameters\r\n   * \r\n   * @callback onTreeItemWithParentCallback\r\n   * @param {string} nodeid The node id\r\n   * @param {object} node The node context object\r\n   * @param {string} parentid The parent node id\r\n   * @param {object} parent The parent node context object\r\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n   */\n\n  /**\r\n   * Traverse tree structure in post order.\r\n   * Children first - parent last\r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeItemWithParentCallback} onItem Callback function to call for every node \r\n   */\n  function loopPostOrder(thisArg, onItem) {\n    var stack = [],\n      nodeid,\n      key,\n      index,\n      prevParent,\n      children;\n    if (onItem != null) {\n      for (key in _rootChildren) {\n        if (_rootChildren.hasOwnProperty(key)) {\n          stack = stack.concat(_rootChildren[key]);\n        }\n      }\n      while (stack.length > 0) {\n        nodeid = stack[stack.length - 1];\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n          }\n        } else {\n          stack.pop();\n          prevParent = _parents[nodeid];\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], prevParent, _nodes[prevParent])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Traverse tree structure in pre order.\r\n   * Parent first - children next\r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} arg0 The node id to start traversing\r\n   * @param {onTreeItemWithParentCallback} arg1 A callback function to call for every node \r\n   */\n  function loopPreOrder(thisArg, arg0, arg1) {\n    var stack = [],\n      nodeid,\n      key,\n      index,\n      parentid,\n      prevParent,\n      children,\n      startNodeId,\n      onItem;\n    switch (arguments.length) {\n      case 2:\n        onItem = arg0;\n        break;\n      case 3:\n        startNodeId = arg0;\n        onItem = arg1;\n        break;\n    }\n    if (onItem != null) {\n      if (!node(startNodeId)) {\n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            stack = stack.concat(_rootChildren[key]);\n          }\n        }\n      } else {\n        stack.push(startNodeId);\n      }\n      while (stack.length > 0) {\n        nodeid = stack[stack.length - 1];\n        if (nodeid != prevParent) {\n          parentid = _parents[nodeid];\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], parentid, _nodes[parentid])) {\n            break;\n          }\n        }\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n          }\n        } else {\n          stack.pop();\n          prevParent = _parents[nodeid];\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback for iterating nodes in euler walk order\r\n   * \r\n   * @callback onItemEulerWalkCallback\r\n   * @param {string} nodeid The node id\r\n   * @param {object} node Context object of the node\r\n   * @param {number} level The node's level\r\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n   */\n\n  /**\r\n   * Loops tree nodes in \"Euler Walk\" order\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onItemEulerWalkCallback} onItem Callback function to call for every node \r\n   */\n  function loopEulerWalk(thisArg, onItem) {\n    var stack = [],\n      nodeid,\n      levels = [],\n      level = 0,\n      key,\n      index,\n      len,\n      prevParent,\n      children;\n    if (onItem != null) {\n      for (key in _rootChildren) {\n        if (_rootChildren.hasOwnProperty(key)) {\n          children = _rootChildren[key];\n          for (index = 0, len = children.length; index < len; index += 1) {\n            stack.push(children[index]);\n            levels.push(0);\n          }\n        }\n      }\n      while (stack.length > 0) {\n        index = stack.length - 1;\n        nodeid = stack[index];\n        level = levels[index];\n        if (onItem.call(thisArg, nodeid, _nodes[nodeid], level)) {\n          break;\n        }\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n            levels.push(level + 1);\n            if (index > 0) {\n              stack.push(nodeid);\n              levels.push(level);\n            }\n          }\n        } else {\n          stack.pop();\n          levels.pop();\n          prevParent = _parents[nodeid];\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback function to return pairs of nodes\r\n   * \r\n   * @callback onZipUpPairCallback\r\n   * @param {string} firstNodeId First node id\r\n   * @param {string} firstParentId Parent id of the first node\r\n   * @param {string} secondNodeid Second node id\r\n   * @param {string} secondParentId Parent id of the second node\r\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n   */\n\n  /**\r\n   * Iterates hierarchy nodes by pairs starting with given pair of start and second nodes and up to the root of the hierarchy.\r\n   * Breaks iteration when callback function returns true.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} firstNodeId The first node to start iteration\r\n   * @param {string} secondNodeid The second node to start iteration\r\n   * @param {onZipUpPairCallback} onZip Callback function to call for every pair of nodes on the way up in the tree structure\r\n   */\n  function zipUp(thisArg, firstNodeId, secondNodeid, onZip) {\n    var firstParentId, secondParentId;\n    if (onZip != null) {\n      while (firstNodeId != null && secondNodeid != null && firstNodeId != secondNodeid) {\n        firstParentId = _parents[firstNodeId];\n        secondParentId = _parents[secondNodeid];\n        if (onZip.call(thisArg, firstNodeId, firstParentId, secondNodeid, secondParentId)) {\n          break;\n        }\n        firstNodeId = firstParentId;\n        secondNodeid = secondParentId;\n      }\n    }\n  }\n\n  /**\r\n   * Loops parents up to the root of the hierarchy starting with the given node.\r\n   * Breaks iteration if callback function returns true.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The node id to start iteration from\r\n   * @param {onTreeItemCallback} onItem Callback function to call for every parent node\r\n   * @param {boolean} includingStartItem If true the first call to callback function is made with start node id\r\n   */\n  function loopParents(thisArg, nodeid, onItem, includingStartItem) {\n    // onItem(nodeid, node)\n    var parentid = nodeid;\n    if (_nodes[parentid] != null) {\n      if (onItem != null) {\n        if (includingStartItem === true) {\n          if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n            return;\n          }\n        }\n        while ((parentid = _parents[parentid]) != null) {\n          if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback function to loop through children of the given node\r\n   * \r\n   * @callback onTreeChildItemCallback\r\n   * @param {string} nodeid Child node id\r\n   * @param {object} node Context object of the child node\r\n   * @param {number} index Index of the child node\r\n   * @param {number} lastIndex Index of the last child\r\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n   */\n\n  /**\r\n   * Loops immediate children of the given node.\r\n   * Breaks iteration if callback function returns true.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The parent node id to loop children of\r\n   * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\r\n   */\n  function loopChildren(thisArg, nodeid, onItem) {\n    // onItem(nodeid, node, index, lastIndex)\n    var items, itemid, index, len;\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n      if (items != null) {\n        for (index = 0, len = items.length; index < len; index += 1) {\n          itemid = items[index];\n          if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback function to loop through range of children for the given node\r\n   * \r\n   * @callback onTreeNodeWithIndexItemCallback\r\n   * @param {string} nodeid Child node id\r\n   * @param {object} node Context object of the child node\r\n   * @param {number} index Index of the child node\r\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n   */\n\n  /**\r\n   * Loops range of immediate children of the given node.\r\n   * Breaks iteration if callback function returns true.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The parent node id to loop children of\r\n   * @param {number} fromIndex Start index of iteration\r\n   * @param {number} toIndex End index of iteration\r\n   * @param {onTreeNodeWithIndexItemCallback} onItem Callback function to call for every child node\r\n   */\n  function loopChildrenRange(thisArg, nodeid, fromIndex, toIndex, onItem) {\n    var items, itemid, index, len;\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n      if (items != null) {\n        if (fromIndex < toIndex) {\n          fromIndex = Math.max(fromIndex, 0);\n          toIndex = Math.min(toIndex, items.length - 1);\n          for (index = fromIndex; index <= toIndex; index += 1) {\n            itemid = items[index];\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n              break;\n            }\n          }\n        } else {\n          fromIndex = Math.min(fromIndex, items.length - 1);\n          toIndex = Math.max(0, toIndex);\n          for (index = fromIndex; index >= toIndex; index -= 1) {\n            itemid = items[index];\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Loops immediate children of the given node in reversed order.\r\n   * Breaks iteration if callback function returns true.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The parent node id to loop children of\r\n   * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\r\n   */\n  function loopChildrenReversed(thisArg, nodeid, onItem) {\n    var items, itemid, index, lastIndex;\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n      lastIndex = items.length - 1;\n      if (items != null) {\n        for (index = lastIndex; index >= 0; index -= 1) {\n          itemid = items[index];\n          if (onItem.call(thisArg, itemid, _nodes[itemid], index, lastIndex)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Orders children of the given node\r\n   * \r\n   * @param {string} nodeid The node id of the parent node which children should be ordered in the tree structure\r\n   * @param {string[]} children Collection of ordered children\r\n   */\n  function arrangeChildren(nodeid, children) {\n    var childid, index, len;\n    children = children.slice(0);\n    if (_nodes[nodeid] != null) {\n      if (_children[nodeid] != null) {\n        if (_children[nodeid].length == children.length) {\n          for (index = 0, len = children.length; index < len; index += 1) {\n            childid = children[index];\n            if (_parents[childid] != nodeid) {\n              throw \"Child \" + childid + \" does not belong to given node!\";\n            }\n          }\n          _children[nodeid] = children;\n        } else {\n          throw \"Collections of children don't match each other!\";\n        }\n      } else {\n        if (children.length > 0) {\n          throw \"Collections of children don't match each other!\";\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Adds new tree item\r\n   * @param {string} parentid Parent id\r\n   * @param {string} nodeid New node id\r\n   * @param {object} node Context object of the new node\r\n   * @param {number} position Position of the new node in the collection of children\r\n   */\n  function add(parentid, nodeid, node, position) {\n    var index, len, children, childid;\n    if (_nodes[nodeid] != null) {\n      throw \"Node already exists\";\n    }\n    if (nodeid != null && node != null && _nodes[nodeid] == null) {\n      if (_nodes[parentid] != null) {\n        _parents[nodeid] = parentid;\n\n        // existing parent\n        if (_children[parentid] != null) {\n          if (position == null) {\n            _children[parentid].push(nodeid);\n          } else {\n            _children[parentid].splice(position, 0, nodeid);\n          }\n        } else {\n          _children[parentid] = [nodeid];\n        }\n      } else {\n        _roots[nodeid] = parentid;\n\n        // missing parent\n        if (_rootChildren[parentid] != null) {\n          if (position == null) {\n            _rootChildren[parentid].push(nodeid);\n          } else {\n            _rootChildren[parentid].splice(position, 0, nodeid);\n          }\n        } else {\n          _rootChildren[parentid] = [nodeid];\n        }\n      }\n      _nodes[nodeid] = node;\n      if (_rootChildren[nodeid] != null) {\n        _children[nodeid] = _rootChildren[nodeid];\n        delete _rootChildren[nodeid];\n        children = _children[nodeid];\n        for (index = 0, len = children.length; index < len; index += 1) {\n          childid = children[index];\n          delete _roots[childid];\n          _parents[childid] = nodeid;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Inserts bundle node into the tree structure. The new bundle node becomes only child node of the parent node.\r\n   * All immediate children of the parent node become children of the inserted bundle node.\r\n   * \r\n   * @param {string} nodeid Parent node id\r\n   * @param {string} bundleid New bundle node id\r\n   * @param {object} bundle Context object of the bundle node\r\n   */\n  function insert(nodeid, bundleid, bundle) {\n    if (_nodes[nodeid] != null && bundleid != null && _nodes[bundleid] == null && bundle != null) {\n      _nodes[bundleid] = bundle;\n      if (_children[nodeid] != null) {\n        _children[bundleid] = _children[nodeid];\n      }\n      _children[nodeid] = [bundleid];\n      loopChildren(this, bundleid, function (childid, node, index) {\n        _parents[childid] = bundleid;\n      });\n      _parents[bundleid] = nodeid;\n    }\n  }\n\n  /**\r\n   * Moves children form one node to another.\r\n   * \r\n   * @param {string} fromNodeid Source node node id\r\n   * @param {string} toNodeId Destination node id\r\n   */\n  function moveChildren(fromNodeid, toNodeId) {\n    if (_nodes[fromNodeid] != null && _nodes[toNodeId] != null && fromNodeid != toNodeId) {\n      if (_children[fromNodeid] != null) {\n        loopChildren(this, fromNodeid, function (childid, node, index) {\n          _parents[childid] = toNodeId;\n        });\n        if (_children[toNodeId] != null) {\n          _children[toNodeId] = _children[toNodeId].concat(_children[fromNodeid]);\n        } else {\n          _children[toNodeId] = _children[fromNodeid];\n        }\n        delete _children[fromNodeid];\n      }\n    }\n  }\n\n  /**\r\n   * Return true if structure has nodes\r\n   * \r\n   * @returns {boolean} Returns true if structure has nodes\r\n   */\n  function hasNodes() {\n    return !isEmptyObject(_rootChildren);\n  }\n\n  /**\r\n   * Returns parent node id\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {string} Returns parent node id\r\n   */\n  function parentid(nodeid) {\n    var result = null;\n    if (_parents[nodeid] != null) {\n      result = _parents[nodeid];\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns context object of the parent node\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {object} Returns context object of the  parent node\r\n   */\n  function parent(nodeid) {\n    var result = null;\n    if (_parents[nodeid] != null) {\n      result = _nodes[_parents[nodeid]];\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns true if node has children\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {boolean} Returns true if node has children\r\n   */\n  function hasChildren(nodeid) {\n    return _children[nodeid] != null;\n  }\n\n  /**\r\n   * Returns number of children\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {number} Returns number of child nodes\r\n   */\n  function countChildren(nodeid) {\n    return _children[nodeid] != null ? _children[nodeid].length : 0;\n  }\n\n  /**\r\n   * Returns number of siblings\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {number} Returns number of siblings\r\n   */\n  function countSiblings(nodeid) {\n    var parent = parentid(nodeid);\n    return parent != null ? _children[parent].length : 0;\n  }\n\n  /**\r\n   * Returns index of the node in the children's collection\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @returns {number} Returns node index\r\n   */\n  function indexOf(nodeid) {\n    var parent = parentid(nodeid);\n    return parent != null ? _children[parent].findIndex(itemid => itemid === nodeid) : null;\n  }\n\n  /**\r\n   * Returns child node by index in the children's collection\r\n   * \r\n   * @param {string} nodeid Node id\r\n   * @param {number} index Child index\r\n   * @returns {object} Returns child node\r\n   */\n  function getChild(parentid, index) {\n    var result = null,\n      children;\n    if ((children = _children[parentid]) != null) {\n      result = _nodes[children[index]];\n    }\n    return result;\n  }\n  function _splice(collection, nodeid) {\n    var index,\n      len = collection.length;\n    for (index = 0; index < len; index += 1) {\n      if (collection[index] == nodeid) {\n        collection.splice(index, 1);\n        return len - 1;\n      }\n    }\n    return len;\n  }\n\n  /**\r\n   * Adds existing node to the children of the parent node\r\n   * \r\n   * @param {string} parentid Parent Node id\r\n   * @param {string} nodeid Node id\r\n   */\n  function adopt(parentid, nodeid) {\n    if (_nodes[parentid] != null && _nodes[nodeid] != null) {\n      if (parentid != nodeid) {\n        if (_roots.hasOwnProperty(nodeid)) {\n          if (!_splice(_rootChildren[_roots[nodeid]], nodeid)) {\n            delete _rootChildren[_roots[nodeid]];\n          }\n          delete _roots[nodeid];\n        }\n        if (_parents.hasOwnProperty(nodeid)) {\n          if (!_splice(_children[_parents[nodeid]], nodeid)) {\n            delete _children[_parents[nodeid]];\n          }\n        }\n        _parents[nodeid] = parentid;\n        if (_children[parentid] != null) {\n          _children[parentid].push(nodeid);\n        } else {\n          _children[parentid] = [nodeid];\n        }\n      } else {\n        throw \"Item cannot be parent of itself!\";\n      }\n    } else {\n      throw \"Both parent and child should be in hierarchy!\";\n    }\n  }\n\n  /**\r\n   * Returns context object\r\n   * @param {string} nodeid Node id\r\n   * @returns {object} Context object of the node\r\n   */\n  function node(nodeid) {\n    return _nodes[nodeid];\n  }\n\n  /**\r\n   * Validates internal data integrity of the structure\r\n   * \r\n   * @returns {boolean} Returns true if structure pass validation\r\n   */\n  function validate() {\n    var result = true,\n      key;\n    for (key in _roots) {\n      if (_roots.hasOwnProperty(key)) {\n        if (_roots[key] != null) {\n          result = false;\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * Clones tree structure\r\n   * \r\n   * @returns {tree} Returns clone of the tree\r\n   */\n  function clone() {\n    return Tree({\n      nodes: _nodes,\n      parents: _parents,\n      children: _children,\n      roots: _roots,\n      rootChildren: _rootChildren\n    });\n  }\n\n  /**\r\n   * Callback for iterating tree node neighbours level by level\r\n   * \r\n   * @callback onTreeItemNeighbourCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} distance The neigbour node distance from the start node\r\n   * @returns {number} Returns true to skip further neighbous traversing.\r\n   */\n\n  /**\r\n   * Loops through the node neighbours of the tree structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid The node id to start traversing neighbour nodes\r\n   * @param {number} distance Stop iteration of neighbours when distance exceeds the given value\r\n   * @param {onTreeItemNeighbourCallback} onItem A callback function to call for every neighbour node \r\n   */\n  function loopNeighbours(thisArg, itemid, distance, onItem) {\n    var processed = {},\n      margin = [itemid],\n      newMargin,\n      currentDistance = 0;\n    if (onItem != null) {\n      if (_nodes.hasOwnProperty(itemid)) {\n        processed[itemid] = true;\n        while (margin.length > 0) {\n          newMargin = [];\n          for (var index = 0, len = margin.length; index < len; index += 1) {\n            var marginid = margin[index];\n            if (currentDistance > 0) {\n              if (onItem.call(thisArg, marginid, _nodes[marginid], currentDistance)) {\n                return;\n              }\n            }\n            if (currentDistance < distance) {\n              _loopNeighbours(this, marginid, function (neighbourid, neighbour) {\n                if (!processed.hasOwnProperty(neighbourid)) {\n                  newMargin.push(neighbourid);\n                  processed[neighbourid] = true;\n                }\n              });\n            }\n          }\n          margin = newMargin;\n          currentDistance += 1;\n        }\n      }\n    }\n  }\n  function _loopNeighbours(thisArg, itemid, onItem) {\n    if (onItem != null) {\n      if (_nodes.hasOwnProperty(itemid)) {\n        /* loop parent */\n        var parentItemId = parentid(itemid);\n        if (parentItemId != null) {\n          if (onItem.call(thisArg, parentItemId, _nodes[parentItemId])) {\n            return;\n          }\n        }\n        /* loop siblings */\n        loopChildren(thisArg, parentItemId, function (childItemId, childItem) {\n          if (childItemId != itemid) {\n            if (onItem.call(thisArg, childItemId, childItem)) {\n              return;\n            }\n          }\n        });\n        /* loop actual children */\n        loopChildren(thisArg, itemid, function (childItemId, childItem) {\n          if (onItem.call(thisArg, childItemId, childItem)) {\n            return;\n          }\n        });\n      }\n    }\n  }\n  return {\n    loop: loop,\n    loopLevels: loopLevels,\n    loopParents: loopParents,\n    loopChildren: loopChildren,\n    loopChildrenRange: loopChildrenRange,\n    loopChildrenReversed: loopChildrenReversed,\n    loopPostOrder: loopPostOrder,\n    /* children first - parent last */\n    loopPreOrder: loopPreOrder,\n    /* parent first - children next */\n    loopEulerWalk: loopEulerWalk,\n    /* pre order loop with every parent revisited for every child */\n    loopNeighbours: loopNeighbours,\n    /* loop items by distance. Siblings are as far as parent and children */\n    zipUp: zipUp,\n    parentid: parentid,\n    parent: parent,\n    adopt: adopt,\n    moveChildren: moveChildren,\n    node: node,\n    add: add,\n    insert: insert,\n    hasNodes: hasNodes,\n    hasChildren: hasChildren,\n    countChildren: countChildren,\n    countSiblings: countSiblings,\n    indexOf: indexOf,\n    getChild: getChild,\n    arrangeChildren: arrangeChildren,\n    /* force validation */\n    validate: validate,\n    clone: clone,\n    // callback return codes\n    BREAK: BREAK,\n    // break loop immidiatly\n    SKIP: SKIP // skip loop of current node children \n  };\n}\n;","map":{"version":3,"names":["isObject","cloneObject","isEmptyObject","Tree","source","_nodes","_parents","_children","_roots","_rootChildren","BREAK","SKIP","_init","nodes","parents","children","roots","rootChildren","loop","thisArg","onItem","item","hasOwnProperty","call","loopLevels","arg0","arg1","levelIndex","items","itemid","newItems","key","index","len","arguments","length","concat","loopPostOrder","stack","nodeid","prevParent","push","pop","loopPreOrder","parentid","startNodeId","node","loopEulerWalk","levels","level","zipUp","firstNodeId","secondNodeid","onZip","firstParentId","secondParentId","loopParents","includingStartItem","loopChildren","loopChildrenRange","fromIndex","toIndex","Math","max","min","loopChildrenReversed","lastIndex","arrangeChildren","childid","slice","add","position","splice","insert","bundleid","bundle","moveChildren","fromNodeid","toNodeId","hasNodes","result","parent","hasChildren","countChildren","countSiblings","indexOf","findIndex","getChild","_splice","collection","adopt","validate","clone","loopNeighbours","distance","processed","margin","newMargin","currentDistance","marginid","_loopNeighbours","neighbourid","neighbour","parentItemId","childItemId","childItem"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/Tree.js"],"sourcesContent":["import { isObject, cloneObject, isEmptyObject } from '../common'\r\n/**\r\n * Creates tree structure\r\n * @class Tree\r\n * \r\n * @param {Tree} source A source tree structure to clone properties from\r\n * @returns {Tree} Returns new tree structure\r\n */\r\nexport default function Tree(source) {\r\n    var _nodes = {},        // objects attached to nodes\r\n      _parents = {},      // parent node id for every node id. Both of them should exists in the tree.\r\n      _children = {},     // children node ids for every node id. All children and node itself should be in the tree.\r\n      _roots = {},        // id of non existing parent. If parent does not exists in the tree this hash contains its id.\r\n      _rootChildren = {}, // children of non existing parent. If parent id does not exists in the tree this collection contains it existing children.\r\n      /** @constant\r\n        @type {number}\r\n        @default\r\n      */\r\n      BREAK = 1,\r\n      /** @constant\r\n        @type {number}\r\n        @default\r\n      */\r\n      SKIP = 2;\r\n  \r\n    _init(source);\r\n  \r\n    function _init(source) {\r\n      if (isObject(source)) {\r\n        _nodes = cloneObject(source.nodes, true);\r\n        _parents = cloneObject(source.parents, true);\r\n        _children = cloneObject(source.children, false);\r\n        _roots = cloneObject(source.roots, false);\r\n        _rootChildren = cloneObject(source.rootChildren, true);\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback for iterating tree nodes\r\n     * \r\n     * @callback onTreeItemCallback\r\n     * @param {string} itemid The node id\r\n     * @param {object} item The node\r\n     * @returns {boolean} Returns true to break the loop\r\n     */\r\n  \r\n    /**\r\n     * Loops through nodes of tree structure\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {onTreeItemCallback} onItem Callback function to call for every tree node \r\n     */\r\n    function loop(thisArg, onItem) {\r\n      var item;\r\n      if (onItem != null) {\r\n        for (item in _nodes) {\r\n          if (_nodes.hasOwnProperty(item)) {\r\n            if (onItem.call(thisArg, item, _nodes[item])) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback for iterating the tree nodes level by level\r\n     * \r\n     * @callback onTreeItemWithLevelCallback\r\n     * @param {string} nodeid The node id\r\n     * @param {object} node The node context object\r\n     * @param {number} levelIndex The node level index\r\n     * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n     */\r\n  \r\n    /**\r\n     * Loops through child nodes of the tree structure level by level\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} arg0 The node id to start children traversing\r\n     * @param {onTreeItemWithLevelCallback} arg1 Callback function to call for every child node \r\n     */\r\n    function loopLevels(thisArg, arg0, arg1) {\r\n      var levelIndex = 0,\r\n        items = [],\r\n        itemid,\r\n        onItem,\r\n        newItems,\r\n        key,\r\n        index, len;\r\n  \r\n      switch (arguments.length) {\r\n        case 2:\r\n          onItem = arg0;\r\n          break;\r\n        case 3:\r\n          itemid = arg0;\r\n          onItem = arg1;\r\n          break;\r\n      }\r\n  \r\n      if (onItem != null) {\r\n  \r\n        if (itemid == null) {\r\n          for (key in _rootChildren) {\r\n            if (_rootChildren.hasOwnProperty(key)) {\r\n              items = items.concat(_rootChildren[key]);\r\n            }\r\n          }\r\n        } else {\r\n          if (_children[itemid] != null) {\r\n            items = items.concat(_children[itemid]);\r\n          }\r\n        }\r\n  \r\n        while (items.length > 0) {\r\n          newItems = [];\r\n  \r\n          for (index = 0, len = items.length; index < len; index += 1) {\r\n            itemid = items[index];\r\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\r\n              case BREAK:\r\n                newItems = [];\r\n                break;\r\n              case SKIP:\r\n                break;\r\n              default:\r\n                if (_children[itemid] != null) {\r\n                  newItems = newItems.concat(_children[itemid]);\r\n                }\r\n                break;\r\n            }\r\n          }\r\n  \r\n          items = newItems;\r\n          levelIndex += 1;\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback for iterating nodes and providing parent in parameters\r\n     * \r\n     * @callback onTreeItemWithParentCallback\r\n     * @param {string} nodeid The node id\r\n     * @param {object} node The node context object\r\n     * @param {string} parentid The parent node id\r\n     * @param {object} parent The parent node context object\r\n     * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n     */\r\n  \r\n    /**\r\n     * Traverse tree structure in post order.\r\n     * Children first - parent last\r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {onTreeItemWithParentCallback} onItem Callback function to call for every node \r\n     */\r\n    function loopPostOrder(thisArg, onItem) {\r\n      var stack = [], nodeid,\r\n        key,\r\n        index,\r\n        prevParent,\r\n        children;\r\n  \r\n      if (onItem != null) {\r\n  \r\n        for (key in _rootChildren) {\r\n          if (_rootChildren.hasOwnProperty(key)) {\r\n            stack = stack.concat(_rootChildren[key]);\r\n          }\r\n        }\r\n  \r\n        while (stack.length > 0) {\r\n          nodeid = stack[stack.length - 1];\r\n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\r\n            for (index = children.length - 1; index >= 0; index -= 1) {\r\n              stack.push(children[index]);\r\n            }\r\n          } else {\r\n            stack.pop();\r\n            prevParent = _parents[nodeid];\r\n  \r\n            if (onItem.call(thisArg, nodeid, _nodes[nodeid], prevParent, _nodes[prevParent])) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n  \r\n    /**\r\n     * Traverse tree structure in pre order.\r\n     * Parent first - children next\r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} arg0 The node id to start traversing\r\n     * @param {onTreeItemWithParentCallback} arg1 A callback function to call for every node \r\n     */\r\n    function loopPreOrder(thisArg, arg0, arg1) {\r\n      var stack = [], nodeid,\r\n        key,\r\n        index,\r\n        parentid,\r\n        prevParent,\r\n        children,\r\n        startNodeId,\r\n        onItem;\r\n  \r\n      switch (arguments.length) {\r\n        case 2:\r\n          onItem = arg0;\r\n          break;\r\n        case 3:\r\n          startNodeId = arg0;\r\n          onItem = arg1;\r\n          break;\r\n      }\r\n\r\n      if (onItem != null) {\r\n  \r\n        if(!node(startNodeId)) {\r\n          for (key in _rootChildren) {\r\n            if (_rootChildren.hasOwnProperty(key)) {\r\n              stack = stack.concat(_rootChildren[key]);\r\n            }\r\n          }\r\n        } else {\r\n          stack.push(startNodeId);\r\n        }\r\n  \r\n        while (stack.length > 0) {\r\n          nodeid = stack[stack.length - 1];\r\n          if (nodeid != prevParent) {\r\n            parentid = _parents[nodeid];\r\n            if (onItem.call(thisArg, nodeid, _nodes[nodeid], parentid, _nodes[parentid])) {\r\n              break;\r\n            }\r\n          }\r\n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\r\n            for (index = children.length - 1; index >= 0; index -= 1) {\r\n              stack.push(children[index]);\r\n            }\r\n          } else {\r\n            stack.pop();\r\n            prevParent = _parents[nodeid];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback for iterating nodes in euler walk order\r\n     * \r\n     * @callback onItemEulerWalkCallback\r\n     * @param {string} nodeid The node id\r\n     * @param {object} node Context object of the node\r\n     * @param {number} level The node's level\r\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n     */\r\n  \r\n    /**\r\n     * Loops tree nodes in \"Euler Walk\" order\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {onItemEulerWalkCallback} onItem Callback function to call for every node \r\n     */\r\n    function loopEulerWalk(thisArg, onItem) {\r\n      var stack = [],\r\n        nodeid,\r\n        levels = [],\r\n        level = 0,\r\n        key,\r\n        index, len,\r\n        prevParent,\r\n        children;\r\n  \r\n      if (onItem != null) {\r\n  \r\n        for (key in _rootChildren) {\r\n          if (_rootChildren.hasOwnProperty(key)) {\r\n            children = _rootChildren[key];\r\n            for (index = 0, len = children.length; index < len; index += 1) {\r\n              stack.push(children[index]);\r\n              levels.push(0);\r\n            }\r\n          }\r\n        }\r\n        while (stack.length > 0) {\r\n          index = stack.length - 1;\r\n          nodeid = stack[index];\r\n          level = levels[index];\r\n  \r\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], level)) {\r\n            break;\r\n          }\r\n  \r\n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\r\n            for (index = children.length - 1; index >= 0; index -= 1) {\r\n              stack.push(children[index]);\r\n              levels.push(level + 1);\r\n              if (index > 0) {\r\n                stack.push(nodeid);\r\n                levels.push(level);\r\n              }\r\n            }\r\n          } else {\r\n            stack.pop();\r\n            levels.pop();\r\n  \r\n            prevParent = _parents[nodeid];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback function to return pairs of nodes\r\n     * \r\n     * @callback onZipUpPairCallback\r\n     * @param {string} firstNodeId First node id\r\n     * @param {string} firstParentId Parent id of the first node\r\n     * @param {string} secondNodeid Second node id\r\n     * @param {string} secondParentId Parent id of the second node\r\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n     */\r\n  \r\n    /**\r\n     * Iterates hierarchy nodes by pairs starting with given pair of start and second nodes and up to the root of the hierarchy.\r\n     * Breaks iteration when callback function returns true.\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} firstNodeId The first node to start iteration\r\n     * @param {string} secondNodeid The second node to start iteration\r\n     * @param {onZipUpPairCallback} onZip Callback function to call for every pair of nodes on the way up in the tree structure\r\n     */\r\n    function zipUp(thisArg, firstNodeId, secondNodeid, onZip) {\r\n      var firstParentId,\r\n        secondParentId;\r\n  \r\n      if (onZip != null) {\r\n        while (firstNodeId != null && secondNodeid != null && firstNodeId != secondNodeid) {\r\n          firstParentId = _parents[firstNodeId];\r\n          secondParentId = _parents[secondNodeid];\r\n          if (onZip.call(thisArg, firstNodeId, firstParentId, secondNodeid, secondParentId)) {\r\n            break;\r\n          }\r\n          firstNodeId = firstParentId;\r\n          secondNodeid = secondParentId;\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Loops parents up to the root of the hierarchy starting with the given node.\r\n     * Breaks iteration if callback function returns true.\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} nodeid The node id to start iteration from\r\n     * @param {onTreeItemCallback} onItem Callback function to call for every parent node\r\n     * @param {boolean} includingStartItem If true the first call to callback function is made with start node id\r\n     */\r\n    function loopParents(thisArg, nodeid, onItem, includingStartItem) { // onItem(nodeid, node)\r\n      var parentid = nodeid;\r\n      if (_nodes[parentid] != null) {\r\n        if (onItem != null) {\r\n          if (includingStartItem === true) {\r\n            if (onItem.call(thisArg, parentid, _nodes[parentid])) {\r\n              return;\r\n            }\r\n          }\r\n          while ((parentid = _parents[parentid]) != null) {\r\n            if (onItem.call(thisArg, parentid, _nodes[parentid])) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback function to loop through children of the given node\r\n     * \r\n     * @callback onTreeChildItemCallback\r\n     * @param {string} nodeid Child node id\r\n     * @param {object} node Context object of the child node\r\n     * @param {number} index Index of the child node\r\n     * @param {number} lastIndex Index of the last child\r\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n     */\r\n  \r\n    /**\r\n     * Loops immediate children of the given node.\r\n     * Breaks iteration if callback function returns true.\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} nodeid The parent node id to loop children of\r\n     * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\r\n     */\r\n    function loopChildren(thisArg, nodeid, onItem) { // onItem(nodeid, node, index, lastIndex)\r\n      var items,\r\n        itemid,\r\n        index, len;\r\n      if (_nodes[nodeid] != null) {\r\n        items = _children[nodeid];\r\n        if (items != null) {\r\n          for (index = 0, len = items.length; index < len; index += 1) {\r\n            itemid = items[index];\r\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Callback function to loop through range of children for the given node\r\n     * \r\n     * @callback onTreeNodeWithIndexItemCallback\r\n     * @param {string} nodeid Child node id\r\n     * @param {object} node Context object of the child node\r\n     * @param {number} index Index of the child node\r\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\r\n     */\r\n  \r\n    /**\r\n     * Loops range of immediate children of the given node.\r\n     * Breaks iteration if callback function returns true.\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} nodeid The parent node id to loop children of\r\n     * @param {number} fromIndex Start index of iteration\r\n     * @param {number} toIndex End index of iteration\r\n     * @param {onTreeNodeWithIndexItemCallback} onItem Callback function to call for every child node\r\n     */\r\n    function loopChildrenRange(thisArg, nodeid, fromIndex, toIndex, onItem) {\r\n      var items,\r\n        itemid,\r\n        index, len;\r\n      if (_nodes[nodeid] != null) {\r\n        items = _children[nodeid];\r\n        if (items != null) {\r\n          if (fromIndex < toIndex) {\r\n            fromIndex = Math.max(fromIndex, 0);\r\n            toIndex = Math.min(toIndex, items.length - 1);\r\n            for (index = fromIndex; index <= toIndex; index += 1) {\r\n              itemid = items[index];\r\n              if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\r\n                break;\r\n              }\r\n            }\r\n          } else {\r\n            fromIndex = Math.min(fromIndex, items.length - 1);\r\n            toIndex = Math.max(0, toIndex);\r\n            for (index = fromIndex; index >= toIndex; index -= 1) {\r\n              itemid = items[index];\r\n              if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Loops immediate children of the given node in reversed order.\r\n     * Breaks iteration if callback function returns true.\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} nodeid The parent node id to loop children of\r\n     * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\r\n     */\r\n    function loopChildrenReversed(thisArg, nodeid, onItem) {\r\n      var items,\r\n        itemid,\r\n        index, lastIndex;\r\n      if (_nodes[nodeid] != null) {\r\n        items = _children[nodeid];\r\n        lastIndex = items.length - 1;\r\n        if (items != null) {\r\n          for (index = lastIndex; index >= 0; index -= 1) {\r\n            itemid = items[index];\r\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, lastIndex)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Orders children of the given node\r\n     * \r\n     * @param {string} nodeid The node id of the parent node which children should be ordered in the tree structure\r\n     * @param {string[]} children Collection of ordered children\r\n     */\r\n    function arrangeChildren(nodeid, children) {\r\n      var childid,\r\n        index, len;\r\n  \r\n      children = children.slice(0);\r\n      if (_nodes[nodeid] != null) {\r\n        if (_children[nodeid] != null) {\r\n          if (_children[nodeid].length == children.length) {\r\n            for (index = 0, len = children.length; index < len; index += 1) {\r\n              childid = children[index];\r\n              if (_parents[childid] != nodeid) {\r\n                throw \"Child \" + childid + \" does not belong to given node!\";\r\n              }\r\n            }\r\n            _children[nodeid] = children;\r\n          } else {\r\n            throw \"Collections of children don't match each other!\";\r\n          }\r\n        } else {\r\n          if (children.length > 0) {\r\n            throw \"Collections of children don't match each other!\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Adds new tree item\r\n     * @param {string} parentid Parent id\r\n     * @param {string} nodeid New node id\r\n     * @param {object} node Context object of the new node\r\n     * @param {number} position Position of the new node in the collection of children\r\n     */\r\n    function add(parentid, nodeid, node, position) {\r\n      var index, len, children, childid;\r\n  \r\n      if (_nodes[nodeid] != null) {\r\n        throw \"Node already exists\";\r\n      }\r\n  \r\n      if (nodeid != null && node != null && _nodes[nodeid] == null) {\r\n  \r\n        if (_nodes[parentid] != null) {\r\n          _parents[nodeid] = parentid;\r\n  \r\n          // existing parent\r\n          if (_children[parentid] != null) {\r\n            if (position == null) {\r\n              _children[parentid].push(nodeid);\r\n            } else {\r\n              _children[parentid].splice(position, 0, nodeid);\r\n            }\r\n          } else {\r\n            _children[parentid] = [nodeid];\r\n          }\r\n        } else {\r\n          _roots[nodeid] = parentid;\r\n  \r\n          // missing parent\r\n          if (_rootChildren[parentid] != null) {\r\n            if (position == null) {\r\n              _rootChildren[parentid].push(nodeid);\r\n            } else {\r\n              _rootChildren[parentid].splice(position, 0, nodeid);\r\n            }\r\n          } else {\r\n            _rootChildren[parentid] = [nodeid];\r\n          }\r\n        }\r\n  \r\n        _nodes[nodeid] = node;\r\n  \r\n        if (_rootChildren[nodeid] != null) {\r\n          _children[nodeid] = _rootChildren[nodeid];\r\n          delete _rootChildren[nodeid];\r\n  \r\n          children = _children[nodeid];\r\n          for (index = 0, len = children.length; index < len; index += 1) {\r\n            childid = children[index];\r\n  \r\n            delete _roots[childid];\r\n  \r\n            _parents[childid] = nodeid;\r\n          }\r\n  \r\n        }\r\n  \r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Inserts bundle node into the tree structure. The new bundle node becomes only child node of the parent node.\r\n     * All immediate children of the parent node become children of the inserted bundle node.\r\n     * \r\n     * @param {string} nodeid Parent node id\r\n     * @param {string} bundleid New bundle node id\r\n     * @param {object} bundle Context object of the bundle node\r\n     */\r\n    function insert(nodeid, bundleid, bundle) {\r\n      if (_nodes[nodeid] != null && bundleid != null && _nodes[bundleid] == null && bundle != null) {\r\n  \r\n        _nodes[bundleid] = bundle;\r\n  \r\n        if (_children[nodeid] != null) {\r\n          _children[bundleid] = _children[nodeid];\r\n        }\r\n        _children[nodeid] = [bundleid];\r\n  \r\n        loopChildren(this, bundleid, function (childid, node, index) {\r\n          _parents[childid] = bundleid;\r\n        });\r\n        _parents[bundleid] = nodeid;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Moves children form one node to another.\r\n     * \r\n     * @param {string} fromNodeid Source node node id\r\n     * @param {string} toNodeId Destination node id\r\n     */\r\n    function moveChildren(fromNodeid, toNodeId) {\r\n      if (_nodes[fromNodeid] != null && _nodes[toNodeId] != null && fromNodeid != toNodeId) {\r\n  \r\n        if (_children[fromNodeid] != null) {\r\n  \r\n          loopChildren(this, fromNodeid, function (childid, node, index) {\r\n            _parents[childid] = toNodeId;\r\n          });\r\n  \r\n          if (_children[toNodeId] != null) {\r\n            _children[toNodeId] = _children[toNodeId].concat(_children[fromNodeid]);\r\n          } else {\r\n            _children[toNodeId] = _children[fromNodeid];\r\n          }\r\n          delete _children[fromNodeid];\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Return true if structure has nodes\r\n     * \r\n     * @returns {boolean} Returns true if structure has nodes\r\n     */\r\n    function hasNodes() {\r\n      return !isEmptyObject(_rootChildren);\r\n    }\r\n  \r\n    /**\r\n     * Returns parent node id\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {string} Returns parent node id\r\n     */\r\n    function parentid(nodeid) {\r\n      var result = null;\r\n  \r\n      if (_parents[nodeid] != null) {\r\n        result = _parents[nodeid];\r\n      }\r\n  \r\n      return result;\r\n    }\r\n  \r\n    /**\r\n     * Returns context object of the parent node\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {object} Returns context object of the  parent node\r\n     */\r\n    function parent(nodeid) {\r\n      var result = null;\r\n  \r\n      if (_parents[nodeid] != null) {\r\n        result = _nodes[_parents[nodeid]];\r\n      }\r\n  \r\n      return result;\r\n    }\r\n  \r\n    /**\r\n     * Returns true if node has children\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {boolean} Returns true if node has children\r\n     */\r\n    function hasChildren(nodeid) {\r\n      return _children[nodeid] != null;\r\n    }\r\n  \r\n    /**\r\n     * Returns number of children\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {number} Returns number of child nodes\r\n     */\r\n    function countChildren(nodeid) {\r\n      return _children[nodeid] != null ? _children[nodeid].length : 0;\r\n    }\r\n  \r\n    /**\r\n     * Returns number of siblings\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {number} Returns number of siblings\r\n     */\r\n    function countSiblings(nodeid) {\r\n      var parent = parentid(nodeid);\r\n      return parent != null ? _children[parent].length : 0;\r\n    }\r\n  \r\n    /**\r\n     * Returns index of the node in the children's collection\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @returns {number} Returns node index\r\n     */\r\n    function indexOf(nodeid) {\r\n      var parent = parentid(nodeid);\r\n      return parent != null ? _children[parent].findIndex( itemid => itemid === nodeid) : null;\r\n    }\r\n  \r\n    /**\r\n     * Returns child node by index in the children's collection\r\n     * \r\n     * @param {string} nodeid Node id\r\n     * @param {number} index Child index\r\n     * @returns {object} Returns child node\r\n     */\r\n    function getChild(parentid, index) {\r\n      var result = null,\r\n        children;\r\n      if ((children = _children[parentid]) != null) {\r\n        result = _nodes[children[index]];\r\n      }\r\n      return result;\r\n    }\r\n  \r\n    function _splice(collection, nodeid) {\r\n      var index, len = collection.length;\r\n      for (index = 0; index < len; index += 1) {\r\n        if (collection[index] == nodeid) {\r\n          collection.splice(index, 1);\r\n          return len - 1;\r\n        }\r\n      }\r\n      return len;\r\n    }\r\n  \r\n    /**\r\n     * Adds existing node to the children of the parent node\r\n     * \r\n     * @param {string} parentid Parent Node id\r\n     * @param {string} nodeid Node id\r\n     */\r\n    function adopt(parentid, nodeid) {\r\n      if (_nodes[parentid] != null && _nodes[nodeid] != null) {\r\n        if (parentid != nodeid) {\r\n          if (_roots.hasOwnProperty(nodeid)) {\r\n            if (!_splice(_rootChildren[_roots[nodeid]], nodeid)) {\r\n              delete _rootChildren[_roots[nodeid]];\r\n            }\r\n            delete _roots[nodeid];\r\n          }\r\n  \r\n          if (_parents.hasOwnProperty(nodeid)) {\r\n            if (!_splice(_children[_parents[nodeid]], nodeid)) {\r\n              delete _children[_parents[nodeid]];\r\n            }\r\n          }\r\n  \r\n          _parents[nodeid] = parentid;\r\n          if (_children[parentid] != null) {\r\n            _children[parentid].push(nodeid);\r\n          } else {\r\n            _children[parentid] = [nodeid];\r\n          }\r\n        }\r\n        else {\r\n          throw \"Item cannot be parent of itself!\";\r\n        }\r\n      } else {\r\n        throw \"Both parent and child should be in hierarchy!\";\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Returns context object\r\n     * @param {string} nodeid Node id\r\n     * @returns {object} Context object of the node\r\n     */\r\n    function node(nodeid) {\r\n      return _nodes[nodeid];\r\n    }\r\n  \r\n    /**\r\n     * Validates internal data integrity of the structure\r\n     * \r\n     * @returns {boolean} Returns true if structure pass validation\r\n     */\r\n    function validate() {\r\n      var result = true,\r\n        key;\r\n  \r\n      for (key in _roots) {\r\n        if (_roots.hasOwnProperty(key)) {\r\n          if (_roots[key] != null) {\r\n            result = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n  \r\n      return result;\r\n    }\r\n  \r\n    /**\r\n     * Clones tree structure\r\n     * \r\n     * @returns {tree} Returns clone of the tree\r\n     */\r\n    function clone() {\r\n      return Tree({\r\n        nodes: _nodes,\r\n        parents: _parents,\r\n        children: _children,\r\n        roots: _roots,\r\n        rootChildren: _rootChildren\r\n      });\r\n    }\r\n  \r\n  \r\n    /**\r\n     * Callback for iterating tree node neighbours level by level\r\n     * \r\n     * @callback onTreeItemNeighbourCallback\r\n     * @param {string} itemid The node id\r\n     * @param {object} item The node\r\n     * @param {number} distance The neigbour node distance from the start node\r\n     * @returns {number} Returns true to skip further neighbous traversing.\r\n     */\r\n  \r\n    /**\r\n     * Loops through the node neighbours of the tree structure level by level\r\n     * \r\n     * @param {Object} thisArg The callback function invocation context\r\n     * @param {string} itemid The node id to start traversing neighbour nodes\r\n     * @param {number} distance Stop iteration of neighbours when distance exceeds the given value\r\n     * @param {onTreeItemNeighbourCallback} onItem A callback function to call for every neighbour node \r\n     */\r\n    function loopNeighbours(thisArg, itemid, distance, onItem) {\r\n      var processed = {},\r\n        margin = [itemid],\r\n        newMargin,\r\n        currentDistance = 0;\r\n  \r\n      if (onItem != null) {\r\n        if (_nodes.hasOwnProperty(itemid)) {\r\n          processed[itemid] = true;\r\n          while (margin.length > 0) {\r\n            newMargin = [];\r\n            for (var index = 0, len = margin.length; index < len; index += 1) {\r\n              var marginid = margin[index];\r\n              if (currentDistance > 0) {\r\n                if (onItem.call(thisArg, marginid, _nodes[marginid], currentDistance)) {\r\n                  return;\r\n                }\r\n              }\r\n              if (currentDistance < distance) {\r\n                _loopNeighbours(this, marginid, function (neighbourid, neighbour) {\r\n                  if (!processed.hasOwnProperty(neighbourid)) {\r\n                    newMargin.push(neighbourid);\r\n                    processed[neighbourid] = true;\r\n                  }\r\n                });\r\n              }\r\n            }\r\n            margin = newMargin;\r\n            currentDistance += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    function _loopNeighbours(thisArg, itemid, onItem) {\r\n      if (onItem != null) {\r\n        if (_nodes.hasOwnProperty(itemid)) {\r\n          /* loop parent */\r\n          var parentItemId = parentid(itemid);\r\n          if (parentItemId != null) {\r\n            if (onItem.call(thisArg, parentItemId, _nodes[parentItemId])) {\r\n              return;\r\n            }\r\n          }\r\n          /* loop siblings */\r\n          loopChildren(thisArg, parentItemId, function (childItemId, childItem) {\r\n            if (childItemId != itemid) {\r\n              if (onItem.call(thisArg, childItemId, childItem)) {\r\n                return;\r\n              }\r\n            }\r\n          });\r\n          /* loop actual children */\r\n          loopChildren(thisArg, itemid, function (childItemId, childItem) {\r\n            if (onItem.call(thisArg, childItemId, childItem)) {\r\n              return;\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n  \r\n    return {\r\n      loop: loop,\r\n      loopLevels: loopLevels,\r\n      loopParents: loopParents,\r\n      loopChildren: loopChildren,\r\n      loopChildrenRange: loopChildrenRange,\r\n      loopChildrenReversed: loopChildrenReversed,\r\n      loopPostOrder: loopPostOrder, /* children first - parent last */\r\n      loopPreOrder: loopPreOrder, /* parent first - children next */\r\n      loopEulerWalk: loopEulerWalk, /* pre order loop with every parent revisited for every child */\r\n      loopNeighbours: loopNeighbours, /* loop items by distance. Siblings are as far as parent and children */\r\n      zipUp: zipUp,\r\n      parentid: parentid,\r\n      parent: parent,\r\n      adopt: adopt,\r\n      moveChildren: moveChildren,\r\n      node: node,\r\n      add: add,\r\n      insert: insert,\r\n      hasNodes: hasNodes,\r\n      hasChildren: hasChildren,\r\n      countChildren: countChildren,\r\n      countSiblings: countSiblings,\r\n      indexOf: indexOf,\r\n      getChild: getChild,\r\n      arrangeChildren: arrangeChildren,\r\n  \r\n      /* force validation */\r\n      validate: validate,\r\n      clone: clone,\r\n  \r\n      // callback return codes\r\n      BREAK: BREAK, // break loop immidiatly\r\n      SKIP: SKIP // skip loop of current node children \r\n    };\r\n  };"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,aAAa,QAAQ,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,IAAIA,CAACC,MAAM,EAAE;EACjC,IAAIC,MAAM,GAAG,CAAC,CAAC;IAAS;IACtBC,QAAQ,GAAG,CAAC,CAAC;IAAO;IACpBC,SAAS,GAAG,CAAC,CAAC;IAAM;IACpBC,MAAM,GAAG,CAAC,CAAC;IAAS;IACpBC,aAAa,GAAG,CAAC,CAAC;IAAE;IACpB;AACN;AACA;AACA;IACMC,KAAK,GAAG,CAAC;IACT;AACN;AACA;AACA;IACMC,IAAI,GAAG,CAAC;EAEVC,KAAK,CAACR,MAAM,CAAC;EAEb,SAASQ,KAAKA,CAACR,MAAM,EAAE;IACrB,IAAIJ,QAAQ,CAACI,MAAM,CAAC,EAAE;MACpBC,MAAM,GAAGJ,WAAW,CAACG,MAAM,CAACS,KAAK,EAAE,IAAI,CAAC;MACxCP,QAAQ,GAAGL,WAAW,CAACG,MAAM,CAACU,OAAO,EAAE,IAAI,CAAC;MAC5CP,SAAS,GAAGN,WAAW,CAACG,MAAM,CAACW,QAAQ,EAAE,KAAK,CAAC;MAC/CP,MAAM,GAAGP,WAAW,CAACG,MAAM,CAACY,KAAK,EAAE,KAAK,CAAC;MACzCP,aAAa,GAAGR,WAAW,CAACG,MAAM,CAACa,YAAY,EAAE,IAAI,CAAC;IACxD;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;EACI,SAASC,IAAIA,CAACC,OAAO,EAAEC,MAAM,EAAE;IAC7B,IAAIC,IAAI;IACR,IAAID,MAAM,IAAI,IAAI,EAAE;MAClB,KAAKC,IAAI,IAAIhB,MAAM,EAAE;QACnB,IAAIA,MAAM,CAACiB,cAAc,CAACD,IAAI,CAAC,EAAE;UAC/B,IAAID,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEE,IAAI,EAAEhB,MAAM,CAACgB,IAAI,CAAC,CAAC,EAAE;YAC5C;UACF;QACF;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAASG,UAAUA,CAACL,OAAO,EAAEM,IAAI,EAAEC,IAAI,EAAE;IACvC,IAAIC,UAAU,GAAG,CAAC;MAChBC,KAAK,GAAG,EAAE;MACVC,MAAM;MACNT,MAAM;MACNU,QAAQ;MACRC,GAAG;MACHC,KAAK;MAAEC,GAAG;IAEZ,QAAQC,SAAS,CAACC,MAAM;MACtB,KAAK,CAAC;QACJf,MAAM,GAAGK,IAAI;QACb;MACF,KAAK,CAAC;QACJI,MAAM,GAAGJ,IAAI;QACbL,MAAM,GAAGM,IAAI;QACb;IACJ;IAEA,IAAIN,MAAM,IAAI,IAAI,EAAE;MAElB,IAAIS,MAAM,IAAI,IAAI,EAAE;QAClB,KAAKE,GAAG,IAAItB,aAAa,EAAE;UACzB,IAAIA,aAAa,CAACa,cAAc,CAACS,GAAG,CAAC,EAAE;YACrCH,KAAK,GAAGA,KAAK,CAACQ,MAAM,CAAC3B,aAAa,CAACsB,GAAG,CAAC,CAAC;UAC1C;QACF;MACF,CAAC,MAAM;QACL,IAAIxB,SAAS,CAACsB,MAAM,CAAC,IAAI,IAAI,EAAE;UAC7BD,KAAK,GAAGA,KAAK,CAACQ,MAAM,CAAC7B,SAAS,CAACsB,MAAM,CAAC,CAAC;QACzC;MACF;MAEA,OAAOD,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;QACvBL,QAAQ,GAAG,EAAE;QAEb,KAAKE,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGL,KAAK,CAACO,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;UAC3DH,MAAM,GAAGD,KAAK,CAACI,KAAK,CAAC;UACrB,QAAQZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEU,MAAM,EAAExB,MAAM,CAACwB,MAAM,CAAC,EAAEF,UAAU,CAAC;YAC9D,KAAKjB,KAAK;cACRoB,QAAQ,GAAG,EAAE;cACb;YACF,KAAKnB,IAAI;cACP;YACF;cACE,IAAIJ,SAAS,CAACsB,MAAM,CAAC,IAAI,IAAI,EAAE;gBAC7BC,QAAQ,GAAGA,QAAQ,CAACM,MAAM,CAAC7B,SAAS,CAACsB,MAAM,CAAC,CAAC;cAC/C;cACA;UACJ;QACF;QAEAD,KAAK,GAAGE,QAAQ;QAChBH,UAAU,IAAI,CAAC;MACjB;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;EACI,SAASU,aAAaA,CAAClB,OAAO,EAAEC,MAAM,EAAE;IACtC,IAAIkB,KAAK,GAAG,EAAE;MAAEC,MAAM;MACpBR,GAAG;MACHC,KAAK;MACLQ,UAAU;MACVzB,QAAQ;IAEV,IAAIK,MAAM,IAAI,IAAI,EAAE;MAElB,KAAKW,GAAG,IAAItB,aAAa,EAAE;QACzB,IAAIA,aAAa,CAACa,cAAc,CAACS,GAAG,CAAC,EAAE;UACrCO,KAAK,GAAGA,KAAK,CAACF,MAAM,CAAC3B,aAAa,CAACsB,GAAG,CAAC,CAAC;QAC1C;MACF;MAEA,OAAOO,KAAK,CAACH,MAAM,GAAG,CAAC,EAAE;QACvBI,MAAM,GAAGD,KAAK,CAACA,KAAK,CAACH,MAAM,GAAG,CAAC,CAAC;QAChC,IAAII,MAAM,IAAIC,UAAU,IAAI,CAACzB,QAAQ,GAAGR,SAAS,CAACgC,MAAM,CAAC,KAAK,IAAI,EAAE;UAClE,KAAKP,KAAK,GAAGjB,QAAQ,CAACoB,MAAM,GAAG,CAAC,EAAEH,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;YACxDM,KAAK,CAACG,IAAI,CAAC1B,QAAQ,CAACiB,KAAK,CAAC,CAAC;UAC7B;QACF,CAAC,MAAM;UACLM,KAAK,CAACI,GAAG,CAAC,CAAC;UACXF,UAAU,GAAGlC,QAAQ,CAACiC,MAAM,CAAC;UAE7B,IAAInB,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEoB,MAAM,EAAElC,MAAM,CAACkC,MAAM,CAAC,EAAEC,UAAU,EAAEnC,MAAM,CAACmC,UAAU,CAAC,CAAC,EAAE;YAChF;UACF;QACF;MACF;IACF;EACF;;EAGA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAASG,YAAYA,CAACxB,OAAO,EAAEM,IAAI,EAAEC,IAAI,EAAE;IACzC,IAAIY,KAAK,GAAG,EAAE;MAAEC,MAAM;MACpBR,GAAG;MACHC,KAAK;MACLY,QAAQ;MACRJ,UAAU;MACVzB,QAAQ;MACR8B,WAAW;MACXzB,MAAM;IAER,QAAQc,SAAS,CAACC,MAAM;MACtB,KAAK,CAAC;QACJf,MAAM,GAAGK,IAAI;QACb;MACF,KAAK,CAAC;QACJoB,WAAW,GAAGpB,IAAI;QAClBL,MAAM,GAAGM,IAAI;QACb;IACJ;IAEA,IAAIN,MAAM,IAAI,IAAI,EAAE;MAElB,IAAG,CAAC0B,IAAI,CAACD,WAAW,CAAC,EAAE;QACrB,KAAKd,GAAG,IAAItB,aAAa,EAAE;UACzB,IAAIA,aAAa,CAACa,cAAc,CAACS,GAAG,CAAC,EAAE;YACrCO,KAAK,GAAGA,KAAK,CAACF,MAAM,CAAC3B,aAAa,CAACsB,GAAG,CAAC,CAAC;UAC1C;QACF;MACF,CAAC,MAAM;QACLO,KAAK,CAACG,IAAI,CAACI,WAAW,CAAC;MACzB;MAEA,OAAOP,KAAK,CAACH,MAAM,GAAG,CAAC,EAAE;QACvBI,MAAM,GAAGD,KAAK,CAACA,KAAK,CAACH,MAAM,GAAG,CAAC,CAAC;QAChC,IAAII,MAAM,IAAIC,UAAU,EAAE;UACxBI,QAAQ,GAAGtC,QAAQ,CAACiC,MAAM,CAAC;UAC3B,IAAInB,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEoB,MAAM,EAAElC,MAAM,CAACkC,MAAM,CAAC,EAAEK,QAAQ,EAAEvC,MAAM,CAACuC,QAAQ,CAAC,CAAC,EAAE;YAC5E;UACF;QACF;QACA,IAAIL,MAAM,IAAIC,UAAU,IAAI,CAACzB,QAAQ,GAAGR,SAAS,CAACgC,MAAM,CAAC,KAAK,IAAI,EAAE;UAClE,KAAKP,KAAK,GAAGjB,QAAQ,CAACoB,MAAM,GAAG,CAAC,EAAEH,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;YACxDM,KAAK,CAACG,IAAI,CAAC1B,QAAQ,CAACiB,KAAK,CAAC,CAAC;UAC7B;QACF,CAAC,MAAM;UACLM,KAAK,CAACI,GAAG,CAAC,CAAC;UACXF,UAAU,GAAGlC,QAAQ,CAACiC,MAAM,CAAC;QAC/B;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;EACI,SAASQ,aAAaA,CAAC5B,OAAO,EAAEC,MAAM,EAAE;IACtC,IAAIkB,KAAK,GAAG,EAAE;MACZC,MAAM;MACNS,MAAM,GAAG,EAAE;MACXC,KAAK,GAAG,CAAC;MACTlB,GAAG;MACHC,KAAK;MAAEC,GAAG;MACVO,UAAU;MACVzB,QAAQ;IAEV,IAAIK,MAAM,IAAI,IAAI,EAAE;MAElB,KAAKW,GAAG,IAAItB,aAAa,EAAE;QACzB,IAAIA,aAAa,CAACa,cAAc,CAACS,GAAG,CAAC,EAAE;UACrChB,QAAQ,GAAGN,aAAa,CAACsB,GAAG,CAAC;UAC7B,KAAKC,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGlB,QAAQ,CAACoB,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;YAC9DM,KAAK,CAACG,IAAI,CAAC1B,QAAQ,CAACiB,KAAK,CAAC,CAAC;YAC3BgB,MAAM,CAACP,IAAI,CAAC,CAAC,CAAC;UAChB;QACF;MACF;MACA,OAAOH,KAAK,CAACH,MAAM,GAAG,CAAC,EAAE;QACvBH,KAAK,GAAGM,KAAK,CAACH,MAAM,GAAG,CAAC;QACxBI,MAAM,GAAGD,KAAK,CAACN,KAAK,CAAC;QACrBiB,KAAK,GAAGD,MAAM,CAAChB,KAAK,CAAC;QAErB,IAAIZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEoB,MAAM,EAAElC,MAAM,CAACkC,MAAM,CAAC,EAAEU,KAAK,CAAC,EAAE;UACvD;QACF;QAEA,IAAIV,MAAM,IAAIC,UAAU,IAAI,CAACzB,QAAQ,GAAGR,SAAS,CAACgC,MAAM,CAAC,KAAK,IAAI,EAAE;UAClE,KAAKP,KAAK,GAAGjB,QAAQ,CAACoB,MAAM,GAAG,CAAC,EAAEH,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;YACxDM,KAAK,CAACG,IAAI,CAAC1B,QAAQ,CAACiB,KAAK,CAAC,CAAC;YAC3BgB,MAAM,CAACP,IAAI,CAACQ,KAAK,GAAG,CAAC,CAAC;YACtB,IAAIjB,KAAK,GAAG,CAAC,EAAE;cACbM,KAAK,CAACG,IAAI,CAACF,MAAM,CAAC;cAClBS,MAAM,CAACP,IAAI,CAACQ,KAAK,CAAC;YACpB;UACF;QACF,CAAC,MAAM;UACLX,KAAK,CAACI,GAAG,CAAC,CAAC;UACXM,MAAM,CAACN,GAAG,CAAC,CAAC;UAEZF,UAAU,GAAGlC,QAAQ,CAACiC,MAAM,CAAC;QAC/B;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASW,KAAKA,CAAC/B,OAAO,EAAEgC,WAAW,EAAEC,YAAY,EAAEC,KAAK,EAAE;IACxD,IAAIC,aAAa,EACfC,cAAc;IAEhB,IAAIF,KAAK,IAAI,IAAI,EAAE;MACjB,OAAOF,WAAW,IAAI,IAAI,IAAIC,YAAY,IAAI,IAAI,IAAID,WAAW,IAAIC,YAAY,EAAE;QACjFE,aAAa,GAAGhD,QAAQ,CAAC6C,WAAW,CAAC;QACrCI,cAAc,GAAGjD,QAAQ,CAAC8C,YAAY,CAAC;QACvC,IAAIC,KAAK,CAAC9B,IAAI,CAACJ,OAAO,EAAEgC,WAAW,EAAEG,aAAa,EAAEF,YAAY,EAAEG,cAAc,CAAC,EAAE;UACjF;QACF;QACAJ,WAAW,GAAGG,aAAa;QAC3BF,YAAY,GAAGG,cAAc;MAC/B;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASC,WAAWA,CAACrC,OAAO,EAAEoB,MAAM,EAAEnB,MAAM,EAAEqC,kBAAkB,EAAE;IAAE;IAClE,IAAIb,QAAQ,GAAGL,MAAM;IACrB,IAAIlC,MAAM,CAACuC,QAAQ,CAAC,IAAI,IAAI,EAAE;MAC5B,IAAIxB,MAAM,IAAI,IAAI,EAAE;QAClB,IAAIqC,kBAAkB,KAAK,IAAI,EAAE;UAC/B,IAAIrC,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEyB,QAAQ,EAAEvC,MAAM,CAACuC,QAAQ,CAAC,CAAC,EAAE;YACpD;UACF;QACF;QACA,OAAO,CAACA,QAAQ,GAAGtC,QAAQ,CAACsC,QAAQ,CAAC,KAAK,IAAI,EAAE;UAC9C,IAAIxB,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEyB,QAAQ,EAAEvC,MAAM,CAACuC,QAAQ,CAAC,CAAC,EAAE;YACpD;UACF;QACF;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASc,YAAYA,CAACvC,OAAO,EAAEoB,MAAM,EAAEnB,MAAM,EAAE;IAAE;IAC/C,IAAIQ,KAAK,EACPC,MAAM,EACNG,KAAK,EAAEC,GAAG;IACZ,IAAI5B,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC1BX,KAAK,GAAGrB,SAAS,CAACgC,MAAM,CAAC;MACzB,IAAIX,KAAK,IAAI,IAAI,EAAE;QACjB,KAAKI,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGL,KAAK,CAACO,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;UAC3DH,MAAM,GAAGD,KAAK,CAACI,KAAK,CAAC;UACrB,IAAIZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEU,MAAM,EAAExB,MAAM,CAACwB,MAAM,CAAC,EAAEG,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE;YAChE;UACF;QACF;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS0B,iBAAiBA,CAACxC,OAAO,EAAEoB,MAAM,EAAEqB,SAAS,EAAEC,OAAO,EAAEzC,MAAM,EAAE;IACtE,IAAIQ,KAAK,EACPC,MAAM,EACNG,KAAK,EAAEC,GAAG;IACZ,IAAI5B,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC1BX,KAAK,GAAGrB,SAAS,CAACgC,MAAM,CAAC;MACzB,IAAIX,KAAK,IAAI,IAAI,EAAE;QACjB,IAAIgC,SAAS,GAAGC,OAAO,EAAE;UACvBD,SAAS,GAAGE,IAAI,CAACC,GAAG,CAACH,SAAS,EAAE,CAAC,CAAC;UAClCC,OAAO,GAAGC,IAAI,CAACE,GAAG,CAACH,OAAO,EAAEjC,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC;UAC7C,KAAKH,KAAK,GAAG4B,SAAS,EAAE5B,KAAK,IAAI6B,OAAO,EAAE7B,KAAK,IAAI,CAAC,EAAE;YACpDH,MAAM,GAAGD,KAAK,CAACI,KAAK,CAAC;YACrB,IAAIZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEU,MAAM,EAAExB,MAAM,CAACwB,MAAM,CAAC,EAAEG,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE;cAChE;YACF;UACF;QACF,CAAC,MAAM;UACL2B,SAAS,GAAGE,IAAI,CAACE,GAAG,CAACJ,SAAS,EAAEhC,KAAK,CAACO,MAAM,GAAG,CAAC,CAAC;UACjD0B,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEF,OAAO,CAAC;UAC9B,KAAK7B,KAAK,GAAG4B,SAAS,EAAE5B,KAAK,IAAI6B,OAAO,EAAE7B,KAAK,IAAI,CAAC,EAAE;YACpDH,MAAM,GAAGD,KAAK,CAACI,KAAK,CAAC;YACrB,IAAIZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEU,MAAM,EAAExB,MAAM,CAACwB,MAAM,CAAC,EAAEG,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE;cAChE;YACF;UACF;QACF;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASgC,oBAAoBA,CAAC9C,OAAO,EAAEoB,MAAM,EAAEnB,MAAM,EAAE;IACrD,IAAIQ,KAAK,EACPC,MAAM,EACNG,KAAK,EAAEkC,SAAS;IAClB,IAAI7D,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC1BX,KAAK,GAAGrB,SAAS,CAACgC,MAAM,CAAC;MACzB2B,SAAS,GAAGtC,KAAK,CAACO,MAAM,GAAG,CAAC;MAC5B,IAAIP,KAAK,IAAI,IAAI,EAAE;QACjB,KAAKI,KAAK,GAAGkC,SAAS,EAAElC,KAAK,IAAI,CAAC,EAAEA,KAAK,IAAI,CAAC,EAAE;UAC9CH,MAAM,GAAGD,KAAK,CAACI,KAAK,CAAC;UACrB,IAAIZ,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEU,MAAM,EAAExB,MAAM,CAACwB,MAAM,CAAC,EAAEG,KAAK,EAAEkC,SAAS,CAAC,EAAE;YAClE;UACF;QACF;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASC,eAAeA,CAAC5B,MAAM,EAAExB,QAAQ,EAAE;IACzC,IAAIqD,OAAO,EACTpC,KAAK,EAAEC,GAAG;IAEZlB,QAAQ,GAAGA,QAAQ,CAACsD,KAAK,CAAC,CAAC,CAAC;IAC5B,IAAIhE,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC1B,IAAIhC,SAAS,CAACgC,MAAM,CAAC,IAAI,IAAI,EAAE;QAC7B,IAAIhC,SAAS,CAACgC,MAAM,CAAC,CAACJ,MAAM,IAAIpB,QAAQ,CAACoB,MAAM,EAAE;UAC/C,KAAKH,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGlB,QAAQ,CAACoB,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;YAC9DoC,OAAO,GAAGrD,QAAQ,CAACiB,KAAK,CAAC;YACzB,IAAI1B,QAAQ,CAAC8D,OAAO,CAAC,IAAI7B,MAAM,EAAE;cAC/B,MAAM,QAAQ,GAAG6B,OAAO,GAAG,iCAAiC;YAC9D;UACF;UACA7D,SAAS,CAACgC,MAAM,CAAC,GAAGxB,QAAQ;QAC9B,CAAC,MAAM;UACL,MAAM,iDAAiD;QACzD;MACF,CAAC,MAAM;QACL,IAAIA,QAAQ,CAACoB,MAAM,GAAG,CAAC,EAAE;UACvB,MAAM,iDAAiD;QACzD;MACF;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAASmC,GAAGA,CAAC1B,QAAQ,EAAEL,MAAM,EAAEO,IAAI,EAAEyB,QAAQ,EAAE;IAC7C,IAAIvC,KAAK,EAAEC,GAAG,EAAElB,QAAQ,EAAEqD,OAAO;IAEjC,IAAI/D,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC1B,MAAM,qBAAqB;IAC7B;IAEA,IAAIA,MAAM,IAAI,IAAI,IAAIO,IAAI,IAAI,IAAI,IAAIzC,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MAE5D,IAAIlC,MAAM,CAACuC,QAAQ,CAAC,IAAI,IAAI,EAAE;QAC5BtC,QAAQ,CAACiC,MAAM,CAAC,GAAGK,QAAQ;;QAE3B;QACA,IAAIrC,SAAS,CAACqC,QAAQ,CAAC,IAAI,IAAI,EAAE;UAC/B,IAAI2B,QAAQ,IAAI,IAAI,EAAE;YACpBhE,SAAS,CAACqC,QAAQ,CAAC,CAACH,IAAI,CAACF,MAAM,CAAC;UAClC,CAAC,MAAM;YACLhC,SAAS,CAACqC,QAAQ,CAAC,CAAC4B,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEhC,MAAM,CAAC;UACjD;QACF,CAAC,MAAM;UACLhC,SAAS,CAACqC,QAAQ,CAAC,GAAG,CAACL,MAAM,CAAC;QAChC;MACF,CAAC,MAAM;QACL/B,MAAM,CAAC+B,MAAM,CAAC,GAAGK,QAAQ;;QAEzB;QACA,IAAInC,aAAa,CAACmC,QAAQ,CAAC,IAAI,IAAI,EAAE;UACnC,IAAI2B,QAAQ,IAAI,IAAI,EAAE;YACpB9D,aAAa,CAACmC,QAAQ,CAAC,CAACH,IAAI,CAACF,MAAM,CAAC;UACtC,CAAC,MAAM;YACL9B,aAAa,CAACmC,QAAQ,CAAC,CAAC4B,MAAM,CAACD,QAAQ,EAAE,CAAC,EAAEhC,MAAM,CAAC;UACrD;QACF,CAAC,MAAM;UACL9B,aAAa,CAACmC,QAAQ,CAAC,GAAG,CAACL,MAAM,CAAC;QACpC;MACF;MAEAlC,MAAM,CAACkC,MAAM,CAAC,GAAGO,IAAI;MAErB,IAAIrC,aAAa,CAAC8B,MAAM,CAAC,IAAI,IAAI,EAAE;QACjChC,SAAS,CAACgC,MAAM,CAAC,GAAG9B,aAAa,CAAC8B,MAAM,CAAC;QACzC,OAAO9B,aAAa,CAAC8B,MAAM,CAAC;QAE5BxB,QAAQ,GAAGR,SAAS,CAACgC,MAAM,CAAC;QAC5B,KAAKP,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAGlB,QAAQ,CAACoB,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;UAC9DoC,OAAO,GAAGrD,QAAQ,CAACiB,KAAK,CAAC;UAEzB,OAAOxB,MAAM,CAAC4D,OAAO,CAAC;UAEtB9D,QAAQ,CAAC8D,OAAO,CAAC,GAAG7B,MAAM;QAC5B;MAEF;IAEF;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASkC,MAAMA,CAAClC,MAAM,EAAEmC,QAAQ,EAAEC,MAAM,EAAE;IACxC,IAAItE,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,IAAImC,QAAQ,IAAI,IAAI,IAAIrE,MAAM,CAACqE,QAAQ,CAAC,IAAI,IAAI,IAAIC,MAAM,IAAI,IAAI,EAAE;MAE5FtE,MAAM,CAACqE,QAAQ,CAAC,GAAGC,MAAM;MAEzB,IAAIpE,SAAS,CAACgC,MAAM,CAAC,IAAI,IAAI,EAAE;QAC7BhC,SAAS,CAACmE,QAAQ,CAAC,GAAGnE,SAAS,CAACgC,MAAM,CAAC;MACzC;MACAhC,SAAS,CAACgC,MAAM,CAAC,GAAG,CAACmC,QAAQ,CAAC;MAE9BhB,YAAY,CAAC,IAAI,EAAEgB,QAAQ,EAAE,UAAUN,OAAO,EAAEtB,IAAI,EAAEd,KAAK,EAAE;QAC3D1B,QAAQ,CAAC8D,OAAO,CAAC,GAAGM,QAAQ;MAC9B,CAAC,CAAC;MACFpE,QAAQ,CAACoE,QAAQ,CAAC,GAAGnC,MAAM;IAC7B;EACF;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASqC,YAAYA,CAACC,UAAU,EAAEC,QAAQ,EAAE;IAC1C,IAAIzE,MAAM,CAACwE,UAAU,CAAC,IAAI,IAAI,IAAIxE,MAAM,CAACyE,QAAQ,CAAC,IAAI,IAAI,IAAID,UAAU,IAAIC,QAAQ,EAAE;MAEpF,IAAIvE,SAAS,CAACsE,UAAU,CAAC,IAAI,IAAI,EAAE;QAEjCnB,YAAY,CAAC,IAAI,EAAEmB,UAAU,EAAE,UAAUT,OAAO,EAAEtB,IAAI,EAAEd,KAAK,EAAE;UAC7D1B,QAAQ,CAAC8D,OAAO,CAAC,GAAGU,QAAQ;QAC9B,CAAC,CAAC;QAEF,IAAIvE,SAAS,CAACuE,QAAQ,CAAC,IAAI,IAAI,EAAE;UAC/BvE,SAAS,CAACuE,QAAQ,CAAC,GAAGvE,SAAS,CAACuE,QAAQ,CAAC,CAAC1C,MAAM,CAAC7B,SAAS,CAACsE,UAAU,CAAC,CAAC;QACzE,CAAC,MAAM;UACLtE,SAAS,CAACuE,QAAQ,CAAC,GAAGvE,SAAS,CAACsE,UAAU,CAAC;QAC7C;QACA,OAAOtE,SAAS,CAACsE,UAAU,CAAC;MAC9B;IACF;EACF;;EAEA;AACJ;AACA;AACA;AACA;EACI,SAASE,QAAQA,CAAA,EAAG;IAClB,OAAO,CAAC7E,aAAa,CAACO,aAAa,CAAC;EACtC;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASmC,QAAQA,CAACL,MAAM,EAAE;IACxB,IAAIyC,MAAM,GAAG,IAAI;IAEjB,IAAI1E,QAAQ,CAACiC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC5ByC,MAAM,GAAG1E,QAAQ,CAACiC,MAAM,CAAC;IAC3B;IAEA,OAAOyC,MAAM;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASC,MAAMA,CAAC1C,MAAM,EAAE;IACtB,IAAIyC,MAAM,GAAG,IAAI;IAEjB,IAAI1E,QAAQ,CAACiC,MAAM,CAAC,IAAI,IAAI,EAAE;MAC5ByC,MAAM,GAAG3E,MAAM,CAACC,QAAQ,CAACiC,MAAM,CAAC,CAAC;IACnC;IAEA,OAAOyC,MAAM;EACf;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASE,WAAWA,CAAC3C,MAAM,EAAE;IAC3B,OAAOhC,SAAS,CAACgC,MAAM,CAAC,IAAI,IAAI;EAClC;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAAS4C,aAAaA,CAAC5C,MAAM,EAAE;IAC7B,OAAOhC,SAAS,CAACgC,MAAM,CAAC,IAAI,IAAI,GAAGhC,SAAS,CAACgC,MAAM,CAAC,CAACJ,MAAM,GAAG,CAAC;EACjE;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASiD,aAAaA,CAAC7C,MAAM,EAAE;IAC7B,IAAI0C,MAAM,GAAGrC,QAAQ,CAACL,MAAM,CAAC;IAC7B,OAAO0C,MAAM,IAAI,IAAI,GAAG1E,SAAS,CAAC0E,MAAM,CAAC,CAAC9C,MAAM,GAAG,CAAC;EACtD;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASkD,OAAOA,CAAC9C,MAAM,EAAE;IACvB,IAAI0C,MAAM,GAAGrC,QAAQ,CAACL,MAAM,CAAC;IAC7B,OAAO0C,MAAM,IAAI,IAAI,GAAG1E,SAAS,CAAC0E,MAAM,CAAC,CAACK,SAAS,CAAEzD,MAAM,IAAIA,MAAM,KAAKU,MAAM,CAAC,GAAG,IAAI;EAC1F;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAASgD,QAAQA,CAAC3C,QAAQ,EAAEZ,KAAK,EAAE;IACjC,IAAIgD,MAAM,GAAG,IAAI;MACfjE,QAAQ;IACV,IAAI,CAACA,QAAQ,GAAGR,SAAS,CAACqC,QAAQ,CAAC,KAAK,IAAI,EAAE;MAC5CoC,MAAM,GAAG3E,MAAM,CAACU,QAAQ,CAACiB,KAAK,CAAC,CAAC;IAClC;IACA,OAAOgD,MAAM;EACf;EAEA,SAASQ,OAAOA,CAACC,UAAU,EAAElD,MAAM,EAAE;IACnC,IAAIP,KAAK;MAAEC,GAAG,GAAGwD,UAAU,CAACtD,MAAM;IAClC,KAAKH,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;MACvC,IAAIyD,UAAU,CAACzD,KAAK,CAAC,IAAIO,MAAM,EAAE;QAC/BkD,UAAU,CAACjB,MAAM,CAACxC,KAAK,EAAE,CAAC,CAAC;QAC3B,OAAOC,GAAG,GAAG,CAAC;MAChB;IACF;IACA,OAAOA,GAAG;EACZ;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASyD,KAAKA,CAAC9C,QAAQ,EAAEL,MAAM,EAAE;IAC/B,IAAIlC,MAAM,CAACuC,QAAQ,CAAC,IAAI,IAAI,IAAIvC,MAAM,CAACkC,MAAM,CAAC,IAAI,IAAI,EAAE;MACtD,IAAIK,QAAQ,IAAIL,MAAM,EAAE;QACtB,IAAI/B,MAAM,CAACc,cAAc,CAACiB,MAAM,CAAC,EAAE;UACjC,IAAI,CAACiD,OAAO,CAAC/E,aAAa,CAACD,MAAM,CAAC+B,MAAM,CAAC,CAAC,EAAEA,MAAM,CAAC,EAAE;YACnD,OAAO9B,aAAa,CAACD,MAAM,CAAC+B,MAAM,CAAC,CAAC;UACtC;UACA,OAAO/B,MAAM,CAAC+B,MAAM,CAAC;QACvB;QAEA,IAAIjC,QAAQ,CAACgB,cAAc,CAACiB,MAAM,CAAC,EAAE;UACnC,IAAI,CAACiD,OAAO,CAACjF,SAAS,CAACD,QAAQ,CAACiC,MAAM,CAAC,CAAC,EAAEA,MAAM,CAAC,EAAE;YACjD,OAAOhC,SAAS,CAACD,QAAQ,CAACiC,MAAM,CAAC,CAAC;UACpC;QACF;QAEAjC,QAAQ,CAACiC,MAAM,CAAC,GAAGK,QAAQ;QAC3B,IAAIrC,SAAS,CAACqC,QAAQ,CAAC,IAAI,IAAI,EAAE;UAC/BrC,SAAS,CAACqC,QAAQ,CAAC,CAACH,IAAI,CAACF,MAAM,CAAC;QAClC,CAAC,MAAM;UACLhC,SAAS,CAACqC,QAAQ,CAAC,GAAG,CAACL,MAAM,CAAC;QAChC;MACF,CAAC,MACI;QACH,MAAM,kCAAkC;MAC1C;IACF,CAAC,MAAM;MACL,MAAM,+CAA+C;IACvD;EACF;;EAEA;AACJ;AACA;AACA;AACA;EACI,SAASO,IAAIA,CAACP,MAAM,EAAE;IACpB,OAAOlC,MAAM,CAACkC,MAAM,CAAC;EACvB;;EAEA;AACJ;AACA;AACA;AACA;EACI,SAASoD,QAAQA,CAAA,EAAG;IAClB,IAAIX,MAAM,GAAG,IAAI;MACfjD,GAAG;IAEL,KAAKA,GAAG,IAAIvB,MAAM,EAAE;MAClB,IAAIA,MAAM,CAACc,cAAc,CAACS,GAAG,CAAC,EAAE;QAC9B,IAAIvB,MAAM,CAACuB,GAAG,CAAC,IAAI,IAAI,EAAE;UACvBiD,MAAM,GAAG,KAAK;UACd;QACF;MACF;IACF;IAEA,OAAOA,MAAM;EACf;;EAEA;AACJ;AACA;AACA;AACA;EACI,SAASY,KAAKA,CAAA,EAAG;IACf,OAAOzF,IAAI,CAAC;MACVU,KAAK,EAAER,MAAM;MACbS,OAAO,EAAER,QAAQ;MACjBS,QAAQ,EAAER,SAAS;MACnBS,KAAK,EAAER,MAAM;MACbS,YAAY,EAAER;IAChB,CAAC,CAAC;EACJ;;EAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASoF,cAAcA,CAAC1E,OAAO,EAAEU,MAAM,EAAEiE,QAAQ,EAAE1E,MAAM,EAAE;IACzD,IAAI2E,SAAS,GAAG,CAAC,CAAC;MAChBC,MAAM,GAAG,CAACnE,MAAM,CAAC;MACjBoE,SAAS;MACTC,eAAe,GAAG,CAAC;IAErB,IAAI9E,MAAM,IAAI,IAAI,EAAE;MAClB,IAAIf,MAAM,CAACiB,cAAc,CAACO,MAAM,CAAC,EAAE;QACjCkE,SAAS,CAAClE,MAAM,CAAC,GAAG,IAAI;QACxB,OAAOmE,MAAM,CAAC7D,MAAM,GAAG,CAAC,EAAE;UACxB8D,SAAS,GAAG,EAAE;UACd,KAAK,IAAIjE,KAAK,GAAG,CAAC,EAAEC,GAAG,GAAG+D,MAAM,CAAC7D,MAAM,EAAEH,KAAK,GAAGC,GAAG,EAAED,KAAK,IAAI,CAAC,EAAE;YAChE,IAAImE,QAAQ,GAAGH,MAAM,CAAChE,KAAK,CAAC;YAC5B,IAAIkE,eAAe,GAAG,CAAC,EAAE;cACvB,IAAI9E,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEgF,QAAQ,EAAE9F,MAAM,CAAC8F,QAAQ,CAAC,EAAED,eAAe,CAAC,EAAE;gBACrE;cACF;YACF;YACA,IAAIA,eAAe,GAAGJ,QAAQ,EAAE;cAC9BM,eAAe,CAAC,IAAI,EAAED,QAAQ,EAAE,UAAUE,WAAW,EAAEC,SAAS,EAAE;gBAChE,IAAI,CAACP,SAAS,CAACzE,cAAc,CAAC+E,WAAW,CAAC,EAAE;kBAC1CJ,SAAS,CAACxD,IAAI,CAAC4D,WAAW,CAAC;kBAC3BN,SAAS,CAACM,WAAW,CAAC,GAAG,IAAI;gBAC/B;cACF,CAAC,CAAC;YACJ;UACF;UACAL,MAAM,GAAGC,SAAS;UAClBC,eAAe,IAAI,CAAC;QACtB;MACF;IACF;EACF;EAEA,SAASE,eAAeA,CAACjF,OAAO,EAAEU,MAAM,EAAET,MAAM,EAAE;IAChD,IAAIA,MAAM,IAAI,IAAI,EAAE;MAClB,IAAIf,MAAM,CAACiB,cAAc,CAACO,MAAM,CAAC,EAAE;QACjC;QACA,IAAI0E,YAAY,GAAG3D,QAAQ,CAACf,MAAM,CAAC;QACnC,IAAI0E,YAAY,IAAI,IAAI,EAAE;UACxB,IAAInF,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEoF,YAAY,EAAElG,MAAM,CAACkG,YAAY,CAAC,CAAC,EAAE;YAC5D;UACF;QACF;QACA;QACA7C,YAAY,CAACvC,OAAO,EAAEoF,YAAY,EAAE,UAAUC,WAAW,EAAEC,SAAS,EAAE;UACpE,IAAID,WAAW,IAAI3E,MAAM,EAAE;YACzB,IAAIT,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEqF,WAAW,EAAEC,SAAS,CAAC,EAAE;cAChD;YACF;UACF;QACF,CAAC,CAAC;QACF;QACA/C,YAAY,CAACvC,OAAO,EAAEU,MAAM,EAAE,UAAU2E,WAAW,EAAEC,SAAS,EAAE;UAC9D,IAAIrF,MAAM,CAACG,IAAI,CAACJ,OAAO,EAAEqF,WAAW,EAAEC,SAAS,CAAC,EAAE;YAChD;UACF;QACF,CAAC,CAAC;MACJ;IACF;EACF;EAEA,OAAO;IACLvF,IAAI,EAAEA,IAAI;IACVM,UAAU,EAAEA,UAAU;IACtBgC,WAAW,EAAEA,WAAW;IACxBE,YAAY,EAAEA,YAAY;IAC1BC,iBAAiB,EAAEA,iBAAiB;IACpCM,oBAAoB,EAAEA,oBAAoB;IAC1C5B,aAAa,EAAEA,aAAa;IAAE;IAC9BM,YAAY,EAAEA,YAAY;IAAE;IAC5BI,aAAa,EAAEA,aAAa;IAAE;IAC9B8C,cAAc,EAAEA,cAAc;IAAE;IAChC3C,KAAK,EAAEA,KAAK;IACZN,QAAQ,EAAEA,QAAQ;IAClBqC,MAAM,EAAEA,MAAM;IACdS,KAAK,EAAEA,KAAK;IACZd,YAAY,EAAEA,YAAY;IAC1B9B,IAAI,EAAEA,IAAI;IACVwB,GAAG,EAAEA,GAAG;IACRG,MAAM,EAAEA,MAAM;IACdM,QAAQ,EAAEA,QAAQ;IAClBG,WAAW,EAAEA,WAAW;IACxBC,aAAa,EAAEA,aAAa;IAC5BC,aAAa,EAAEA,aAAa;IAC5BC,OAAO,EAAEA,OAAO;IAChBE,QAAQ,EAAEA,QAAQ;IAClBpB,eAAe,EAAEA,eAAe;IAEhC;IACAwB,QAAQ,EAAEA,QAAQ;IAClBC,KAAK,EAAEA,KAAK;IAEZ;IACAlF,KAAK,EAAEA,KAAK;IAAE;IACdC,IAAI,EAAEA,IAAI,CAAC;EACb,CAAC;AACH;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}