{"ast":null,"code":"import Interval from '../graphics/structs/Interval';\nfunction IntervalPoint(value, index, isStart) {\n  this.value = value;\n  this.index = index;\n  this.isStart = isStart;\n}\n\n/**\r\n * Callback function to iterate over result intervals\r\n * \r\n * @callback onMergedIntervalItemCallback\r\n * @param {Interval} interval Merged interval\r\n * @param {Object} context First interval context.\r\n */\n\n/**\r\n * Merges collection of overlapping intervals into continuous group of intervals. Calls callback \r\n * function to pass result interval per group of overlapping intervals.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Interval[]} items Collection of intervals.\r\n * @param {onMergedIntervalItemCallback} onItem Callback function to pass result group of merged intervals.\r\n */\nexport default function getMergedIntervals(thisArg, items, onItem) {\n  var points = [];\n  for (var index = 0; index < items.length; index += 1) {\n    var item = items[index];\n    points.push(new IntervalPoint(item.from, index, true));\n    points.push(new IntervalPoint(item.to, index, false));\n  }\n  points.sort(function (a, b) {\n    if (a.value === b.value) {\n      return b.isStart - a.isStart;\n    }\n    return a.value - b.value;\n  });\n  var counter = 0;\n  var interval = null;\n  var logicalIndex = null;\n  for (var index = 0, len = points.length; index < len; index += 1) {\n    var point = points[index];\n    if (interval == null) {\n      interval = new Interval(items[point.index]);\n    }\n    interval.to = point.value;\n    if (point.isStart) {\n      counter++;\n      if (logicalIndex === null || logicalIndex > point.index) {\n        logicalIndex = point.index;\n        interval.context = items[point.index].context;\n      }\n    } else {\n      counter--;\n    }\n    if (!counter) {\n      if (onItem != null) {\n        onItem.call(thisArg, interval);\n      }\n      interval = null;\n      logicalIndex = null;\n    }\n  }\n}\n;","map":{"version":3,"names":["Interval","IntervalPoint","value","index","isStart","getMergedIntervals","thisArg","items","onItem","points","length","item","push","from","to","sort","a","b","counter","interval","logicalIndex","len","point","context","call"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/getMergedIntervals.js"],"sourcesContent":["import Interval from '../graphics/structs/Interval';\r\n\r\nfunction IntervalPoint(value, index, isStart) {\r\n  this.value = value;\r\n  this.index = index;\r\n  this.isStart = isStart;\r\n}\r\n\r\n/**\r\n * Callback function to iterate over result intervals\r\n * \r\n * @callback onMergedIntervalItemCallback\r\n * @param {Interval} interval Merged interval\r\n * @param {Object} context First interval context.\r\n */\r\n\r\n/**\r\n * Merges collection of overlapping intervals into continuous group of intervals. Calls callback \r\n * function to pass result interval per group of overlapping intervals.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Interval[]} items Collection of intervals.\r\n * @param {onMergedIntervalItemCallback} onItem Callback function to pass result group of merged intervals.\r\n */\r\nexport default function getMergedIntervals(thisArg, items, onItem) {\r\n  var points = [];\r\n  for(var index = 0; index < items.length; index+=1) {\r\n    var item = items[index];\r\n    points.push(new IntervalPoint(item.from, index, true));\r\n    points.push(new IntervalPoint(item.to, index, false));\r\n  }\r\n\r\n  points.sort(function(a, b) {\r\n    if(a.value === b.value) {\r\n      return b.isStart - a.isStart;\r\n    }\r\n    return  a.value - b.value;\r\n  })\r\n\r\n  var counter = 0;\r\n  var interval = null;\r\n  var logicalIndex = null;\r\n  for(var index = 0, len = points.length; index < len; index+=1) {\r\n    var point = points[index];\r\n    if(interval == null) {\r\n      interval = new Interval(items[point.index]);\r\n    }\r\n    interval.to = point.value;\r\n\r\n    if(point.isStart) {\r\n      counter++;\r\n\r\n      if(logicalIndex === null || logicalIndex > point.index) {\r\n        logicalIndex = point.index;\r\n        interval.context = items[point.index].context;\r\n      }\r\n    } else {\r\n      counter--;\r\n    }\r\n    if(!counter) {\r\n      if(onItem != null) {\r\n        onItem.call(thisArg, interval);\r\n      }\r\n      interval = null;\r\n      logicalIndex = null;\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,8BAA8B;AAEnD,SAASC,aAAaA,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAC5C,IAAI,CAACF,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,OAAO,GAAGA,OAAO;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,kBAAkBA,CAACC,OAAO,EAAEC,KAAK,EAAEC,MAAM,EAAE;EACjE,IAAIC,MAAM,GAAG,EAAE;EACf,KAAI,IAAIN,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGI,KAAK,CAACG,MAAM,EAAEP,KAAK,IAAE,CAAC,EAAE;IACjD,IAAIQ,IAAI,GAAGJ,KAAK,CAACJ,KAAK,CAAC;IACvBM,MAAM,CAACG,IAAI,CAAC,IAAIX,aAAa,CAACU,IAAI,CAACE,IAAI,EAAEV,KAAK,EAAE,IAAI,CAAC,CAAC;IACtDM,MAAM,CAACG,IAAI,CAAC,IAAIX,aAAa,CAACU,IAAI,CAACG,EAAE,EAAEX,KAAK,EAAE,KAAK,CAAC,CAAC;EACvD;EAEAM,MAAM,CAACM,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;IACzB,IAAGD,CAAC,CAACd,KAAK,KAAKe,CAAC,CAACf,KAAK,EAAE;MACtB,OAAOe,CAAC,CAACb,OAAO,GAAGY,CAAC,CAACZ,OAAO;IAC9B;IACA,OAAQY,CAAC,CAACd,KAAK,GAAGe,CAAC,CAACf,KAAK;EAC3B,CAAC,CAAC;EAEF,IAAIgB,OAAO,GAAG,CAAC;EACf,IAAIC,QAAQ,GAAG,IAAI;EACnB,IAAIC,YAAY,GAAG,IAAI;EACvB,KAAI,IAAIjB,KAAK,GAAG,CAAC,EAAEkB,GAAG,GAAGZ,MAAM,CAACC,MAAM,EAAEP,KAAK,GAAGkB,GAAG,EAAElB,KAAK,IAAE,CAAC,EAAE;IAC7D,IAAImB,KAAK,GAAGb,MAAM,CAACN,KAAK,CAAC;IACzB,IAAGgB,QAAQ,IAAI,IAAI,EAAE;MACnBA,QAAQ,GAAG,IAAInB,QAAQ,CAACO,KAAK,CAACe,KAAK,CAACnB,KAAK,CAAC,CAAC;IAC7C;IACAgB,QAAQ,CAACL,EAAE,GAAGQ,KAAK,CAACpB,KAAK;IAEzB,IAAGoB,KAAK,CAAClB,OAAO,EAAE;MAChBc,OAAO,EAAE;MAET,IAAGE,YAAY,KAAK,IAAI,IAAIA,YAAY,GAAGE,KAAK,CAACnB,KAAK,EAAE;QACtDiB,YAAY,GAAGE,KAAK,CAACnB,KAAK;QAC1BgB,QAAQ,CAACI,OAAO,GAAGhB,KAAK,CAACe,KAAK,CAACnB,KAAK,CAAC,CAACoB,OAAO;MAC/C;IACF,CAAC,MAAM;MACLL,OAAO,EAAE;IACX;IACA,IAAG,CAACA,OAAO,EAAE;MACX,IAAGV,MAAM,IAAI,IAAI,EAAE;QACjBA,MAAM,CAACgB,IAAI,CAAClB,OAAO,EAAEa,QAAQ,CAAC;MAChC;MACAA,QAAQ,GAAG,IAAI;MACfC,YAAY,GAAG,IAAI;IACrB;EACF;AACF;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}