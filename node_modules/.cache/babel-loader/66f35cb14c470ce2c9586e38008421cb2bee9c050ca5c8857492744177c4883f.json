{"ast":null,"code":"import BaseTransformer from './BaseTransformer';\nimport FamilyItem from '../../../models/FamilyItem';\nimport { GroupByType } from '../../../enums';\nimport { isEmptyObject } from '../../../common';\nexport default function FamilyNormalizer(debug) {\n  this.parent = BaseTransformer.prototype;\n  this.parent.constructor.apply(this, arguments);\n}\n;\nFamilyNormalizer.prototype = new BaseTransformer();\nFamilyNormalizer.prototype.normalize = function (options, logicalFamily, maximumId) {\n  if (logicalFamily.hasNodes() > 0) {\n    /* create temp family without labels and invisible node used to bind connections and eliminate many to many relations */\n    var toBeRemoved = [];\n    logicalFamily.loop(this, function (itemId, item) {\n      if (item.isLevelNeutral) {\n        toBeRemoved.push(itemId);\n      }\n    });\n    var logicalFamily2 = logicalFamily;\n    if (toBeRemoved.length > 0) {\n      logicalFamily2 = logicalFamily.clone();\n      for (var index = 0; index < toBeRemoved.length; index += 1) {\n        var itemId = toBeRemoved[index];\n        var parents = [];\n        logicalFamily2.loopParents(this, itemId, function (parentId, parent, levelIndex) {\n          if (levelIndex == 0) {\n            parents.push(parentId);\n            return;\n          }\n          return true;\n        });\n        var children = [];\n        if (parents.length > 0) {\n          logicalFamily2.loopChildren(this, itemId, function (childId, child, levelIndex) {\n            if (levelIndex == 0) {\n              children.push(childId);\n              return;\n            }\n            return true;\n          });\n        }\n        logicalFamily2.removeNode(itemId);\n        if (children.length > 0) {\n          for (var childIndex = 0; childIndex < children.length; childIndex += 1) {\n            var childId = children[childIndex];\n            logicalFamily2.adopt(parents, childId);\n          }\n        }\n      }\n    }\n\n    /* Distribute Temp Family nodes by levels. Item levels aligned to bottom. */\n    logicalFamily2.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemId, item, levelIndex) {\n      item.level = levelIndex;\n    });\n    if (options.alignBylevels) {\n      /* Distribute optimized FamilyItem-s by levels. The original family items visible to user should keep their levels after all transformations */\n      this.resortItemsBylevels(logicalFamily);\n    } else {\n      logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\n        item.level = levelIndex;\n      });\n    }\n    if (this.debug) {\n      this.validate(logicalFamily, false);\n    }\n\n    /* Fill in items between parent/child relations having gaps in levels */\n    this.fillInItems(logicalFamily, function (famItem) {\n      var result;\n      maximumId += 1;\n      result = new FamilyItem({\n        id: maximumId,\n        levelGravity: GroupByType.Children,\n        isVisible: false,\n        isActive: false,\n        itemConfig: {\n          title: \"extension #\" + maximumId,\n          description: \"This is item used to fill gaps in levels.\"\n        }\n      });\n      return result;\n    } //ignore jslint\n    );\n    if (this.debug) {\n      this.validate(logicalFamily, true);\n    }\n  }\n  return maximumId;\n};\nFamilyNormalizer.prototype.resortItemsBylevels = function (logicalFamily) {\n  var itemsAtLevels = [],\n    minimumLevel = null,\n    maximumLevel = null,\n    index,\n    itemsAtLevel;\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    famItem.originalLevel = famItem.level;\n    famItem.level = null;\n    if (famItem.originalLevel != null) {\n      if (!itemsAtLevels[famItem.originalLevel]) {\n        itemsAtLevels[famItem.originalLevel] = {};\n      }\n      itemsAtLevels[famItem.originalLevel][famItemId] = famItem;\n      minimumLevel = minimumLevel != null ? Math.min(famItem.originalLevel, minimumLevel) : famItem.originalLevel;\n      maximumLevel = maximumLevel != null ? Math.max(famItem.originalLevel, maximumLevel) : famItem.originalLevel;\n    }\n  });\n\n  /* assign levels*/\n  for (index = minimumLevel; index <= maximumLevel; index += 1) {\n    itemsAtLevel = itemsAtLevels[index];\n    this.setLevelsForItems(itemsAtLevel, logicalFamily);\n  }\n  logicalFamily.loopTopo(this, function (famItemId, famItem, position) {\n    var level;\n    if (famItem.levelGravity == GroupByType.Parents) {\n      level = null;\n      logicalFamily.loopParents(this, famItemId, function (childItemId, childFamItem, levelIndex) {\n        level = level == null ? childFamItem.level + 1 : Math.max(childFamItem.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n      famItem.level = !level ? famItem.level : level;\n    }\n  });\n};\nFamilyNormalizer.prototype.setLevelsForItems = function (items, logicalFamily) {\n  var level = 0,\n    key,\n    famItem,\n    nextItems;\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      logicalFamily.loopParents(this, key, function (parentid, parent, levelIndex) {\n        level = Math.max(parent.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n    }\n  }\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      famItem = items[key];\n      famItem.level = level;\n    }\n  }\n  while (!isEmptyObject(items)) {\n    nextItems = {};\n    for (key in items) {\n      if (items.hasOwnProperty(key)) {\n        famItem = items[key];\n        logicalFamily.loopChildren(this, key, function (childid, child, levelIndex) {\n          if (child.originalLevel == null || child.isLevelNeutral) {\n            child.level = child.level == null ? famItem.level + 1 : Math.max(child.level, famItem.level + 1);\n            nextItems[childid] = child;\n          }\n          return logicalFamily.SKIP;\n        }); //ignore jslint\n      }\n    }\n    items = nextItems;\n  }\n};\nFamilyNormalizer.prototype.fillInItems = function (logicalFamily, createFamItem) {\n  var bundleItem;\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle,\n      isSingleExtension = true;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n      logicalFamily.loopChildren(this, famItemId, function (childItemId, childItem, level) {\n        if (famItem.level + 1 < childItem.level) {\n          itemsToBundle.push(childItemId);\n        } else {\n          isSingleExtension = false;\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level + 1;\n        if (isSingleExtension) {\n          bundleItem.hideParentConnection = false;\n          bundleItem.hideChildrenConnection = false;\n        }\n        logicalFamily.bundleChildren(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 0) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n};","map":{"version":3,"names":["BaseTransformer","FamilyItem","GroupByType","isEmptyObject","FamilyNormalizer","debug","parent","prototype","constructor","apply","arguments","normalize","options","logicalFamily","maximumId","hasNodes","toBeRemoved","loop","itemId","item","isLevelNeutral","push","logicalFamily2","length","clone","index","parents","loopParents","parentId","levelIndex","children","loopChildren","childId","child","removeNode","childIndex","adopt","loopLevels","groupByType","Parents","level","alignBylevels","resortItemsBylevels","itemid","validate","fillInItems","famItem","result","id","levelGravity","Children","isVisible","isActive","itemConfig","title","description","itemsAtLevels","minimumLevel","maximumLevel","itemsAtLevel","famItemId","originalLevel","Math","min","max","setLevelsForItems","loopTopo","position","childItemId","childFamItem","SKIP","items","key","nextItems","hasOwnProperty","parentid","childid","createFamItem","bundleItem","extNeeded","itemsToBundle","parentItemId","parentItem","hideParentConnection","hideChildrenConnection","bundleParents","isSingleExtension","childItem","bundleChildren"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyNormalizer.js"],"sourcesContent":["import BaseTransformer from './BaseTransformer';\r\nimport FamilyItem from '../../../models/FamilyItem';\r\nimport { GroupByType } from '../../../enums';\r\nimport { isEmptyObject } from '../../../common';\r\n\r\nexport default function FamilyNormalizer(debug) {\r\n  this.parent = BaseTransformer.prototype;\r\n  this.parent.constructor.apply(this, arguments);\r\n};\r\n\r\nFamilyNormalizer.prototype = new BaseTransformer();\r\n\r\nFamilyNormalizer.prototype.normalize = function (options, logicalFamily, maximumId) {\r\n  if (logicalFamily.hasNodes() > 0) {\r\n\r\n    /* create temp family without labels and invisible node used to bind connections and eliminate many to many relations */\r\n    var toBeRemoved = [];\r\n    logicalFamily.loop(this, function(itemId, item) {\r\n      if(item.isLevelNeutral) {\r\n        toBeRemoved.push(itemId);\r\n      }\r\n    })\r\n    var logicalFamily2 = logicalFamily;\r\n    if(toBeRemoved.length > 0) {\r\n      logicalFamily2 = logicalFamily.clone();\r\n      for(var index = 0; index < toBeRemoved.length; index+=1) {\r\n        var itemId = toBeRemoved[index];\r\n        var parents = [];\r\n        logicalFamily2.loopParents(this, itemId, function(parentId, parent, levelIndex) {\r\n          if(levelIndex == 0) {\r\n            parents.push(parentId);\r\n            return;\r\n          }\r\n          return true;\r\n        });\r\n        var children = [];\r\n        if(parents.length > 0) {\r\n          logicalFamily2.loopChildren(this, itemId, function(childId, child, levelIndex) {\r\n            if(levelIndex == 0) {\r\n              children.push(childId);\r\n              return;\r\n            }\r\n            return true;\r\n          });\r\n        }\r\n        logicalFamily2.removeNode(itemId);\r\n\r\n        if(children.length > 0) {\r\n          for(var childIndex = 0; childIndex < children.length; childIndex+=1) {\r\n            var childId = children[childIndex];\r\n            logicalFamily2.adopt(parents, childId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Distribute Temp Family nodes by levels. Item levels aligned to bottom. */\r\n    logicalFamily2.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemId, item, levelIndex) {\r\n      item.level = levelIndex;\r\n    });\r\n\r\n    if (options.alignBylevels) {\r\n      /* Distribute optimized FamilyItem-s by levels. The original family items visible to user should keep their levels after all transformations */\r\n      this.resortItemsBylevels(logicalFamily);\r\n    } else {\r\n      logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\r\n        item.level = levelIndex;\r\n      });\r\n    }\r\n\r\n    if (this.debug) {\r\n      this.validate(logicalFamily, false);\r\n    }\r\n\r\n    /* Fill in items between parent/child relations having gaps in levels */\r\n    this.fillInItems(logicalFamily,\r\n      function (famItem) {\r\n        var result;\r\n\r\n        maximumId += 1;\r\n\r\n        result = new FamilyItem({\r\n          id: maximumId,\r\n          levelGravity: GroupByType.Children,\r\n          isVisible: false,\r\n          isActive: false,\r\n          itemConfig: { title: \"extension #\" + maximumId, description: \"This is item used to fill gaps in levels.\" }\r\n        });\r\n\r\n        return result;\r\n      } //ignore jslint\r\n    );\r\n\r\n    if (this.debug) {\r\n      this.validate(logicalFamily, true);\r\n    }\r\n  }\r\n  return maximumId;\r\n};\r\n\r\nFamilyNormalizer.prototype.resortItemsBylevels = function (logicalFamily) {\r\n  var itemsAtLevels = [],\r\n    minimumLevel = null,\r\n    maximumLevel = null,\r\n    index, itemsAtLevel;\r\n\r\n  logicalFamily.loop(this, function (famItemId, famItem) {\r\n    famItem.originalLevel = famItem.level;\r\n    famItem.level = null;\r\n    if (famItem.originalLevel != null) {\r\n      if (!itemsAtLevels[famItem.originalLevel]) {\r\n        itemsAtLevels[famItem.originalLevel] = {};\r\n      }\r\n      itemsAtLevels[famItem.originalLevel][famItemId] = famItem;\r\n\r\n      minimumLevel = minimumLevel != null ? Math.min(famItem.originalLevel, minimumLevel) : famItem.originalLevel;\r\n      maximumLevel = maximumLevel != null ? Math.max(famItem.originalLevel, maximumLevel) : famItem.originalLevel;\r\n    }\r\n  });\r\n\r\n  /* assign levels*/\r\n  for (index = minimumLevel; index <= maximumLevel; index += 1) {\r\n    itemsAtLevel = itemsAtLevels[index];\r\n\r\n    this.setLevelsForItems(itemsAtLevel, logicalFamily);\r\n  }\r\n\r\n  logicalFamily.loopTopo(this, function (famItemId, famItem, position) {\r\n    var level;\r\n    if (famItem.levelGravity == GroupByType.Parents) {\r\n      level = null;\r\n      logicalFamily.loopParents(this, famItemId, function (childItemId, childFamItem, levelIndex) {\r\n        level = level == null ? childFamItem.level + 1 : Math.max(childFamItem.level + 1, level);\r\n        return logicalFamily.SKIP;\r\n      }); //ignore jslint\r\n      famItem.level = !level ? famItem.level : level;\r\n    }\r\n  });\r\n};\r\n\r\nFamilyNormalizer.prototype.setLevelsForItems = function (items, logicalFamily) {\r\n  var level = 0,\r\n    key, famItem,\r\n    nextItems;\r\n\r\n  for (key in items) {\r\n    if (items.hasOwnProperty(key)) {\r\n      logicalFamily.loopParents(this, key, function (parentid, parent, levelIndex) {\r\n        level = Math.max(parent.level + 1, level);\r\n        return logicalFamily.SKIP;\r\n      }); //ignore jslint\r\n    }\r\n  }\r\n\r\n  for (key in items) {\r\n    if (items.hasOwnProperty(key)) {\r\n      famItem = items[key];\r\n      famItem.level = level;\r\n    }\r\n  }\r\n\r\n  while (!isEmptyObject(items)) {\r\n    nextItems = {};\r\n\r\n    for (key in items) {\r\n      if (items.hasOwnProperty(key)) {\r\n        famItem = items[key];\r\n        logicalFamily.loopChildren(this, key, function (childid, child, levelIndex) {\r\n          if (child.originalLevel == null || child.isLevelNeutral) {\r\n            child.level = child.level == null ? famItem.level + 1 : Math.max(child.level, famItem.level + 1);\r\n            nextItems[childid] = child;\r\n          }\r\n          return logicalFamily.SKIP;\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n    items = nextItems;\r\n  }\r\n};\r\n\r\nFamilyNormalizer.prototype.fillInItems = function (logicalFamily, createFamItem) {\r\n  var bundleItem;\r\n\r\n  logicalFamily.loop(this, function (famItemId, famItem) {\r\n    var extNeeded = true,\r\n      itemsToBundle;\r\n    while (extNeeded) {\r\n      extNeeded = false;\r\n\r\n      /* extend children down */\r\n      itemsToBundle = [];\r\n\r\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\r\n        if (famItem.level - 1 > parentItem.level) {\r\n          itemsToBundle.push(parentItemId);\r\n        }\r\n        return logicalFamily.SKIP;\r\n      }); //ignore jslint\r\n\r\n      if (itemsToBundle.length > 1) {\r\n        bundleItem = createFamItem(famItem);\r\n        bundleItem.level = famItem.level - 1;\r\n\r\n        bundleItem.hideParentConnection = false;\r\n        bundleItem.hideChildrenConnection = false;\r\n\r\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\r\n\r\n        extNeeded = true;\r\n\r\n        famItemId = bundleItem.id;\r\n        famItem = bundleItem;\r\n      }\r\n    }\r\n  });\r\n\r\n  logicalFamily.loop(this, function (famItemId, famItem) {\r\n    var extNeeded = true,\r\n      itemsToBundle,\r\n      isSingleExtension = true;\r\n    while (extNeeded) {\r\n      extNeeded = false;\r\n\r\n      /* extend children down */\r\n      itemsToBundle = [];\r\n      logicalFamily.loopChildren(this, famItemId, function (childItemId, childItem, level) {\r\n        if (famItem.level + 1 < childItem.level) {\r\n          itemsToBundle.push(childItemId);\r\n        } else {\r\n          isSingleExtension = false;\r\n        }\r\n        return logicalFamily.SKIP;\r\n      }); //ignore jslint\r\n\r\n      if (itemsToBundle.length > 1) {\r\n        bundleItem = createFamItem(famItem);\r\n        bundleItem.level = famItem.level + 1;\r\n\r\n        if (isSingleExtension) {\r\n          bundleItem.hideParentConnection = false;\r\n          bundleItem.hideChildrenConnection = false;\r\n        }\r\n\r\n        logicalFamily.bundleChildren(famItemId, itemsToBundle, bundleItem.id, bundleItem);\r\n\r\n        extNeeded = true;\r\n\r\n        famItemId = bundleItem.id;\r\n        famItem = bundleItem;\r\n      }\r\n    }\r\n  });\r\n\r\n  logicalFamily.loop(this, function (famItemId, famItem) {\r\n    var extNeeded = true,\r\n      itemsToBundle;\r\n    while (extNeeded) {\r\n      extNeeded = false;\r\n\r\n      /* extend children down */\r\n      itemsToBundle = [];\r\n\r\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\r\n        if (famItem.level - 1 > parentItem.level) {\r\n          itemsToBundle.push(parentItemId);\r\n        }\r\n        return logicalFamily.SKIP;\r\n      }); //ignore jslint\r\n\r\n      if (itemsToBundle.length > 0) {\r\n        bundleItem = createFamItem(famItem);\r\n        bundleItem.level = famItem.level - 1;\r\n\r\n        bundleItem.hideParentConnection = false;\r\n        bundleItem.hideChildrenConnection = false;\r\n\r\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\r\n\r\n        extNeeded = true;\r\n\r\n        famItemId = bundleItem.id;\r\n        famItem = bundleItem;\r\n      }\r\n    }\r\n  });\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}