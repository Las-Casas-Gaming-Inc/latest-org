{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Rect from '../structs/Rect';\nimport Vector from '../structs/Vector';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\nexport default function ConnectorStraight() {}\n;\nConnectorStraight.prototype = new BaseShape();\nConnectorStraight.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var fromPoint,\n    toPoint,\n    betweenPoint,\n    vector,\n    newVector,\n    offset = linesOffset / 2,\n    labelPlacement = null,\n    fromLabelPlacement = PlacementType.Auto,\n    toLabelPlacement = PlacementType.Auto,\n    self = this;\n  vector = new Vector(fromRect.centerPoint(), toRect.centerPoint());\n  fromRect.loopEdges(function (sideVector, placementType) {\n    fromPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    fromLabelPlacement = placementType;\n    return fromPoint != null;\n  });\n  toRect.loopEdges(function (sideVector, placementType) {\n    toPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    toLabelPlacement = placementType;\n    return toPoint != null;\n  });\n  if (fromPoint != null && toPoint != null) {\n    var baseVector = new Vector(fromPoint, toPoint);\n    connectorAnnotationOffsetResolver.getOffset(baseVector, function (offsetIndex, bundleSize, direction) {\n      var tempOffset = (offsetIndex * bundleOffset - (bundleSize - 1) * bundleOffset / 2.0) * direction;\n      baseVector.offset(tempOffset);\n      fromPoint = baseVector.from;\n      toPoint = baseVector.to;\n      switch (connectorShapeType) {\n        case ConnectorShapeType.TwoWay:\n          newVector = new Vector(toPoint.clone(), fromPoint.clone());\n          newVector.offset(offset);\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n          newVector = new Vector(fromPoint.clone(), toPoint.clone());\n          newVector.offset(offset);\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n          break;\n        case ConnectorShapeType.OneWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, false);\n          break;\n        case ConnectorShapeType.BothWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, true);\n          break;\n      }\n      if (hasLabel) {\n        /* end points labels placement */\n        switch (labelPlacementType) {\n          case ConnectorLabelPlacementType.From:\n            labelPlacement = self._getLabelPositionBySnapPoint(fromPoint.x, fromPoint.y, labelSize.width, labelSize.height, labelOffset, fromLabelPlacement);\n            break;\n          case ConnectorLabelPlacementType.Between:\n            betweenPoint = self._betweenPoint(fromPoint, toPoint);\n            labelPlacement = self._getLabelPositionBySnapPoint(betweenPoint.x, betweenPoint.y, labelSize.width, labelSize.height, labelOffset, PlacementType.Right);\n            break;\n          case ConnectorLabelPlacementType.To:\n            labelPlacement = self._getLabelPositionBySnapPoint(toPoint.x, toPoint.y, labelSize.width, labelSize.height, labelOffset, toLabelPlacement);\n            break;\n          default:\n            break;\n        }\n        if (onLabelPlacement != null) {\n          onLabelPlacement.call(this, labelPlacement, labelConfig);\n        }\n      }\n    });\n  }\n};\nConnectorStraight.prototype._drawLine = function (buffer, linePaletteItem, fromPoint, toPoint, bothWays) {\n  var polyline;\n  buffer.addInverted(function (invertedBuffer) {\n    polyline = invertedBuffer.getPolyline(linePaletteItem);\n    polyline.addSegment(new MoveSegment(fromPoint));\n    polyline.addSegment(new LineSegment(toPoint));\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }, false); //ignore jslint\n\n  if (bothWays) {\n    polyline = buffer.getPolyline(linePaletteItem);\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }\n};\nConnectorStraight.prototype._getLabelPositionBySnapPoint = function (x, y, labelWidth, labelHeight, labelOffset, placementType) {\n  var result = null;\n  switch (placementType) {\n    case PlacementType.Auto:\n    case PlacementType.Top:\n      result = new Rect(x - labelWidth / 2.0, y - labelOffset - labelHeight, labelWidth, labelHeight);\n      break;\n    case PlacementType.Right:\n      result = new Rect(x + labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n    case PlacementType.Bottom:\n      result = new Rect(x - labelWidth / 2.0, y + labelOffset, labelWidth, labelHeight);\n      break;\n    case PlacementType.Left:\n      result = new Rect(x - labelWidth - labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n  }\n  return result;\n};","map":{"version":3,"names":["BaseShape","Rect","Vector","MoveSegment","LineSegment","PlacementType","ConnectorShapeType","ConnectorLabelPlacementType","ConnectorStraight","prototype","draw","buffer","linePaletteItem","fromRect","toRect","linesOffset","bundleOffset","labelSize","panelSize","connectorShapeType","labelOffset","labelPlacementType","hasLabel","connectorAnnotationOffsetResolver","onLabelPlacement","labelConfig","fromPoint","toPoint","betweenPoint","vector","newVector","offset","labelPlacement","fromLabelPlacement","Auto","toLabelPlacement","self","centerPoint","loopEdges","sideVector","placementType","getIntersectionPoint","baseVector","getOffset","offsetIndex","bundleSize","direction","tempOffset","from","to","TwoWay","clone","_drawLine","OneWay","BothWay","From","_getLabelPositionBySnapPoint","x","y","width","height","Between","_betweenPoint","Right","To","call","bothWays","polyline","addInverted","invertedBuffer","getPolyline","addSegment","addArrow","lineWidth","mergeTo","paletteItem","labelWidth","labelHeight","result","Top","Bottom","Left"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/graphics/shapes/ConnectorStraight.js"],"sourcesContent":["import BaseShape from './BaseShape';\r\nimport Rect from '../structs/Rect';\r\nimport Vector from '../structs/Vector';\r\nimport MoveSegment from '../structs/MoveSegment';\r\nimport LineSegment from '../structs/LineSegment';\r\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\r\n\r\n\r\nexport default function ConnectorStraight() {\r\n\r\n};\r\n\r\nConnectorStraight.prototype = new BaseShape();\r\n\r\nConnectorStraight.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel,\r\n  connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\r\n  var fromPoint, toPoint, betweenPoint,\r\n    vector, newVector,\r\n    offset = linesOffset / 2,\r\n    labelPlacement = null,\r\n    fromLabelPlacement = PlacementType.Auto,\r\n    toLabelPlacement = PlacementType.Auto,\r\n    self = this;\r\n\r\n  vector = new Vector(fromRect.centerPoint(), toRect.centerPoint());\r\n\r\n  fromRect.loopEdges(function (sideVector, placementType) {\r\n    fromPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\r\n    fromLabelPlacement = placementType;\r\n    return (fromPoint != null);\r\n  });\r\n\r\n  toRect.loopEdges(function (sideVector, placementType) {\r\n    toPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\r\n    toLabelPlacement = placementType;\r\n    return (toPoint != null);\r\n  });\r\n\r\n  if (fromPoint != null && toPoint != null) {\r\n    var baseVector = new Vector(fromPoint, toPoint);\r\n    connectorAnnotationOffsetResolver.getOffset(baseVector, function (offsetIndex, bundleSize, direction) {\r\n      var tempOffset = (offsetIndex * bundleOffset - (bundleSize - 1) * bundleOffset / 2.0) * direction;\r\n      baseVector.offset(tempOffset);\r\n      fromPoint = baseVector.from;\r\n      toPoint = baseVector.to;\r\n\r\n      switch (connectorShapeType) {\r\n        case ConnectorShapeType.TwoWay:\r\n          newVector = new Vector(toPoint.clone(), fromPoint.clone());\r\n          newVector.offset(offset);\r\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\r\n\r\n          newVector = new Vector(fromPoint.clone(), toPoint.clone());\r\n          newVector.offset(offset);\r\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\r\n          break;\r\n        case ConnectorShapeType.OneWay:\r\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, false);\r\n          break;\r\n        case ConnectorShapeType.BothWay:\r\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, true);\r\n          break;\r\n      }\r\n\r\n      if (hasLabel) {\r\n        /* end points labels placement */\r\n        switch (labelPlacementType) {\r\n          case ConnectorLabelPlacementType.From:\r\n            labelPlacement = self._getLabelPositionBySnapPoint(fromPoint.x, fromPoint.y, labelSize.width, labelSize.height, labelOffset, fromLabelPlacement);\r\n            break;\r\n          case ConnectorLabelPlacementType.Between:\r\n            betweenPoint = self._betweenPoint(fromPoint, toPoint);\r\n            labelPlacement = self._getLabelPositionBySnapPoint(betweenPoint.x, betweenPoint.y, labelSize.width, labelSize.height, labelOffset, PlacementType.Right);\r\n            break;\r\n          case ConnectorLabelPlacementType.To:\r\n            labelPlacement = self._getLabelPositionBySnapPoint(toPoint.x, toPoint.y, labelSize.width, labelSize.height, labelOffset, toLabelPlacement);\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n\r\n        if (onLabelPlacement != null) {\r\n          onLabelPlacement.call(this, labelPlacement, labelConfig);\r\n        }\r\n      }\r\n    });\r\n\r\n  }\r\n};\r\n\r\nConnectorStraight.prototype._drawLine = function (buffer, linePaletteItem, fromPoint, toPoint, bothWays) {\r\n  var polyline;\r\n\r\n  buffer.addInverted(function (invertedBuffer) {\r\n    polyline = invertedBuffer.getPolyline(linePaletteItem);\r\n    polyline.addSegment(new MoveSegment(fromPoint));\r\n    polyline.addSegment(new LineSegment(toPoint));\r\n\r\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n    }); //ignore jslint\r\n  }, false);//ignore jslint\r\n\r\n  if (bothWays) {\r\n    polyline = buffer.getPolyline(linePaletteItem);\r\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n    }); //ignore jslint\r\n  }\r\n};\r\n\r\nConnectorStraight.prototype._getLabelPositionBySnapPoint = function (x, y, labelWidth, labelHeight, labelOffset, placementType) {\r\n  var result = null;\r\n  switch (placementType) {\r\n    case PlacementType.Auto:\r\n    case PlacementType.Top:\r\n      result = new Rect(x - labelWidth / 2.0, y - labelOffset - labelHeight, labelWidth, labelHeight);\r\n      break;\r\n    case PlacementType.Right:\r\n      result = new Rect(x + labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\r\n      break;\r\n    case PlacementType.Bottom:\r\n      result = new Rect(x - labelWidth / 2.0, y + labelOffset, labelWidth, labelHeight);\r\n      break;\r\n    case PlacementType.Left:\r\n      result = new Rect(x - labelWidth - labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\r\n      break;\r\n  }\r\n  return result;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}