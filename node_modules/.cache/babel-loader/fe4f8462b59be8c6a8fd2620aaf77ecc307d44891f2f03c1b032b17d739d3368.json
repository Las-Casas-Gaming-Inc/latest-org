{"ast":null,"code":"import Tree from '../../../algorithms/Tree';\nimport { RowType, GroupType, RowTypeToGroupTypeMap } from './enums';\nfunction RowKeyGenerator() {\n  var _rowsHash = {};\n  var _rowIndex = 1;\n  function find(parentId, rowType, index) {\n    var key = parentId + '-' + rowType + '-' + index;\n    if (!_rowsHash.hasOwnProperty(key)) {\n      _rowsHash[key] = _rowIndex;\n      _rowIndex += 1;\n    }\n    return _rowsHash[key];\n  }\n  function get() {\n    var result = _rowIndex;\n    _rowIndex += 1;\n    return result;\n  }\n  return {\n    find: find,\n    get: get\n  };\n}\nfunction Row(id) {\n  this.id = id;\n  this.rowType = RowType.Items;\n  this.index = 0;\n  this.offset = 0;\n  this.extend = true; /* indicates that we need to keep branches of this row children above subsequent rows */\n  this.depth = 0;\n  this.groups = [];\n  this.groups[GroupType.Items] = [[1, 1]];\n  this.getDepth = function () {\n    var [currExtend, currDepth] = this.groups.reduce((acc, row) => {\n      return row.reduce((_ref, item) => {\n        let [currExtend, currDepth] = _ref;\n        var [extend, depth] = item || [1, 1];\n        return [currExtend + extend, Math.max(currDepth, currExtend + depth)];\n      }, acc);\n    }, [0, 0]);\n    return Math.max(currExtend, currDepth) || 1;\n  };\n  this.addRowDepth = function (rowType, extend, index, depth) {\n    var groupIndex = RowTypeToGroupTypeMap[rowType];\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = [];\n    }\n    var rows = this.groups[groupIndex];\n    var [currExtend, currDepth] = rows[index] || [1, 1];\n    rows[index] = [Math.max(currExtend, extend ? depth : 1), Math.max(currDepth, depth)];\n  };\n}\nfunction BranchAligner() {\n  var _rowsTree = Tree();\n  var _rowKeyGenerator = RowKeyGenerator();\n  var _rowHash = {}; // rowHash[nodeId] = rowKey;\n\n  function _createParentRow(parentNodeId) {\n    var parentRowId = _rowKeyGenerator.find(null, RowType.Children, 0);\n    var parentRow = new Row(parentRowId);\n    parentRow.rowType = RowType.Items;\n    parentRow.index = 0;\n    parentRow.offset = 0;\n    parentRow.extend = false;\n    _rowsTree.add(null, parentRowId, parentRow);\n    _rowHash[parentNodeId] = parentRowId;\n    return parentRowId;\n  }\n  function mergeToParent(parentNodeId, nodes) {\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\n    nodes.forEach(child => {\n      _rowHash[child.id] = parentRowId;\n    });\n  }\n  function mergeToChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\n    var rowId = _rowKeyGenerator.find(parentRowId, rowType, index);\n    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);\n  }\n  function addChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\n    var rowId = _rowKeyGenerator.get();\n    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);\n  }\n  function addSplitChildren(parentNodeId, nodes, rowType, index, offset) {\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\n    nodes.forEach(child => {\n      var rowId = _rowKeyGenerator.get();\n      var row = new Row(rowId);\n      row.extend = false;\n      row.index = index || 0;\n      row.offset = offset || 0;\n      row.rowType = rowType;\n      _rowsTree.add(parentRowId, rowId, row);\n      _rowHash[child.id] = rowId;\n    });\n  }\n  function _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren) {\n    var row = _rowsTree.node(rowId);\n    if (!row) {\n      row = new Row(rowId);\n      row.extend = extendChildren;\n      row.index = index || 0;\n      row.offset = offset || 0;\n      row.rowType = rowType;\n      _rowsTree.add(parentRowId, rowId, row);\n    }\n    nodes.forEach(child => {\n      _rowHash[child.id] = rowId;\n    });\n  }\n\n  /* measure depth of rows in rowsTree, count number of assistants and child rows, find depth of partner's branches */\n  function align(debug) {\n    _rowsTree.loopPostOrder(this, function (rowId, row, parentRowId, parentRow) {\n      row.depth = row.getDepth() + row.offset;\n      if (parentRow != null) {\n        parentRow.addRowDepth(row.rowType, row.extend, row.index, row.depth);\n      }\n    });\n  }\n\n  // function loopGroupTypes(rowType, len)\n  function loopGroupTypes(thisArg, nodeId, onGroupType) {\n    var rowId = _rowHash[nodeId];\n    var row = _rowsTree.node(rowId);\n    if (row) {\n      for (var index = 0, len = row.groups.length; index < len; index += 1) {\n        if (row.groups[index]) {\n          if (onGroupType.call(thisArg, index, len)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  function getRowDepth(nodeId, groupType, index) {\n    var rowId = _rowHash[nodeId];\n    var row = _rowsTree.node(rowId);\n    var childRow = (row.groups[groupType] || [])[index];\n    return childRow && childRow[0] || 1;\n  }\n  function getGroupSize(nodeId, groupType) {\n    var rowId = _rowHash[nodeId];\n    var row = _rowsTree.node(rowId);\n    if (row) {\n      if (row.groups.hasOwnProperty(groupType)) {\n        return row.groups[groupType].length;\n      }\n    }\n    return 0;\n  }\n  function getRowsDepth(nodeId, groupType) {\n    var rowId = _rowHash[nodeId];\n    var row = _rowsTree.node(rowId);\n    var children = row.groups[groupType] || [];\n    return children.map(item => item[0]);\n  }\n\n  // function onRow(rowDepth, index)\n  function loopRows(thisArg, nodeId, rowType, onRow) {\n    var rowId = _rowHash[nodeId];\n    var row = _rowsTree.node(rowId);\n    var groupIndex = RowTypeToGroupTypeMap[rowType];\n    var children = row.groups[groupIndex] || [];\n    for (var index = 0; index < children.length; index += 1) {\n      var childRow = children[index];\n      if (childRow) {\n        if (onRow.call(thisArg, childRow[0], index)) {\n          break;\n        }\n      }\n    }\n  }\n  return {\n    mergeToParent: mergeToParent,\n    mergeToChild: mergeToChild,\n    addChild: addChild,\n    addSplitChildren: addSplitChildren,\n    align: align,\n    loopGroupTypes: loopGroupTypes,\n    getRowDepth: getRowDepth,\n    getRowsDepth: getRowsDepth,\n    loopRows: loopRows,\n    getGroupSize: getGroupSize\n  };\n}\nexport default BranchAligner;","map":{"version":3,"names":["Tree","RowType","GroupType","RowTypeToGroupTypeMap","RowKeyGenerator","_rowsHash","_rowIndex","find","parentId","rowType","index","key","hasOwnProperty","get","result","Row","id","Items","offset","extend","depth","groups","getDepth","currExtend","currDepth","reduce","acc","row","_ref","item","Math","max","addRowDepth","groupIndex","rows","BranchAligner","_rowsTree","_rowKeyGenerator","_rowHash","_createParentRow","parentNodeId","parentRowId","Children","parentRow","add","mergeToParent","nodes","forEach","child","mergeToChild","extendChildren","rowId","_add","addChild","addSplitChildren","node","align","debug","loopPostOrder","loopGroupTypes","thisArg","nodeId","onGroupType","len","length","call","getRowDepth","groupType","childRow","getGroupSize","getRowsDepth","children","map","loopRows","onRow"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/tasks/transformations/visualTreeBuilder/BranchAligner.js"],"sourcesContent":["import Tree from '../../../algorithms/Tree';\r\nimport { RowType, GroupType, RowTypeToGroupTypeMap } from './enums';\r\n\r\nfunction RowKeyGenerator() {\r\n  var _rowsHash = {};\r\n  var _rowIndex = 1;\r\n\r\n  function find(parentId, rowType, index) {\r\n    var key = parentId + '-' + rowType + '-' + index;\r\n    if(!_rowsHash.hasOwnProperty(key)) {\r\n        _rowsHash[key] = _rowIndex;\r\n        _rowIndex+=1;\r\n    }\r\n    return _rowsHash[key];\r\n  }\r\n\r\n  function get() {\r\n    var result = _rowIndex;\r\n    _rowIndex+=1;\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    find: find,\r\n    get: get\r\n  }\r\n}\r\n\r\nfunction Row(id) {\r\n  this.id = id;\r\n  this.rowType = RowType.Items;\r\n  this.index = 0;\r\n  this.offset = 0;\r\n  this.extend = true; /* indicates that we need to keep branches of this row children above subsequent rows */\r\n  this.depth = 0;\r\n  \r\n  this.groups = [];\r\n  this.groups[GroupType.Items] = [[1,1]];\r\n  \r\n  this.getDepth = function() {\r\n    var [currExtend, currDepth] = this.groups.reduce((acc, row) => {\r\n        return row.reduce(([currExtend, currDepth], item) => {\r\n          var [extend, depth] = item || [1, 1];\r\n          return [currExtend + extend, Math.max(currDepth, currExtend + depth)];\r\n        }, acc)\r\n    }, [0,0]);\r\n    return Math.max(currExtend, currDepth) || 1;\r\n  };\r\n\r\n\r\n  this.addRowDepth = function(rowType, extend, index, depth) {\r\n    var groupIndex = RowTypeToGroupTypeMap[rowType];\r\n    if(!this.groups[groupIndex]) {\r\n      this.groups[groupIndex] = [];\r\n    }\r\n    var rows = this.groups[groupIndex];\r\n    var [currExtend, currDepth] = rows[index] || [1,1];\r\n    rows[index] = [Math.max(currExtend, extend ? depth : 1), Math.max(currDepth, depth)];\r\n  }\r\n}\r\n\r\nfunction BranchAligner() {\r\n  var _rowsTree = Tree();\r\n  var _rowKeyGenerator = RowKeyGenerator();\r\n  var _rowHash = {}; // rowHash[nodeId] = rowKey;\r\n\r\n  function _createParentRow(parentNodeId) {\r\n      var parentRowId = _rowKeyGenerator.find(null, RowType.Children, 0);\r\n      var parentRow = new Row(parentRowId);\r\n      parentRow.rowType = RowType.Items;\r\n      parentRow.index = 0;\r\n      parentRow.offset = 0;\r\n      parentRow.extend = false;\r\n      _rowsTree.add(null, parentRowId, parentRow);\r\n      _rowHash[parentNodeId] = parentRowId;\r\n      return parentRowId;\r\n  }\r\n\r\n  function mergeToParent(parentNodeId, nodes) {\r\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\r\n    nodes.forEach(child => {\r\n        _rowHash[child.id] = parentRowId;\r\n    });\r\n  }\r\n\r\n  function mergeToChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {\r\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\r\n    var rowId = _rowKeyGenerator.find(parentRowId, rowType, index);\r\n    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);\r\n  }\r\n\r\n  function addChild(parentNodeId, nodes, rowType, index, offset, extendChildren) {\r\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\r\n    var rowId = _rowKeyGenerator.get();\r\n    _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren);\r\n  }\r\n\r\n  function addSplitChildren(parentNodeId, nodes, rowType, index, offset) {\r\n    var parentRowId = _rowHash[parentNodeId] || _createParentRow(parentNodeId);\r\n    nodes.forEach(child => {\r\n      var rowId = _rowKeyGenerator.get();\r\n      var row = new Row(rowId);\r\n      row.extend = false;\r\n      row.index = index || 0;\r\n      row.offset = offset || 0;\r\n      row.rowType = rowType;\r\n      _rowsTree.add(parentRowId, rowId, row);\r\n      _rowHash[child.id] = rowId;\r\n    })\r\n  }\r\n\r\n  function _add(parentRowId, rowId, nodes, rowType, index, offset, extendChildren) {\r\n    var row = _rowsTree.node(rowId);\r\n    if(!row) {\r\n      row = new Row(rowId);\r\n      row.extend = extendChildren;\r\n      row.index = index || 0;\r\n      row.offset = offset || 0;\r\n      row.rowType = rowType;\r\n      _rowsTree.add(parentRowId, rowId, row);\r\n    }\r\n    nodes.forEach(child => {\r\n      _rowHash[child.id] = rowId;\r\n    });\r\n  }\r\n\r\n  /* measure depth of rows in rowsTree, count number of assistants and child rows, find depth of partner's branches */\r\n  function align(debug) {\r\n    _rowsTree.loopPostOrder(this, function (rowId, row, parentRowId, parentRow) {\r\n        row.depth = row.getDepth() + row.offset;\r\n        if(parentRow != null) {\r\n            parentRow.addRowDepth(row.rowType, row.extend, row.index, row.depth);\r\n        }\r\n    });\r\n  }\r\n\r\n  // function loopGroupTypes(rowType, len)\r\n  function loopGroupTypes(thisArg, nodeId, onGroupType) {\r\n    var rowId = _rowHash[nodeId];\r\n    var row = _rowsTree.node(rowId);\r\n    if(row) {\r\n      for(var index = 0, len = row.groups.length; index < len; index+=1) {\r\n        if(row.groups[index]) {\r\n          if(onGroupType.call(thisArg, index, len)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }    \r\n\r\n  function getRowDepth(nodeId, groupType, index) {\r\n    var rowId = _rowHash[nodeId];\r\n    var row = _rowsTree.node(rowId);\r\n    var childRow = (row.groups[groupType] || [])[index];\r\n    return (childRow && childRow[0]) || 1;\r\n  }\r\n\r\n  function getGroupSize(nodeId, groupType) {\r\n    var rowId = _rowHash[nodeId];\r\n    var row = _rowsTree.node(rowId);\r\n    if(row) {\r\n      if(row.groups.hasOwnProperty(groupType)){\r\n        return row.groups[groupType].length; \r\n      } \r\n    }\r\n    return 0;\r\n  }  \r\n\r\n  function getRowsDepth(nodeId, groupType) {\r\n    var rowId = _rowHash[nodeId];\r\n    var row = _rowsTree.node(rowId);\r\n    var children = row.groups[groupType] || [];\r\n    return children.map(item => item[0]);\r\n  }\r\n\r\n  // function onRow(rowDepth, index)\r\n  function loopRows(thisArg, nodeId, rowType, onRow) {\r\n    var rowId = _rowHash[nodeId];\r\n    var row = _rowsTree.node(rowId);\r\n    var groupIndex = RowTypeToGroupTypeMap[rowType];\r\n    var children = row.groups[groupIndex] || [];\r\n    for(var index = 0; index < children.length; index+=1) {\r\n      var childRow = children[index];\r\n      if(childRow) {\r\n        if(onRow.call(thisArg, childRow[0], index)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n      mergeToParent: mergeToParent,\r\n      mergeToChild: mergeToChild,\r\n      addChild: addChild,\r\n      addSplitChildren: addSplitChildren,\r\n      align: align,\r\n      loopGroupTypes: loopGroupTypes,\r\n      getRowDepth: getRowDepth,\r\n      getRowsDepth: getRowsDepth,\r\n      loopRows: loopRows,\r\n      getGroupSize: getGroupSize\r\n  }\r\n}\r\n\r\nexport default BranchAligner;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}