{"ast":null,"code":"import Graph from '../../algorithms/Graph';\nexport default function ConnectionsGraphTask(getGraphics, createTransformTask, connectorsOptionTask, visualTreeLevelsTask, extractNestedLayoutsTask, alignDiagramTask, removeLoopsTask) {\n  var _data = {\n    graph: null,\n    nodeid: 0\n  };\n  function process() {\n    var bundles = visualTreeLevelsTask.getBundles(),\n      bundles2 = extractNestedLayoutsTask.getBundles(),\n      nestedLayoutParentConnectorIds = extractNestedLayoutsTask.getNestedLayoutParentConnectorIds(),\n      nestedLayoutBottomConnectorIds = extractNestedLayoutsTask.getNestedLayoutBottomConnectorIds(),\n      connectorsOptions = connectorsOptionTask.getOptions(),\n      loops = removeLoopsTask != null ? removeLoopsTask.getLoops() : [];\n    bundles = bundles.concat(bundles2);\n    var data = {\n      graph: Graph(),\n      nodeid: 0\n    };\n    var params = {\n      treeItemsPositions: alignDiagramTask.getItemsPositions(),\n      nestedLayoutParentConnectorIds: nestedLayoutParentConnectorIds,\n      nestedLayoutBottomConnectorIds: nestedLayoutBottomConnectorIds,\n      transform: createTransformTask.getTransform()\n    };\n    var options = {\n      connectorType: connectorsOptions.connectorType,\n      showExtraArrows: connectorsOptions.showExtraArrows,\n      bevelSize: connectorsOptions.bevelSize,\n      elbowType: connectorsOptions.elbowType\n    };\n    for (var index = 0, len = bundles.length; index < len; index += 1) {\n      var bundle = bundles[index];\n      bundle.trace(data, params, options);\n    }\n    TraceLoops(data.graph, loops, connectorsOptions.extraArrowsMinimumSpace);\n    _data = data;\n    return true;\n  }\n  function TraceLoops(graph, loops) {\n    var edges = [];\n    for (var isOppositeFlow = 1; isOppositeFlow >= 0; isOppositeFlow -= 1) {\n      for (var index = 0, len = loops.length; index < len; index += 1) {\n        var loop = loops[index];\n        if (loop.isOppositeFlow == (isOppositeFlow == 1)) {\n          graph.getShortestPath(this, loop.from, [loop.to], function (connectorEdge, fromItem, toItem) {\n            return connectorEdge.weight;\n          }, function (path, to) {\n            for (var index2 = 0, len2 = path.length - 1; index2 < len2; index2 += 1) {\n              var fromItem = path[index2],\n                toItem = path[index2 + 1];\n              var edge = graph.edge(fromItem, toItem);\n              if (edge.polyline.length() > 0) {\n                edge.isOppositeFlow = isOppositeFlow == 1;\n                edges.push(edge);\n              }\n            }\n          }); //ignore jslint\n        }\n      }\n    }\n    for (var index = 0, len = edges.length; index < len; index += 1) {\n      var edge = edges[index];\n      if (edge.isOppositeFlow) {\n        edge.hasArrow = true;\n      }\n    }\n  }\n  function getGraph() {\n    return _data.graph;\n  }\n  return {\n    process: process,\n    getGraph: getGraph\n  };\n}\n;","map":{"version":3,"names":["Graph","ConnectionsGraphTask","getGraphics","createTransformTask","connectorsOptionTask","visualTreeLevelsTask","extractNestedLayoutsTask","alignDiagramTask","removeLoopsTask","_data","graph","nodeid","process","bundles","getBundles","bundles2","nestedLayoutParentConnectorIds","getNestedLayoutParentConnectorIds","nestedLayoutBottomConnectorIds","getNestedLayoutBottomConnectorIds","connectorsOptions","getOptions","loops","getLoops","concat","data","params","treeItemsPositions","getItemsPositions","transform","getTransform","options","connectorType","showExtraArrows","bevelSize","elbowType","index","len","length","bundle","trace","TraceLoops","extraArrowsMinimumSpace","edges","isOppositeFlow","loop","getShortestPath","from","to","connectorEdge","fromItem","toItem","weight","path","index2","len2","edge","polyline","push","hasArrow","getGraph"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/tasks/transformations/ConnectionsGraphTask.js"],"sourcesContent":["import Graph from '../../algorithms/Graph';\r\n\r\nexport default function ConnectionsGraphTask(getGraphics, createTransformTask, connectorsOptionTask, visualTreeLevelsTask, extractNestedLayoutsTask, alignDiagramTask, removeLoopsTask) {\r\n  var _data = {\r\n    graph: null,\r\n    nodeid: 0\r\n  };\r\n\r\n  function process() {\r\n    var bundles = visualTreeLevelsTask.getBundles(),\r\n      bundles2 = extractNestedLayoutsTask.getBundles(),\r\n      nestedLayoutParentConnectorIds = extractNestedLayoutsTask.getNestedLayoutParentConnectorIds(),\r\n      nestedLayoutBottomConnectorIds = extractNestedLayoutsTask.getNestedLayoutBottomConnectorIds(),\r\n      connectorsOptions = connectorsOptionTask.getOptions(),\r\n      loops = removeLoopsTask != null ? removeLoopsTask.getLoops() : [];\r\n\r\n    bundles = bundles.concat(bundles2);\r\n\r\n    var data = {\r\n      graph: Graph(),\r\n      nodeid: 0\r\n    };\r\n\r\n    var params = {\r\n      treeItemsPositions: alignDiagramTask.getItemsPositions(),\r\n      nestedLayoutParentConnectorIds: nestedLayoutParentConnectorIds,\r\n      nestedLayoutBottomConnectorIds: nestedLayoutBottomConnectorIds,\r\n      transform: createTransformTask.getTransform()\r\n    };\r\n\r\n    var options = {\r\n      connectorType: connectorsOptions.connectorType,\r\n      showExtraArrows: connectorsOptions.showExtraArrows,\r\n      bevelSize: connectorsOptions.bevelSize,\r\n      elbowType: connectorsOptions.elbowType\r\n    };\r\n\r\n    for (var index = 0, len = bundles.length; index < len; index += 1) {\r\n      var bundle = bundles[index];\r\n\r\n      bundle.trace(data, params, options);\r\n    }\r\n\r\n    TraceLoops(data.graph, loops, connectorsOptions.extraArrowsMinimumSpace);\r\n\r\n    _data = data;\r\n\r\n    return true;\r\n  }\r\n\r\n  function TraceLoops(graph, loops) {\r\n    var edges = [];\r\n    for(var isOppositeFlow = 1; isOppositeFlow >= 0; isOppositeFlow -=1) {\r\n      for (var index = 0, len = loops.length; index < len; index += 1) {\r\n        var loop = loops[index];\r\n        if(loop.isOppositeFlow == (isOppositeFlow == 1)) {\r\n          graph.getShortestPath(this, loop.from, [loop.to], function (connectorEdge, fromItem, toItem) {\r\n            return connectorEdge.weight;\r\n          }, function (path, to) {\r\n            for (var index2 = 0, len2 = path.length - 1; index2 < len2; index2 += 1) {\r\n              var fromItem = path[index2], toItem = path[index2 + 1];\r\n              var edge = graph.edge(fromItem, toItem);\r\n              if(edge.polyline.length() > 0) {\r\n                edge.isOppositeFlow = (isOppositeFlow == 1);\r\n                edges.push(edge);\r\n              }\r\n            }\r\n          }); //ignore jslint\r\n        }\r\n      }\r\n    }\r\n    for (var index = 0, len = edges.length; index < len; index += 1) {\r\n      var edge = edges[index];\r\n      if(edge.isOppositeFlow) {\r\n        edge.hasArrow = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getGraph() {\r\n    return _data.graph;\r\n  }\r\n\r\n  return {\r\n    process: process,\r\n    getGraph: getGraph\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}