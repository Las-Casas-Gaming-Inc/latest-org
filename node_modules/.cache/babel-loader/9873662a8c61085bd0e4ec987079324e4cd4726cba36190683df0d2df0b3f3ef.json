{"ast":null,"code":"import Rect from '../graphics/structs/Rect';\n/**\r\n * Creates Quad Tree data structure. It distributes points into equal quadrants. \r\n * So it is equivalent to 2 dimensional binary search tree. \r\n * @class QuadTree\r\n * \r\n * @param {number} minimalSize Defines minimal size of the quadrant. This protects structure against unnecessary depth.\r\n * @returns {QuadTree} Returns Quad Tree data structure.\r\n */\nexport default function QuadTree(minimalSize) {\n  var _minimalScale = Math.max(1, scale(minimalSize)),\n    _rootScale = 8,\n    _rootSize = 256,\n    _rootCell = null;\n\n  // Create root cell\n  _rootCell = new Cell(0, 0, _rootScale, _rootSize);\n  function Cell(x, y, scale, size) {\n    this.x = x;\n    this.y = y;\n    this.scale = scale;\n    this.size = size;\n    this.quadrants = [];\n    this.points = [];\n  }\n  Cell.prototype.notEnclosed = function (rect) {\n    if (this.x < rect.x || this.x + this.size > rect.x + rect.width || this.y < rect.y || this.y + this.size > rect.y + rect.height) {\n      return true;\n    }\n    return false;\n  };\n  Cell.prototype.overlaps = function (rect) {\n    if (this.x + this.size < rect.x || rect.x + rect.width < this.x || this.y + this.size < rect.y || rect.y + rect.height < this.y) {\n      return false;\n    }\n    return true;\n  };\n  Cell.prototype.getQuadrantIndex = function (x, y) {\n    var shift = this.scale - 1;\n    return x >> shift & 1 | (y >> shift & 1) << 1;\n  };\n  function scale(value) {\n    return Math.floor(Math.log(value) / Math.log(2));\n  }\n\n  /**\r\n   * Adds point\r\n   * \r\n   * @param {Point} point Point\r\n   */\n  function addPoint(point) {\n    var x = Math.floor(point.x),\n      y = Math.floor(point.y),\n      size = Math.max(x, y);\n    while (_rootSize <= size) {\n      _rootScale += 1;\n      _rootSize *= 2;\n      var parent = new Cell(0, 0, _rootScale, _rootSize);\n      _splitCell(parent);\n      parent.quadrants[0] = _rootCell;\n      _rootCell = parent;\n    }\n    _addPoint(point);\n  }\n  function _addPoint(point) {\n    var x = Math.floor(point.x),\n      y = Math.floor(point.y),\n      cell = _rootCell;\n    if (x < 0 || y < 0) {\n      throw \"Negative values are not supported in the quad tree.\";\n    }\n    while (cell.points == null || cell.points.length > 0) {\n      if (cell.scale == _minimalScale && cell.points != null) {\n        break;\n      }\n      if (cell.points != null && cell.points.length > 0) {\n        _splitCell(cell);\n      }\n      cell = cell.quadrants[cell.getQuadrantIndex(x, y)];\n    }\n    cell.points.push(point);\n  }\n  function _splitCell(parent) {\n    var size = parent.size / 2;\n    parent.quadrants = [new Cell(parent.x, parent.y, parent.scale - 1, size), new Cell(parent.x + size, parent.y, parent.scale - 1, size), new Cell(parent.x, parent.y + size, parent.scale - 1, size), new Cell(parent.x + size, parent.y + size, parent.scale - 1, size)];\n    for (var index = 0, len = parent.points.length; index < len; index += 1) {\n      var point = parent.points[index],\n        x = Math.floor(point.x),\n        y = Math.floor(point.y);\n      parent.quadrants[parent.getQuadrantIndex(x, y)].points.push(point);\n    }\n\n    // indicates that cell has quadrants\n    parent.points = null;\n  }\n\n  /**\r\n   * Callback function for iteration of points\r\n   * \r\n   * @callback onQuadTreePointCallback\r\n   * @param {Point} point Rectangle\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops rectangular area of quad tree structure\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {Rect} rect Rectangular search area\r\n   * @param {onQuadTreePointCallback} onItem Callback function to call for every point within the search area\r\n   */\n  function loopArea(thisArg, rect, onItem) {\n    var cell, index, len;\n    if (onItem != null) {\n      var check = [_rootCell],\n        nocheck = [];\n      while (check.length > 0 || nocheck.length > 0) {\n        var newCheck = [],\n          newNocheck = [];\n        for (index = 0, len = check.length; index < len; index += 1) {\n          cell = check[index];\n          if (cell.overlaps(rect)) {\n            if (cell.notEnclosed(rect)) {\n              if (cell.points == null) {\n                for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n                  newCheck.push(cell.quadrants[quadrantIndex]);\n                }\n              } else {\n                for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n                  var point = cell.points[pointIndex];\n                  if (rect.contains(point)) {\n                    if (onItem.call(thisArg, point)) {\n                      return;\n                    }\n                  }\n                }\n              }\n            } else {\n              nocheck.push(cell);\n            }\n          }\n        }\n        for (index = 0, len = nocheck.length; index < len; index += 1) {\n          cell = nocheck[index];\n          if (cell.points == null) {\n            for (quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n              newNocheck.push(cell.quadrants[quadrantIndex]);\n            }\n          } else {\n            for (pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n              if (onItem.call(thisArg, cell.points[pointIndex])) {\n                return;\n              }\n            }\n          }\n        }\n        check = newCheck;\n        nocheck = newNocheck;\n      }\n    }\n  }\n\n  /**\r\n   * Validates internal data consistency of quad tree data structure\r\n   * \r\n   * @returns {boolean} Returns true if structure pass validation\r\n   */\n  function validate() {\n    var level = [_rootCell];\n    while (level.length > 0) {\n      var newLevel = [];\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n        if (cell.points != null && cell.quadrants.length > 0) {\n          return false;\n        }\n        if (cell.points == null) {\n          for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n            newLevel.push(cell.quadrants[quadrantIndex]);\n          }\n        } else {\n          for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n            var point = cell.points[pointIndex];\n            if (!rect.contains(point)) {\n              return false;\n            }\n          }\n        }\n      }\n      level = newLevel;\n    }\n    return true;\n  }\n\n  /**\r\n   * Returns collection of quadrants created in the data structure\r\n   * Quadrants exists only when elements exists in them.\r\n   * This method is used for visual debugging of the structure.\r\n   * \r\n   * @param {React} selection Rectangular test area to highlight quadrants\r\n   * @returns {Rect[]} Returns collection of available quadrants.\r\n   * Quadrants containing points within selection area have context.highlight property set to true.\r\n   */\n  function getPositions(selection) {\n    var result = [];\n    var count = 0;\n    var level = [_rootCell];\n    while (level.length > 0) {\n      var newLevel = [];\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n        rect.context = {\n          isHighlighted: false\n        };\n        count += 1;\n        if (selection != null && selection.overlaps(rect) && cell.points != null && cell.points.length > 0) {\n          rect.context.isHighlighted = true;\n        }\n        result.push(rect);\n        for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n          var quadrant = cell.quadrants[quadrantIndex];\n          if (quadrant != null) {\n            newLevel.push(quadrant);\n          }\n        }\n      }\n      level = newLevel;\n    }\n    return result;\n  }\n  return {\n    addPoint: addPoint,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n}\n;","map":{"version":3,"names":["Rect","QuadTree","minimalSize","_minimalScale","Math","max","scale","_rootScale","_rootSize","_rootCell","Cell","x","y","size","quadrants","points","prototype","notEnclosed","rect","width","height","overlaps","getQuadrantIndex","shift","value","floor","log","addPoint","point","parent","_splitCell","_addPoint","cell","length","push","index","len","loopArea","thisArg","onItem","check","nocheck","newCheck","newNocheck","quadrantIndex","pointIndex","pointsLen","contains","call","validate","level","newLevel","getPositions","selection","result","count","context","isHighlighted","quadrant"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/QuadTree.js"],"sourcesContent":["import Rect from '../graphics/structs/Rect';\r\n/**\r\n * Creates Quad Tree data structure. It distributes points into equal quadrants. \r\n * So it is equivalent to 2 dimensional binary search tree. \r\n * @class QuadTree\r\n * \r\n * @param {number} minimalSize Defines minimal size of the quadrant. This protects structure against unnecessary depth.\r\n * @returns {QuadTree} Returns Quad Tree data structure.\r\n */\r\nexport default function QuadTree(minimalSize) {\r\n  var _minimalScale = Math.max(1, scale(minimalSize)),\r\n    _rootScale = 8,\r\n    _rootSize = 256,\r\n    _rootCell = null;\r\n\r\n  // Create root cell\r\n  _rootCell = new Cell(0, 0, _rootScale, _rootSize);\r\n\r\n  function Cell(x, y, scale, size) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.scale = scale;\r\n    this.size = size;\r\n    this.quadrants = [];\r\n    this.points = [];\r\n  }\r\n\r\n  Cell.prototype.notEnclosed = function (rect) {\r\n    if (this.x < rect.x || this.x + this.size > rect.x + rect.width || this.y < rect.y || this.y + this.size > rect.y + rect.height) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  Cell.prototype.overlaps = function (rect) {\r\n    if (this.x + this.size < rect.x || rect.x + rect.width < this.x || this.y + this.size < rect.y || rect.y + rect.height < this.y) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  Cell.prototype.getQuadrantIndex = function (x, y) {\r\n    var shift = this.scale - 1;\r\n    return ((x >> shift) & 1) | (((y >> shift) & 1) << 1);\r\n  };\r\n\r\n  function scale(value) {\r\n    return Math.floor(Math.log(value) / Math.log(2));\r\n  }\r\n\r\n  /**\r\n   * Adds point\r\n   * \r\n   * @param {Point} point Point\r\n   */\r\n  function addPoint(point) {\r\n    var x = Math.floor(point.x),\r\n      y = Math.floor(point.y),\r\n      size = Math.max(x, y);\r\n\r\n    while (_rootSize <= size) {\r\n      _rootScale += 1;\r\n      _rootSize *= 2;\r\n      var parent = new Cell(0, 0, _rootScale, _rootSize);\r\n      _splitCell(parent);\r\n      parent.quadrants[0] = _rootCell;\r\n      _rootCell = parent;\r\n    }\r\n    _addPoint(point);\r\n  }\r\n\r\n  function _addPoint(point) {\r\n    var x = Math.floor(point.x),\r\n      y = Math.floor(point.y),\r\n      cell = _rootCell;\r\n    if (x < 0 || y < 0) {\r\n      throw \"Negative values are not supported in the quad tree.\";\r\n    }\r\n    while (cell.points == null || cell.points.length > 0) {\r\n      if (cell.scale == _minimalScale && cell.points != null) {\r\n        break;\r\n      }\r\n      if (cell.points != null && cell.points.length > 0) {\r\n        _splitCell(cell);\r\n      }\r\n      cell = cell.quadrants[cell.getQuadrantIndex(x, y)];\r\n    }\r\n    cell.points.push(point);\r\n  }\r\n\r\n  function _splitCell(parent) {\r\n    var size = parent.size / 2;\r\n    parent.quadrants = [\r\n      new Cell(parent.x, parent.y, parent.scale - 1, size),\r\n      new Cell(parent.x + size, parent.y, parent.scale - 1, size),\r\n      new Cell(parent.x, parent.y + size, parent.scale - 1, size),\r\n      new Cell(parent.x + size, parent.y + size, parent.scale - 1, size)\r\n    ];\r\n    for (var index = 0, len = parent.points.length; index < len; index += 1) {\r\n      var point = parent.points[index],\r\n        x = Math.floor(point.x),\r\n        y = Math.floor(point.y);\r\n\r\n      parent.quadrants[parent.getQuadrantIndex(x, y)].points.push(point);\r\n    }\r\n\r\n    // indicates that cell has quadrants\r\n    parent.points = null;\r\n  }\r\n\r\n  /**\r\n   * Callback function for iteration of points\r\n   * \r\n   * @callback onQuadTreePointCallback\r\n   * @param {Point} point Rectangle\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops rectangular area of quad tree structure\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {Rect} rect Rectangular search area\r\n   * @param {onQuadTreePointCallback} onItem Callback function to call for every point within the search area\r\n   */\r\n  function loopArea(thisArg, rect, onItem) {\r\n    var cell,\r\n      index, len;\r\n    if (onItem != null) {\r\n      var check = [_rootCell],\r\n        nocheck = [];\r\n      while (check.length > 0 || nocheck.length > 0) {\r\n        var newCheck = [],\r\n          newNocheck = [];\r\n        for (index = 0, len = check.length; index < len; index += 1) {\r\n          cell = check[index];\r\n          if (cell.overlaps(rect)) {\r\n            if (cell.notEnclosed(rect)) {\r\n              if (cell.points == null) {\r\n                for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\r\n                  newCheck.push(cell.quadrants[quadrantIndex]);\r\n                }\r\n              } else {\r\n                for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\r\n                  var point = cell.points[pointIndex];\r\n                  if (rect.contains(point)) {\r\n                    if (onItem.call(thisArg, point)) {\r\n                      return;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              nocheck.push(cell);\r\n            }\r\n          }\r\n        }\r\n        for (index = 0, len = nocheck.length; index < len; index += 1) {\r\n          cell = nocheck[index];\r\n          if (cell.points == null) {\r\n            for (quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\r\n              newNocheck.push(cell.quadrants[quadrantIndex]);\r\n            }\r\n          } else {\r\n            for (pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\r\n              if (onItem.call(thisArg, cell.points[pointIndex])) {\r\n                return;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        check = newCheck;\r\n        nocheck = newNocheck;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates internal data consistency of quad tree data structure\r\n   * \r\n   * @returns {boolean} Returns true if structure pass validation\r\n   */\r\n  function validate() {\r\n    var level = [_rootCell];\r\n    while (level.length > 0) {\r\n      var newLevel = [];\r\n      for (var index = 0, len = level.length; index < len; index += 1) {\r\n        var cell = level[index];\r\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\r\n        if (cell.points != null && cell.quadrants.length > 0) {\r\n          return false;\r\n        }\r\n        if (cell.points == null) {\r\n          for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\r\n            newLevel.push(cell.quadrants[quadrantIndex]);\r\n          }\r\n        } else {\r\n          for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\r\n            var point = cell.points[pointIndex];\r\n            if (!rect.contains(point)) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      level = newLevel;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns collection of quadrants created in the data structure\r\n   * Quadrants exists only when elements exists in them.\r\n   * This method is used for visual debugging of the structure.\r\n   * \r\n   * @param {React} selection Rectangular test area to highlight quadrants\r\n   * @returns {Rect[]} Returns collection of available quadrants.\r\n   * Quadrants containing points within selection area have context.highlight property set to true.\r\n   */\r\n  function getPositions(selection) {\r\n    var result = [];\r\n    var count = 0;\r\n    var level = [_rootCell];\r\n    while (level.length > 0) {\r\n      var newLevel = [];\r\n      for (var index = 0, len = level.length; index < len; index += 1) {\r\n        var cell = level[index];\r\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\r\n        rect.context = {\r\n          isHighlighted: false\r\n        };\r\n        count += 1;\r\n        if (selection != null && selection.overlaps(rect) && cell.points != null && cell.points.length > 0) {\r\n          rect.context.isHighlighted = true;\r\n        }\r\n\r\n        result.push(rect);\r\n        for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\r\n          var quadrant = cell.quadrants[quadrantIndex];\r\n          if (quadrant != null) {\r\n            newLevel.push(quadrant);\r\n          }\r\n        }\r\n      }\r\n      level = newLevel;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    addPoint: addPoint,\r\n    loopArea: loopArea,\r\n    validate: validate,\r\n    getPositions: getPositions\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}