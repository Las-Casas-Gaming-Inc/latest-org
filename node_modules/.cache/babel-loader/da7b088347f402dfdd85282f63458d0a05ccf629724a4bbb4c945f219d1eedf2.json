{"ast":null,"code":"import { isObject, cloneObject, isEmptyObject } from '../common';\nimport Graph from './Graph';\nimport LinkedHashItems from './LinkedHashItems';\n/**\r\n* Family node\r\n* @class FamilyNode\r\n* @property {string} id Id\r\n* @property {object} node Node\r\n*/\nfunction FamilyNode(id, node) {\n  this.id = id;\n  this.node = node;\n}\n\n/**\r\n * Creates a family object\r\n * \r\n * @class Family\r\n * \r\n * @param {Family} [source=undefined] Reference to optional family object to clone properties from\r\n * \r\n * @returns {Family} Returns new instance of family structure\r\n */\nexport default function Family(source) {\n  var _roots = {},\n    // children hash of orphant parent id\n    _rootsCount = {},\n    _children = {},\n    // children hash by node id\n    _childrenCount = {},\n    _parents = {},\n    // parents hash by node id\n    _parentsCount = {},\n    _nodes = {},\n    // nodes by node id\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\n    BREAK = 1,\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\n    SKIP = 2;\n  _init(source);\n  function _init(source) {\n    if (isObject(source)) {\n      _roots = cloneObject(source.roots, false);\n      _rootsCount = cloneObject(source.rootsCount, true);\n      _children = cloneObject(source.children, false);\n      _childrenCount = cloneObject(source.childrenCount, true);\n      _parents = cloneObject(source.parents, false);\n      _parentsCount = cloneObject(source.parentsCount, true);\n      _nodes = cloneObject(source.nodes, true);\n    }\n  }\n  function _loop(thisArg, collection, itemid, onItem) {\n    var item, items;\n    if (onItem != null) {\n      items = collection[itemid];\n      if (items != null) {\n        for (item in items) {\n          if (items.hasOwnProperty(item)) {\n            if (onItem.call(thisArg, item, items[item])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Adds new family member\r\n   * @param {string[]} parents A collection of parents ids\r\n   * @param {string} nodeid An id of the new node\r\n   * @param {object} node A reference to the new node\r\n   */\n  function add(parents, nodeid, node) {\n    var index,\n      len,\n      parentid,\n      processed = {};\n    if (!parents || parents.length === 0) {\n      parents = [null];\n    }\n    if (_nodes[nodeid] == null && node != null) {\n      _nodes[nodeid] = node;\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n        if (processed[parentid] == null && parentid != nodeid) {\n          processed[parentid] = true;\n          if (_nodes[parentid] != null) {\n            if (_parents[nodeid] == null) {\n              _parents[nodeid] = {};\n              _parentsCount[nodeid] = 0;\n            }\n            if (!_parents[nodeid][parentid]) {\n              _parents[nodeid][parentid] = true;\n              _parentsCount[nodeid] += 1;\n            }\n            if (_children[parentid] == null) {\n              _children[parentid] = {};\n              _childrenCount[parentid] = 0;\n            }\n            if (!_children[parentid][nodeid]) {\n              _children[parentid][nodeid] = true;\n              _childrenCount[parentid] += 1;\n            }\n          } else {\n            if (_roots[parentid] == null) {\n              _roots[parentid] = {};\n              _rootsCount[parentid] = 0;\n            }\n            if (!_roots[parentid][nodeid]) {\n              _roots[parentid][nodeid] = true;\n              _rootsCount[parentid] += 1;\n            }\n          }\n        }\n      }\n      if (_roots[nodeid] != null) {\n        _children[nodeid] = _roots[nodeid];\n        _childrenCount[nodeid] = _rootsCount[nodeid];\n        delete _roots[nodeid];\n        delete _rootsCount[nodeid];\n        _loop(this, _children, nodeid, function (itemid) {\n          if (_parents[itemid] == null) {\n            _parents[itemid] = {};\n            _parentsCount[itemid] = 0;\n          }\n          if (!_parents[itemid][nodeid]) {\n            _parents[itemid][nodeid] = true;\n            _parentsCount[itemid] += 1;\n          }\n        });\n      }\n    }\n  }\n\n  /**\r\n   * Returns family node by id\r\n   * @param {string} nodeid The id of the node\r\n   * @returns {object|undefined} A reference to the node or undefined if id does not exists\r\n   */\n  function node(nodeid) {\n    return _nodes[nodeid];\n  }\n\n  /**\r\n   * Makes node to be a child of every parent in the collection of parents\r\n   * @param {string[]} parents A collection of parents ids\r\n   * @param {string} nodeid An id of the new node\r\n   */\n  function adopt(parents, nodeid) {\n    var index, len, parentid;\n    if (_nodes[nodeid] != null) {\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n        if (_parents[nodeid] == null) {\n          _parents[nodeid] = {};\n          _parentsCount[nodeid] = 0;\n        }\n        if (parentid != nodeid && _nodes[parentid] != null) {\n          if (!_parents[nodeid][parentid]) {\n            _parents[nodeid][parentid] = true;\n            _parentsCount[nodeid] += 1;\n          }\n          if (_children[parentid] == null) {\n            _children[parentid] = {};\n            _childrenCount[parentid] = 0;\n          }\n          if (!_children[parentid][nodeid]) {\n            _children[parentid][nodeid] = true;\n            _childrenCount[parentid] += 1;\n          }\n        } else {\n          throw \"Item cannot be parent of itself and parent should exist in the structure!\";\n        }\n      }\n    } else {\n      throw \"Child should be in hierarchy!\";\n    }\n  }\n\n  /**\r\n   * Removes node\r\n   * @param {string} nodeid The id of the node\r\n   */\n  function removeNode(nodeid) {\n    if (_nodes[nodeid] != null) {\n      _loop(this, _children, nodeid, function (itemid) {\n        delete _parents[itemid][nodeid];\n        _parentsCount[itemid] -= 1;\n        if (!_parentsCount[itemid]) {\n          delete _parents[itemid];\n          delete _parentsCount[itemid];\n          if (_roots[null] == null) {\n            _roots[null] = {};\n            _rootsCount[null] = 0;\n          }\n          if (!_roots[null][itemid]) {\n            _roots[null][itemid] = true;\n            _rootsCount[null] += 1;\n          }\n        }\n      });\n      _loop(this, _parents, nodeid, function (itemid) {\n        delete _children[itemid][nodeid];\n        _childrenCount[itemid] -= 1;\n        if (!_childrenCount[itemid]) {\n          delete _children[itemid];\n          delete _childrenCount[itemid];\n        }\n      });\n      if (_roots[null] != null && _roots[null][nodeid] != null) {\n        delete _roots[null][nodeid];\n        _rootsCount[null] -= 1;\n        if (!_rootsCount[null]) {\n          delete _roots[null];\n          delete _rootsCount[null];\n        }\n      }\n      delete _children[nodeid];\n      delete _childrenCount[nodeid];\n      delete _parents[nodeid];\n      delete _parentsCount[nodeid];\n      delete _nodes[nodeid];\n    }\n  }\n  function _removeChildReference(parentid, childid) {\n    var result = false;\n    if (_children[parentid] != null && _children[parentid][childid] != null) {\n      delete _children[parentid][childid];\n      _childrenCount[parentid] -= 1;\n      delete _parents[childid][parentid];\n      _parentsCount[childid] -= 1;\n      if (!_childrenCount[parentid]) {\n        delete _children[parentid];\n        delete _childrenCount[parentid];\n      }\n      if (!_parents[childid]) {\n        delete _parents[childid];\n        delete _parentsCount[childid];\n        if (_roots[null] == null) {\n          _roots[null] = {};\n          _rootsCount[null] = 0;\n        }\n        _roots[null][childid] = true;\n        _rootsCount[null] += 1;\n      }\n      result = true;\n    }\n    return result;\n  }\n\n  /**\r\n   * Removes first available parent child or child parent relation\r\n   * \r\n   * @param {string} fromid From node id\r\n   * @param {string} toid To node id\r\n   * @returns {true} If relation was broken\r\n   */\n  function removeRelation(fromid, toid) {\n    var result = false;\n    if (_nodes[fromid] != null && _nodes[toid] != null) {\n      result = _removeChildReference(fromid, toid) || _removeChildReference(toid, fromid);\n    }\n    return result;\n  }\n\n  /**\r\n   * Removes child relation\r\n   * \r\n   * @param {string} parentid The parent node id\r\n   * @param {string} childid The child node id\r\n   * @returns {true} If relation was broken\r\n   */\n  function removeChildRelation(parentid, childid) {\n    var result = false;\n    if (_nodes[parentid] != null && _nodes[childid] != null) {\n      result = _removeChildReference(parentid, childid);\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns true if structure has nodes.\r\n   * \r\n   * @returns {boolean} Returns true if family structure has nodes\r\n   */\n  function hasNodes() {\n    return !isEmptyObject(_nodes);\n  }\n\n  /**\r\n   * Callback for iterating family nodes\r\n   * \r\n   * @callback onFamilyItemCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @returns {boolean} Returns true to break the loop\r\n   */\n\n  /**\r\n   * Loops through nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family node \r\n   */\n  function loop(thisArg, onItem) {\n    var item;\n    if (onItem != null) {\n      for (item in _nodes) {\n        if (_nodes.hasOwnProperty(item)) {\n          if (onItem.call(thisArg, item, _nodes[item])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  function _loopItems(thisArg, collection, items, onItem) {\n    // onItem(itemid, item, levelIndex)\n    var newItems,\n      itemid,\n      processed = {},\n      levelIndex = 0,\n      hasItems = true;\n    while (hasItems) {\n      newItems = {};\n      hasItems = false;\n      for (itemid in items) {\n        if (items.hasOwnProperty(itemid)) {\n          if (!processed[itemid]) {\n            processed[itemid] = true;\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n              case 1 /*BREAK*/:\n                newItems = {};\n                hasItems = false;\n                break;\n              case 2 /*SKIP*/:\n                break;\n              default:\n                _loop(this, collection, itemid, function (newItemId) {\n                  if (!processed[newItemId]) {\n                    newItems[newItemId] = true;\n                    hasItems = true;\n                  }\n                }); //ignore jslint\n                break;\n            }\n          }\n        }\n      }\n      items = newItems;\n      levelIndex += 1;\n    }\n  }\n\n  /**\r\n   * Callback for iterating family nodes level by level\r\n   * \r\n   * @callback onFamilyItemWithLevelCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} levelIndex The node level index\r\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n   */\n\n  /**\r\n   * Loops through child nodes of family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The node id to start children traversing\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every child node \r\n   */\n  function loopChildren(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _children[nodeid] != null) {\n        _loopItems(thisArg, _children, _children[nodeid], onItem);\n      }\n    }\n  }\n\n  /**\r\n   * Loops through parent nodes of family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The node id to start parents traversing\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every parent node \r\n   */\n  function loopParents(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _parents[nodeid] != null) {\n        _loopItems(thisArg, _parents, _parents[nodeid], onItem);\n      }\n    }\n  }\n  function _loopTopo(thisArg, backwardCol, backwardCount, forwardCol, forwardCount, onItem) {\n    // onItem(itemid, item, position)\n    var index, len, nodeid, references, queue, newQueue, position;\n    if (onItem != null) {\n      /* count parents for every node */\n      queue = [];\n      references = {};\n      for (nodeid in _nodes) {\n        if (_nodes.hasOwnProperty(nodeid)) {\n          references[nodeid] = backwardCount[nodeid] || 0;\n          if (!references[nodeid]) {\n            queue.push(nodeid);\n          }\n        }\n      }\n\n      /* iterate queue and reduce reference counts via children */\n      position = 0;\n      while (queue.length > 0) {\n        newQueue = [];\n        for (index = 0, len = queue.length; index < len; index += 1) {\n          nodeid = queue[index];\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], position)) {\n            newQueue = [];\n            break;\n          }\n          position += 1;\n          _loop(this, forwardCol, nodeid, function (itemid) {\n            references[itemid] -= 1;\n            if (references[itemid] === 0) {\n              newQueue.push(itemid);\n            }\n          }); //ignore jslint\n        }\n        queue = newQueue;\n      }\n    }\n  }\n\n  /**\r\n   * Callback for iterating family nodes in topological sort order\r\n   * \r\n   * @callback onFamilyTopoCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} position The node position in the sequence\r\n   * @returns {boolean} Returns true to break the loop and exit.\r\n   */\n\n  /**\r\n   * Loops through topologically sorted nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \r\n   */\n  function loopTopo(thisArg, onItem) {\n    _loopTopo(thisArg, _parents, _parentsCount, _children, _childrenCount, onItem);\n  }\n\n  /**\r\n   * Loops through reversed order topologically sorted nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \r\n   */\n  function loopTopoReversed(thisArg, onItem) {\n    _loopTopo(thisArg, _children, _childrenCount, _parents, _parentsCount, onItem);\n  }\n\n  /**\r\n   * Loops through nodes of family structure level by level. This function aligns nodes top or bottom.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {boolean} parentAligned True if nodes should be placed at the next level after their parents level,\r\n   * otherwise nodes placed at levels close to their children.\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every node \r\n   */\n  function loopLevels(thisArg, parentAligned, onItem) {\n    var topoSorted = [],\n      topoSortedPositions = {},\n      processed = {},\n      margin = [],\n      /* result items distribution by levels */\n      levels = {},\n      levelIndex,\n      groups = {},\n      hasGroups,\n      newGroups,\n      groupIndex,\n      group,\n      itemsAtLevel,\n      itemid,\n      minimumLevel = null,\n      loopFunc = parentAligned ? loopTopo : loopTopoReversed,\n      index,\n      len,\n      mIndex,\n      mLen,\n      mItem,\n      mLevel,\n      topoSortedItem,\n      bestPosition,\n      bestItem,\n      bestLevel,\n      bestIsParent,\n      newMargin,\n      hasNeighbours;\n    function Group() {\n      this.items = {};\n      this.minimumLevel = null;\n    }\n    Group.prototype.addItemToLevel = function (itemid, level) {\n      var items = this.items[level];\n      if (!items) {\n        items = [itemid];\n        this.items[level] = items;\n      } else {\n        items.push(itemid);\n      }\n      this.minimumLevel = this.minimumLevel == null ? level : Math.min(this.minimumLevel, level);\n    };\n    function addItemToLevel(itemid, index, level) {\n      var group = groups[index];\n      if (!group) {\n        group = new Group();\n        groups[index] = group;\n      }\n      group.addItemToLevel(itemid, level);\n      minimumLevel = minimumLevel == null ? level : Math.min(minimumLevel, level);\n      levels[itemid] = level;\n      processed[itemid] = true;\n    }\n    if (onItem != null) {\n      /* sort items topologically */\n      loopFunc(this, function (itemid, item, position) {\n        topoSorted.push(itemid);\n        topoSortedPositions[itemid] = position;\n      });\n\n      /* search for the first available non processed item in topological order */\n      for (index = 0, len = topoSorted.length; index < len; index += 1) {\n        topoSortedItem = topoSorted[index];\n        if (processed[topoSortedItem] == null) {\n          margin.push(topoSortedItem);\n          addItemToLevel(topoSortedItem, index, 0);\n\n          /* use regular graph breadth first search */\n          while (margin.length > 0) {\n            bestPosition = null;\n            bestItem = null;\n            bestLevel = null;\n            bestIsParent = !parentAligned;\n            newMargin = [];\n            for (mIndex = 0, mLen = margin.length; mIndex < mLen; mIndex += 1) {\n              mItem = margin[mIndex];\n              mLevel = levels[mItem];\n              hasNeighbours = false;\n              if (parentAligned) {\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n                    if (bestPosition == null || !bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n                    if (bestPosition == null || !bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n              } else {\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n                    if (bestPosition == null || bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n                    if (bestPosition == null || bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n              }\n              if (hasNeighbours) {\n                newMargin.push(mItem);\n              }\n            }\n            if (bestItem != null) {\n              newMargin.push(bestItem);\n              addItemToLevel(bestItem, index, bestLevel);\n            }\n            margin = newMargin;\n          }\n        }\n      }\n      hasGroups = true;\n      levelIndex = minimumLevel;\n      while (hasGroups) {\n        newGroups = {};\n        hasGroups = false;\n        for (groupIndex in groups) {\n          if (groups.hasOwnProperty(groupIndex)) {\n            group = groups[groupIndex];\n            itemsAtLevel = group.items[group.minimumLevel - minimumLevel + levelIndex];\n            if (itemsAtLevel != null) {\n              newGroups[groupIndex] = group;\n              hasGroups = true;\n              for (index = 0, len = itemsAtLevel.length; index < len; index += 1) {\n                itemid = itemsAtLevel[index];\n                if (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex - minimumLevel)) {\n                  hasGroups = false;\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        groups = newGroups;\n        levelIndex += 1;\n      }\n    }\n  }\n\n  /**\r\n   * Loops root nodes of family structure. \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family root node \r\n   */\n  function loopRoots(thisArg, onItem) {\n    var result = null,\n      minimum,\n      counter = 0,\n      famMembers = {},\n      famCount = {},\n      isRoot,\n      roots = {},\n      processed = {},\n      famItemId,\n      member,\n      members,\n      rootid,\n      membersRoots,\n      memberRoots,\n      memberRoot,\n      index,\n      len;\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              if (!famMembers[parentid][itemid]) {\n                famMembers[parentid][itemid] = true;\n                famCount[parentid] += 1;\n              }\n            }\n          }\n        }\n        return SKIP;\n      });\n      if (isRoot) {\n        roots[famItemId] = true;\n        counter += 1;\n      }\n    });\n\n    /* create collection of roots per member */\n    membersRoots = {};\n    for (rootid in roots) {\n      if (roots.hasOwnProperty(rootid)) {\n        members = famMembers[rootid];\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n            if (!membersRoots[member]) {\n              membersRoots[member] = [];\n            }\n            membersRoots[member].push(rootid.toString());\n          }\n        }\n      }\n    }\n\n    /* loop minimal sub tree roots */\n    while (counter > 0) {\n      minimum = null;\n      for (famItemId in roots) {\n        if (roots.hasOwnProperty(famItemId)) {\n          if (!minimum || famCount[famItemId] < minimum) {\n            minimum = famCount[famItemId];\n            result = famItemId;\n          }\n        }\n      }\n      if (result != null) {\n        if (onItem != null) {\n          onItem.call(thisArg, result, _nodes[result]);\n        }\n        members = famMembers[result];\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n            if (!processed[member]) {\n              memberRoots = membersRoots[member];\n              for (index = 0, len = memberRoots.length; index < len; index += 1) {\n                memberRoot = memberRoots[index];\n                famCount[memberRoot] -= 1;\n              }\n              processed[member] = true;\n            }\n          }\n        }\n        delete roots[result];\n        counter -= 1;\n      }\n    }\n  }\n\n  /**\r\n   * Finds root node having largest number of nodes in its hierarchy\r\n   * \r\n   * @returns {string} Returns largest sub-hierarchy root node id.  \r\n   */\n  function findLargestRoot() {\n    var result = null,\n      maximum,\n      famMembers = {},\n      famCount = {},\n      isRoot;\n    maximum = null;\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              famMembers[parentid][itemid] = true;\n              famCount[parentid] += 1;\n            }\n          }\n        }\n        return SKIP;\n      });\n      if (isRoot && (!maximum || famCount[famItemId] > maximum)) {\n        maximum = famCount[famItemId];\n        result = famItemId;\n      }\n    });\n    return result;\n  }\n\n  /**\r\n   * Checks whether parents share a child node. Common child should belong only to the given collection\r\n   * of parents, if child's parents don't match given collection of parents, \r\n   * it is not considered as common child. \r\n   * @param {string[]} parents Collection of parents\r\n   * @returns {boolean} Returns true if common child exist. \r\n   */\n  function hasCommonChild(parents) {\n    var result = false,\n      parentsHash,\n      childrenHash,\n      parentsCount,\n      pIndex,\n      pLen,\n      parent,\n      child;\n\n    /* convert parents collection to hash, remove duplicates and ignore non-existing items */\n    parentsHash = {};\n    parentsCount = 0;\n    for (pIndex = 0, pLen = parents.length; pIndex < pLen; pIndex += 1) {\n      parent = parents[pIndex];\n      if (_nodes[parent] != null && !parentsHash[parent]) {\n        parentsHash[parent] = true;\n        parentsCount += 1;\n      }\n    }\n\n    /* collect number of parents referencing each child */\n    childrenHash = {};\n    for (parent in parentsHash) {\n      if (parentsHash.hasOwnProperty(parent)) {\n        _loop(this, _children, parent, function (child) {\n          if (!childrenHash[child]) {\n            childrenHash[child] = 1;\n          } else {\n            childrenHash[child] += 1;\n          }\n        }); //ignore jslint\n      }\n    }\n\n    /* find common child having number of references equal to number of existing parents */\n    for (child in childrenHash) {\n      if (childrenHash.hasOwnProperty(child)) {\n        if (_parents[child] != null && (_parentsCount[child] || 0) == childrenHash[child] && childrenHash[child] == parentsCount) {\n          result = true;\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  function _bundleNodes(fromItem, items, bundleItemId, bundleItem, backwardCol, backwardCount, forwardCol, forwardCount, checkChildren) {\n    var isValid = false,\n      index,\n      len,\n      child;\n    if (_nodes[fromItem] != null && forwardCol[fromItem] != null) {\n      /* validate target items */\n      isValid = true;\n      if (checkChildren) {\n        /* if we add new bundle all items should present */\n        for (index = 0, len = items.length; index < len; index += 1) {\n          child = items[index];\n          if (_nodes[child] == null || forwardCol[fromItem][child] == null) {\n            isValid = false;\n          }\n        }\n      }\n      if (isValid) {\n        if (bundleItem != null) {\n          /* add bundle node */\n          _nodes[bundleItemId] = bundleItem;\n        }\n        if (_nodes[bundleItemId] != null) {\n          /* update references */\n          if (!backwardCol[bundleItemId]) {\n            backwardCol[bundleItemId] = {};\n            backwardCount[bundleItemId] = 0;\n          }\n          if (!forwardCol[bundleItemId]) {\n            forwardCol[bundleItemId] = {};\n            forwardCount[bundleItemId] = 0;\n          }\n          if (!backwardCol[bundleItemId][fromItem]) {\n            backwardCol[bundleItemId][fromItem] = true;\n            backwardCount[bundleItemId] += 1;\n          }\n          if (!forwardCol[fromItem][bundleItemId]) {\n            forwardCol[fromItem][bundleItemId] = true;\n            forwardCount[fromItem] += 1;\n          }\n          for (index = 0, len = items.length; index < len; index += 1) {\n            child = items[index];\n            if (bundleItemId != child) {\n              if (forwardCol[fromItem][child] != null) {\n                delete forwardCol[fromItem][child];\n                forwardCount[fromItem] -= 1;\n              }\n              if (backwardCol[child][fromItem] != null) {\n                delete backwardCol[child][fromItem];\n                backwardCount[child] -= 1;\n              }\n              if (!backwardCol[child][bundleItemId]) {\n                backwardCol[child][bundleItemId] = true;\n                backwardCount[child] += 1;\n              }\n              if (!forwardCol[bundleItemId][child]) {\n                forwardCol[bundleItemId][child] = true;\n                forwardCount[bundleItemId] += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    return isValid;\n  }\n\n  /**\r\n   * Adds extra bundle item in between parent and its children. The parent node becomes parent of the bundle node,\r\n   * and bundle becomes parent of the children. Existing parent child relations are removed.\r\n   * @param {string} parent The parent node id\r\n   * @param {string[]} children The collection of child nodes ids\r\n   * @param {string} bundleItemId The bundle node id\r\n   * @param {object} bundleItem The bundle item context object\r\n   * @returns {boolean} Returns true if nodes bundle is valid\r\n   */\n  function bundleChildren(parent, children, bundleItemId, bundleItem) {\n    return _bundleNodes(parent, children, bundleItemId, bundleItem, _parents, _parentsCount, _children, _childrenCount, true);\n  }\n\n  /**\r\n   * Adds extra bundle item in between child node and its parents. The child node becomes child of the bundle node,\r\n   * and bundle becomes child of the parents. Existing parent child relations are removed.\r\n   * @param {string} child The parent node id\r\n   * @param {string[]} parents The collection of child nodes ids\r\n   * @param {string} bundleItemId The bundle node id\r\n   * @param {object} bundleItem The bundle item context object\r\n   * @returns {boolean} Returns true if the bundle is valid\r\n   */\n  function bundleParents(child, parents, bundleItemId, bundleItem) {\n    return _bundleNodes(child, parents, bundleItemId, bundleItem, _children, _childrenCount, _parents, _parentsCount, true);\n  }\n  function ReferenceItem() {\n    this.id = \"\";\n    this.key = \"\";\n    this.children = [];\n    this.childrenHash = {};\n    this.processed = false;\n  }\n  function ReferencesEdge(arg0) {\n    this.items = [];\n    this.weight = 0;\n    this.difference = 0;\n    if (arguments.length > 0) {\n      this.difference = arg0;\n    }\n  }\n  function _getReferencesGraph(currentItems) {\n    var result = Graph(),\n      item,\n      parents,\n      index1,\n      index2,\n      len,\n      from,\n      to,\n      difference,\n      processed = {};\n    for (item in currentItems) {\n      if (currentItems.hasOwnProperty(item)) {\n        _loop(this, _children, item, function (child) {\n          if (!processed.hasOwnProperty(child)) {\n            processed[child] = true;\n            /* create array of parents from hash references */\n            parents = [];\n            _loop(this, _parents, child, function (parent) {\n              parents.push(parent);\n            });\n\n            /* create all possible combinations between items */\n            for (index1 = 0, len = parents.length; index1 < len - 1; index1 += 1) {\n              from = parents[index1];\n              if (currentItems.hasOwnProperty(from)) {\n                for (index2 = index1 + 1; index2 < len; index2 += 1) {\n                  to = parents[index2];\n                  if (currentItems.hasOwnProperty(to)) {\n                    difference = Math.abs(currentItems[from].children.length - currentItems[to].children.length);\n                    var edge = result.edge(from, to);\n                    if (edge == null) {\n                      edge = new ReferencesEdge(difference);\n                      result.addEdge(from, to, edge);\n                    }\n                    edge.items.push(child);\n                    edge.weight += 1;\n                  }\n                }\n              }\n            }\n          }\n        }); //ignore jslint\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * Callback function for creation of new family nodes\r\n   * \r\n   * @callback onNewFamilyNodeCallback\r\n   * @returns {object} Returns new family node.\r\n   */\n\n  /**\r\n   * Optimizes references between family members.\r\n   * It creates bundles eliminating excessive intersections between nodes relations.\r\n   * \r\n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function to create a new family node context object. \r\n   */\n  function optimizeReferences(onNewBundleItem) {\n    var sharedItemsByKey = {},\n      sharedItemsById = {},\n      currentItems = {},\n      nodeid,\n      newReferenceItem,\n      nextItems,\n      graph,\n      node,\n      maximumTree,\n      counter = 0,\n      power = 10,\n      processed;\n    if (onNewBundleItem != null) {\n      for (nodeid in _nodes) {\n        counter += 1;\n        if (_nodes.hasOwnProperty(nodeid)) {\n          newReferenceItem = new ReferenceItem();\n          _loop(this, _children, nodeid, function (child) {\n            newReferenceItem.children.push(child);\n            newReferenceItem.childrenHash[child] = true;\n          }); //ignore jslint\n\n          newReferenceItem.children.sort();\n          newReferenceItem.id = nodeid;\n          newReferenceItem.key = newReferenceItem.children.join(\",\");\n          currentItems[newReferenceItem.id] = newReferenceItem;\n        }\n      }\n      power = Math.pow(10, counter.toString().length);\n      while (!isEmptyObject(currentItems)) {\n        nextItems = {};\n        processed = {};\n        graph = _getReferencesGraph(currentItems);\n        for (nodeid in currentItems) {\n          if (currentItems.hasOwnProperty(nodeid)) {\n            node = currentItems[nodeid];\n            if (!node.processed) {\n              maximumTree = graph.getSpanningTree(nodeid, function (edge) {\n                return edge.weight * power + power - edge.difference;\n              }); //ignore jslint\n\n              maximumTree.loopLevels(this, function (treeKey, treeKeyNode, levelid) {\n                currentItems[treeKey].processed = true;\n                maximumTree.loopChildren(this, treeKey, function (child, childNode) {\n                  var relation = graph.edge(treeKey, child),\n                    nextBundleItem = null,\n                    newItem,\n                    key,\n                    index,\n                    len,\n                    childrenToBind,\n                    isSharedItem,\n                    relationItem;\n                  currentItems[child].processed = true;\n                  if (relation.weight > 1) {\n                    relation.items.sort();\n                    key = relation.items.join(',');\n                    if (!sharedItemsByKey.hasOwnProperty(key)) {\n                      newItem = onNewBundleItem();\n                      _nodes[newItem.id] = newItem; /* add new bundle node to the family */\n\n                      nextBundleItem = new ReferenceItem();\n                      nextBundleItem.id = newItem.id;\n                      nextBundleItem.key = key;\n                      for (index = 0, len = relation.items.length; index < len; index += 1) {\n                        relationItem = relation.items[index];\n                        nextBundleItem.children.push(relationItem);\n                        nextBundleItem.childrenHash[relationItem] = true;\n                        processed[relationItem] = true;\n                      }\n                      nextBundleItem.children.sort();\n                      sharedItemsByKey[nextBundleItem.key] = nextBundleItem;\n                      sharedItemsById[nextBundleItem.id] = nextBundleItem;\n                      nextItems[nextBundleItem.id] = nextBundleItem;\n                      processed[nextBundleItem.id] = nextBundleItem;\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, treeKeyNode.replacementItem || treeKey, function (childid, child, level) {\n                        // if child item is bundle and it is not child of new bundle item\n                        if (!nextBundleItem.childrenHash[childid] && sharedItemsById[childid] != null) {\n                          isSharedItem = true;\n                          // if all children of that child are in the next bundle item we add it to that new bundle item as well\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1 /*BREAK*/;\n                            }\n                            if (!processed.hasOwnProperty(childid)) {\n                              return SKIP;\n                            }\n                          });\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n                        return 2 /*SKIP*/;\n                      });\n                      _bundleNodes(treeKeyNode.replacementItem || treeKey, childrenToBind, nextBundleItem.id, newItem, _parents, _parentsCount, _children, _childrenCount, false);\n                      if ((_childrenCount[treeKey] || 0) <= 1 && treeKeyNode.replacementItem == null) {\n                        treeKeyNode.replacementItem = nextBundleItem.id;\n                      }\n                    } else {\n                      nextBundleItem = sharedItemsByKey[key];\n                    }\n\n                    /* don't add shared item to itself on next items loop*/\n                    if (nextBundleItem.id != child) {\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, childNode.replacementItem || child, function (childid, child, level) {\n                        if (sharedItemsById[childid] != null && !nextBundleItem.childrenHash[childid]) {\n                          isSharedItem = true;\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1 /*BREAK*/;\n                            }\n                            if (!processed.hasOwnProperty(childid)) {\n                              return 2 /*SKIP*/;\n                            }\n                            return SKIP;\n                          });\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n                        return 2 /*SKIP*/;\n                      });\n                      _bundleNodes(childNode.replacementItem || child, childrenToBind, nextBundleItem.id, null, _parents, _parentsCount, _children, _childrenCount, false);\n\n                      /* if all items bundled then use bundle item for following transformations of references instead of original item if references graph*/\n                      if ((_childrenCount[child] || 0) <= 1 && childNode.replacementItem == null) {\n                        childNode.replacementItem = nextBundleItem.id;\n                      }\n                    }\n                  }\n                });\n              }); //ignore jslint\n            }\n          }\n        }\n        currentItems = nextItems;\n      }\n    }\n  }\n\n  /**\r\n   * Eliminates many to many relations in family structure\r\n   * It is needed to simplify layout process of the diagram\r\n   * \r\n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function for creation of new bundle node  \r\n   */\n  function eliminateManyToMany(onNewBundleItem) {\n    var parent, bundleNode;\n    for (parent in _children) {\n      if (_children.hasOwnProperty(parent)) {\n        if ((_childrenCount[parent] || 0) > 1) {\n          _loop(this, _children, parent, function (child) {\n            if ((_parentsCount[child] || 0) > 1) {\n              bundleNode = onNewBundleItem();\n              bundleChildren(parent, [child], bundleNode.id, bundleNode);\n            }\n          }); //ignore jslint\n        }\n      }\n    }\n  }\n  function FamilyEdge(parentid, childid) {\n    this.parentid = parentid;\n    this.childid = childid;\n    this.key = parentid + \",\" + childid;\n  }\n\n  /**\r\n   * Eliminates crossing parent child relations between nodes based of nodes order in treeLevels structure.\r\n   * @param {treeLevels} treeLevels Tree levels structure keeps orders of nodes level by level.\r\n   * @returns {family} Returns planar family structure. \r\n   */\n  function getPlanarFamily(treeLevels) {\n    var result = new Family(),\n      familyEdgeIndex,\n      familyEdgeLen,\n      familyEdgeKey;\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var sequence = new LinkedHashItems(),\n        crossings = {},\n        familyEdges = {},\n        firstBucket = [];\n      treeLevels.loopLevelItems(this, levelIndex, function (parentid, parentItem, position) {\n        loopChildren(this, parentid, function (childid, childItem) {\n          var childPosition = treeLevels.getItemPosition(childid);\n          var familyEdge = new FamilyEdge(parentid, childid);\n          familyEdges[familyEdge.key] = familyEdge;\n          var crossEdges = [];\n          if (sequence.isEmpty()) {\n            sequence.add(childPosition, [familyEdge]);\n          } else {\n            sequence.iterateBack(function (sequenceItem, itemPosition) {\n              if (itemPosition < childPosition) {\n                // add new sequence after itemPosition and exit\n                sequence.insertAfter(itemPosition, childPosition, [familyEdge]);\n                return true;\n              } else if (itemPosition == childPosition) {\n                // add new link to existing sequenceItem and exit\n                sequenceItem.push(familyEdge);\n                return true;\n              } else {\n                // merge links into output\n                for (var crossEdgesIndex = 0, crossEdgesLen = sequenceItem.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                  var crossEdge = sequenceItem[crossEdgesIndex];\n                  if (crossEdge.parentid != parentid) {\n                    crossEdges.push(crossEdge);\n                  }\n                }\n              }\n            });\n            if (sequence.startKey() > childPosition) {\n              sequence.unshift(childPosition, [familyEdge]);\n            }\n          }\n          crossings[familyEdge.key] = crossEdges;\n          for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n            crossings[crossEdges[crossEdgesIndex].key].push(familyEdge);\n          }\n          return SKIP;\n        });\n        if (countChildren(parentid) == 1) {\n          var childid = firstChild(parentid);\n          if (countParents(childid) == 1) {\n            var familyEdge = new FamilyEdge(parentid, childid);\n            firstBucket.push(familyEdge.key);\n          }\n        }\n      });\n\n      // distribute edges by number of crossings into buckets\n      var buckets = [],\n        crossEdges;\n      for (var familyEdgeKey in crossings) {\n        crossEdges = crossings[familyEdgeKey];\n        var len = crossEdges.length;\n        if (buckets[len] != null) {\n          buckets[len].push(familyEdgeKey);\n        } else {\n          buckets[len] = [familyEdgeKey];\n        }\n      }\n      var processed = {};\n\n      // leave single parent child relations\n      buckets.unshift(firstBucket);\n\n      // break relations having \n      for (var bucketIndex = 0, bucketsLen = buckets.length; bucketIndex < bucketsLen; bucketIndex += 1) {\n        var bucket = buckets[bucketIndex];\n        if (bucket != null) {\n          for (familyEdgeIndex = 0, familyEdgeLen = bucket.length; familyEdgeIndex < familyEdgeLen; familyEdgeIndex += 1) {\n            familyEdgeKey = bucket[familyEdgeIndex];\n            if (!processed.hasOwnProperty(familyEdgeKey)) {\n              processed[familyEdgeKey] = true;\n              var familyEdge = familyEdges[familyEdgeKey];\n              if (result.node(familyEdge.parentid) == null) {\n                result.add(null, familyEdge.parentid, {});\n              }\n              if (result.node(familyEdge.childid) == null) {\n                result.add([familyEdge.parentid], familyEdge.childid, {});\n              } else {\n                result.adopt([familyEdge.parentid], familyEdge.childid);\n              }\n              crossEdges = crossings[familyEdgeKey];\n              for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                processed[crossEdges[crossEdgesIndex].key] = true;\n              }\n            }\n          }\n        }\n      }\n    });\n    return result;\n  }\n  function Link(from, to, distance) {\n    this.from = from;\n    this.to = to;\n    this.distance = 0;\n  }\n\n  /**\r\n   * Eliminates direct relations between grand parent nodes.\r\n   * \r\n   * @returns {family} Returns family structure without direct grand parent relations. \r\n   */\n  function getFamilyWithoutGrandParentsRelations() {\n    var result = new Family();\n    var hash = {};\n    var links = [];\n    var level = 0;\n    for (var from in _parents) {\n      if (_parents.hasOwnProperty(from)) {\n        _loop(this, _parents, from, function (to) {\n          var fromHash = hash[from];\n          if (fromHash == null) {\n            fromHash = {};\n            hash[from] = fromHash;\n          }\n          if (!fromHash.hasOwnProperty(to)) {\n            var link = new Link(from, to, level);\n            links.push(link);\n            hash[from][to] = link;\n          }\n        }); //ignore jslint\n      }\n    }\n    while (links.length > 0) {\n      var newLinks = [];\n      level += 1;\n      for (var index = 0, len = links.length; index < len; index += 1) {\n        var link = links[index];\n        from = link.to;\n        if (_parents.hasOwnProperty(from)) {\n          _loop(this, _parents, from, function (to) {\n            var fromHash = hash[link.from];\n            if (fromHash == null) {\n              fromHash = {};\n              hash[link.from] = fromHash;\n            }\n            if (fromHash.hasOwnProperty(to)) {\n              fromHash[to].distance = level;\n            } else {\n              var newLink = new Link(from, to, level);\n              newLinks.push(newLink);\n              fromHash[to] = newLink;\n            }\n          });\n        }\n      }\n      links = newLinks;\n    }\n\n    // return only references to immidiate parents\n    loop(this, function (nodeid, node) {\n      var parents = [];\n      _loop(this, _parents, nodeid, function (to) {\n        if (hash[nodeid][to].distance === 0) {\n          parents.push(to);\n        }\n      });\n      result.add(parents, nodeid, node);\n    });\n    return result;\n  }\n\n  /**\r\n   * Returns number of children\r\n   * @param {string} parent The parent node id\r\n   * @returns {number} Number of children\r\n   */\n  function countChildren(parent) {\n    return _childrenCount[parent] || 0;\n  }\n\n  /**\r\n   * Returns number of parents\r\n   * @param {string} child The child node id\r\n   * @returns {number} Number of parents\r\n   */\n  function countParents(child) {\n    return _parentsCount[child] || 0;\n  }\n\n  /**\r\n   * First available child\r\n   * @param {string} parent The parent node id\r\n   * @returns {string} Returns first available child id or null.\r\n   */\n  function firstChild(parent) {\n    var result = null,\n      children = _children[parent] || {};\n    for (result in children) {\n      if (children.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n    return null;\n  }\n\n  /**\r\n   * First available parent\r\n   * @param {string} child The child node id\r\n   * @returns {string} Returns first available parent id or null.\r\n   */\n  function firstParent(child) {\n    var result = null,\n      parents = _parents[child] || {};\n    for (result in parents) {\n      if (parents.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n    return null;\n  }\n\n  /**\r\n   * Callback for iterating family node neighbours level by level\r\n   * \r\n   * @callback onFamilyItemNeighbourCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} levelIndex The neigbour node distance from the start node\r\n   * @returns {number} Returns true to skip further neighbous traversing.\r\n   */\n\n  /**\r\n   * Loops through the node neighbours of the family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid The node id to start traversing neighbour nodes\r\n   * @param {onFamilyItemNeighbourCallback} onItem A callback function to call for every neighbour node \r\n   */\n  function loopNeighbours(thisArg, itemid, onItem) {\n    var processed = {};\n    if (onItem != null) {\n      loopChildren(this, itemid, function (childid, child, childLevel) {\n        if (!processed.hasOwnProperty(childid)) {\n          processed[childid] = null;\n          if (onItem.call(thisArg, childid, child, 1)) {\n            processed[childid] = SKIP;\n          }\n          loopParents(this, childid, function (parentid, parent, parentLevel) {\n            if (!processed.hasOwnProperty(parentid)) {\n              processed[parentid] = null;\n              if (onItem.call(thisArg, parentid, parent, 2)) {\n                processed[parentid] = SKIP;\n              }\n            }\n            return processed[parentid];\n          });\n        }\n        return processed[childid];\n      });\n      loopParents(this, itemid, function (parentid, parent, parentLevel) {\n        if (!processed.hasOwnProperty(parentid)) {\n          processed[parentid] = null;\n          if (onItem.call(thisArg, parentid, parent, 1)) {\n            processed[parentid] = SKIP;\n          }\n          loopChildren(this, parentid, function (childid, child, childLevel) {\n            if (!processed.hasOwnProperty(childid)) {\n              processed[childid] = true;\n              if (onItem.call(thisArg, childid, child, 2)) {\n                processed[childid] = SKIP;\n              }\n            }\n            return processed[childid];\n          });\n        }\n        return processed[parentid];\n      });\n    }\n  }\n\n  /**\r\n   * Callback for getting default edge value\r\n   * \r\n   * @callback onFamilyEdgeCallback\r\n   * @param {string} from From node id\r\n   * @param {string} to The node\r\n   * @returns {object} Returns new edge object.\r\n   */\n\n  /**\r\n   * Creates graph structure out of the family structure.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyEdgeCallback} onEdge A callback function to call for every new edge added to the final graph\r\n   * @returns {graph} Returns graph structure of the family.\r\n   */\n  function getGraph(thisArg, onEdge) {\n    var result = Graph(),\n      from,\n      to;\n    for (from in _children) {\n      if (_children.hasOwnProperty(from)) {\n        _loop(this, _children, from, function (to) {\n          var edge = result.edge(from, to);\n          if (edge == null) {\n            if (onEdge == null) {\n              edge = new ReferencesEdge({});\n            } else {\n              edge = onEdge.call(thisArg, from, to);\n            }\n            result.addEdge(from, to, edge);\n          }\n        }); //ignore jslint\n      }\n    }\n    return result;\n  }\n  function GroupBy(parents, children) {\n    this.parents = parents;\n    this.children = children;\n    this.nodes = [];\n  }\n\n  /**\r\n   * Callback for grouping nodes having common single parent and child\r\n   * \r\n   * @callback onFamilyGroupCallback\r\n   * @param {string} parent The common parent node id\r\n   * @param {string} child The common child node id\r\n   * @param {Array.<Array.<FamilyNode>>} nodes Collection of collections of grouped items\r\n   */\n\n  /**\r\n   * Callback for getting group id for group of nodes\r\n   * \r\n   * @callback onFamilyGroupIdCallback\r\n   * @param {Array.<FamilyNode>} nodes Collection of nodes to get group id for.\r\n   * @returns {string} Returns group id or null. Null adds node to default group. Return -1 to disable grouping.\r\n  */\n\n  /**\r\n   * Creates graph structure out of the family structure.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyGroupCallback} onGroup A callback function to call for every new group of nodes found\r\n   * @param {onFamilyGroupIdCallback} onGroupId A callback function to call for every new group of nodes found\r\n   */\n  function groupBy(thisArg, size, onGroup, onGroupId) {\n    if (onGroup != null) {\n      var groups = {};\n      var processed = {};\n      for (var nodeid in _nodes) {\n        if (!processed.hasOwnProperty(nodeid)) {\n          processed[nodeid] = true;\n          if ((_parentsCount[nodeid] || 0) <= 1 && (_childrenCount[nodeid] || 0) <= 1) {\n            var nodes = [new FamilyNode(nodeid, _nodes[nodeid])];\n            loopChainParents(this, nodeid, parentId => {\n              processed[parentId] = true;\n              nodes.unshift({\n                id: parentId,\n                node: _nodes[parentId]\n              });\n            });\n            loopChainChildren(this, nodeid, childId => {\n              processed[childId] = true;\n              nodes.push(new FamilyNode(childId, _nodes[childId]));\n            });\n\n            /* find group id*/\n            var groupId = null;\n            if (onGroupId != null) {\n              groupId = onGroupId.call(thisArg, nodes);\n            }\n\n            /* add node or list of nodes to group */\n            if (groupId !== -1) {\n              var parents = [];\n              loopParents(this, nodes[0].id, function (parentId, parent, levelIndex) {\n                if (levelIndex == 0) {\n                  parents.push(parentId);\n                  return;\n                }\n                return BREAK;\n              });\n              parents.sort();\n              var children = [];\n              loopChildren(this, nodes[nodes.length - 1].id, function (childId, child, levelIndex) {\n                if (levelIndex == 0) {\n                  children.push(childId);\n                  return;\n                }\n                return BREAK;\n              });\n              children.sort();\n              var key = parents.join(\",\") + \" * \" + children.join(\",\");\n              if (groupId !== null) {\n                key += \" * \" + groupId;\n              }\n              if (!groups.hasOwnProperty(key)) {\n                groups[key] = new GroupBy(parents, children);\n              }\n              groups[key].nodes.push(nodes);\n            }\n          }\n        }\n      }\n      for (key in groups) {\n        if (groups.hasOwnProperty(key)) {\n          var group = groups[key];\n          if (group.nodes.length >= size) {\n            if (onGroup.call(thisArg, group.parents, group.children, group.nodes)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  function loopChainParents(thisArg, nodeid, onItem) {\n    while (_parentsCount[nodeid] === 1) {\n      var parentId = firstParent(nodeid);\n      if (_childrenCount[parentId] === 1) {\n        onItem.call(thisArg, parentId);\n        nodeid = parentId;\n      } else {\n        break;\n      }\n    }\n  }\n  function loopChainChildren(thisArg, nodeid, onItem) {\n    while (_childrenCount[nodeid] === 1) {\n      var childId = firstChild(nodeid);\n      if (_parentsCount[childId] === 1) {\n        onItem.call(thisArg, childId);\n        nodeid = childId;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\r\n   * Validates internal data structure consistency of the family.\r\n   * @param {object} info Optional validation object. \r\n   */\n  function validate(info) {\n    var parent, child;\n    function _count(items) {\n      var result = 0,\n        key;\n      if (items != null) {\n        for (key in items) {\n          if (items.hasOwnProperty(key)) {\n            result += 1;\n          }\n        }\n      }\n      return result;\n    }\n    loop(this, function (nodeId, node) {\n      _loop(this, _children, nodeId, function (child) {\n        if (!_parents.hasOwnProperty(child) || !_parents[child].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Child #\" + child + \" does not reference parent #\" + nodeId;\n          }\n          return false;\n        }\n      });\n      _loop(this, _parents, nodeId, function (parent) {\n        if (!_children.hasOwnProperty(parent) || !_children[parent].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Parent #\" + parent + \" does not reference child #\" + nodeId;\n          }\n          return false;\n        }\n      });\n    });\n    for (parent in _parents) {\n      if (_parents.hasOwnProperty(parent)) {\n        if ((_parentsCount[parent] || 0) != _count(_parents[parent])) {\n          if (info != null) {\n            info.message = \"Parents count for item #\" + parent + \" missmatch.\";\n          }\n          return false;\n        }\n        if (_parents.hasOwnProperty(parent) && !_nodes.hasOwnProperty(parent)) {\n          if (info != null) {\n            info.message = \"Orphant parents for item #\" + parent;\n          }\n          return false;\n        }\n      }\n    }\n    for (child in _children) {\n      if (_children.hasOwnProperty(child)) {\n        if ((_childrenCount[child] || 0) != _count(_children[child])) {\n          if (info != null) {\n            info.message = \"Children count for item \" + child + \" missmatch.\";\n          }\n          return false;\n        }\n        if (_children.hasOwnProperty(child) && !_nodes.hasOwnProperty(child)) {\n          if (info != null) {\n            info.message = \"Orphant children of item \" + child;\n          }\n          return false;\n        }\n      }\n    }\n    for (child in _roots) {\n      if (_roots.hasOwnProperty(child)) {\n        if ((_rootsCount[child] || 0) != _count(_roots[child])) {\n          if (info != null) {\n            info.message = \"Root children count for item @\" + child + \" missmatch.\";\n          }\n          return false;\n        }\n        _loop(this, _roots, child, function (nodeid) {\n          if (!_nodes.hasOwnProperty(nodeid)) {\n            if (info != null) {\n              info.message = \"Child #\" + nodeid + \"of root #\" + child + \" does not exists.\";\n            }\n            return false;\n          }\n        }); //ignore jslint\n      }\n    }\n    return true;\n  }\n\n  /**\r\n   * Checks if family structure has loops in references. \r\n   * @returns {boolean} Returns true if family structure contains loops in references.\r\n   */\n  function hasLoops() {\n    var tempFamily = clone();\n    loopTopo(this, function (itemid, item, levelIndex) {\n      tempFamily.removeNode(itemid);\n    });\n    return tempFamily.hasNodes();\n  }\n\n  /**\r\n   * Clones family structure.\r\n   * \r\n   * @returns {family} Returns copy of the family structure.\r\n   */\n  function clone() {\n    return Family({\n      roots: _roots,\n      rootsCount: _rootsCount,\n      children: _children,\n      childrenCount: _childrenCount,\n      parents: _parents,\n      parentsCount: _parentsCount,\n      nodes: _nodes\n    });\n  }\n  return {\n    /* family structure modification */\n    add: add,\n    adopt: adopt,\n    bundleChildren: bundleChildren,\n    bundleParents: bundleParents,\n    optimizeReferences: optimizeReferences,\n    eliminateManyToMany: eliminateManyToMany,\n    groupBy: groupBy,\n    getPlanarFamily: getPlanarFamily,\n    getFamilyWithoutGrandParentsRelations: getFamilyWithoutGrandParentsRelations,\n    getGraph: getGraph,\n    removeNode: removeNode,\n    removeRelation: removeRelation,\n    removeChildRelation: removeChildRelation,\n    /* referencing and looping */\n    node: node,\n    loop: loop,\n    loopLevels: loopLevels,\n    loopTopo: loopTopo,\n    loopTopoReversed: loopTopoReversed,\n    loopChildren: loopChildren,\n    loopParents: loopParents,\n    findLargestRoot: findLargestRoot,\n    loopRoots: loopRoots,\n    hasNodes: hasNodes,\n    hasCommonChild: hasCommonChild,\n    loopNeighbours: loopNeighbours,\n    countChildren: countChildren,\n    countParents: countParents,\n    firstParent: firstParent,\n    firstChild: firstChild,\n    /* force validation */\n    validate: validate,\n    hasLoops: hasLoops,\n    clone: clone,\n    // callback return codes\n    BREAK: BREAK,\n    // break loop immidiatly\n    SKIP: SKIP // skip loop of current node children \n  };\n}\n;","map":{"version":3,"names":["isObject","cloneObject","isEmptyObject","Graph","LinkedHashItems","FamilyNode","id","node","Family","source","_roots","_rootsCount","_children","_childrenCount","_parents","_parentsCount","_nodes","BREAK","SKIP","_init","roots","rootsCount","children","childrenCount","parents","parentsCount","nodes","_loop","thisArg","collection","itemid","onItem","item","items","hasOwnProperty","call","add","nodeid","index","len","parentid","processed","length","adopt","removeNode","_removeChildReference","childid","result","removeRelation","fromid","toid","removeChildRelation","hasNodes","loop","_loopItems","newItems","levelIndex","hasItems","newItemId","loopChildren","loopParents","_loopTopo","backwardCol","backwardCount","forwardCol","forwardCount","references","queue","newQueue","position","push","loopTopo","loopTopoReversed","loopLevels","parentAligned","topoSorted","topoSortedPositions","margin","levels","groups","hasGroups","newGroups","groupIndex","group","itemsAtLevel","minimumLevel","loopFunc","mIndex","mLen","mItem","mLevel","topoSortedItem","bestPosition","bestItem","bestLevel","bestIsParent","newMargin","hasNeighbours","Group","prototype","addItemToLevel","level","Math","min","topoSortedPosition","loopRoots","minimum","counter","famMembers","famCount","isRoot","famItemId","member","members","rootid","membersRoots","memberRoots","memberRoot","famItem","parent","toString","findLargestRoot","maximum","hasCommonChild","parentsHash","childrenHash","pIndex","pLen","child","_bundleNodes","fromItem","bundleItemId","bundleItem","checkChildren","isValid","bundleChildren","bundleParents","ReferenceItem","key","ReferencesEdge","arg0","weight","difference","arguments","_getReferencesGraph","currentItems","index1","index2","from","to","abs","edge","addEdge","optimizeReferences","onNewBundleItem","sharedItemsByKey","sharedItemsById","newReferenceItem","nextItems","graph","maximumTree","power","sort","join","pow","getSpanningTree","treeKey","treeKeyNode","levelid","childNode","relation","nextBundleItem","newItem","childrenToBind","isSharedItem","relationItem","slice","replacementItem","eliminateManyToMany","bundleNode","FamilyEdge","getPlanarFamily","treeLevels","familyEdgeIndex","familyEdgeLen","familyEdgeKey","treeLevel","sequence","crossings","familyEdges","firstBucket","loopLevelItems","parentItem","childItem","childPosition","getItemPosition","familyEdge","crossEdges","isEmpty","iterateBack","sequenceItem","itemPosition","insertAfter","crossEdgesIndex","crossEdgesLen","crossEdge","startKey","unshift","countChildren","firstChild","countParents","buckets","bucketIndex","bucketsLen","bucket","Link","distance","getFamilyWithoutGrandParentsRelations","hash","links","fromHash","link","newLinks","newLink","firstParent","loopNeighbours","childLevel","parentLevel","getGraph","onEdge","GroupBy","groupBy","size","onGroup","onGroupId","loopChainParents","parentId","loopChainChildren","childId","groupId","validate","info","_count","nodeId","message","hasLoops","tempFamily","clone"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/Family.js"],"sourcesContent":["import { isObject, cloneObject, isEmptyObject } from '../common';\r\nimport Graph from './Graph';\r\nimport LinkedHashItems from './LinkedHashItems';\r\n  /**\r\n  * Family node\r\n  * @class FamilyNode\r\n  * @property {string} id Id\r\n  * @property {object} node Node\r\n  */\r\n   function FamilyNode(id, node) {\r\n    this.id = id;\r\n    this.node = node;\r\n  }\r\n\r\n/**\r\n * Creates a family object\r\n * \r\n * @class Family\r\n * \r\n * @param {Family} [source=undefined] Reference to optional family object to clone properties from\r\n * \r\n * @returns {Family} Returns new instance of family structure\r\n */\r\nexport default function Family(source) {\r\n  var _roots = {},     // children hash of orphant parent id\r\n    _rootsCount = {},\r\n    _children = {},  // children hash by node id\r\n    _childrenCount = {},\r\n    _parents = {},   // parents hash by node id\r\n    _parentsCount = {},\r\n    _nodes = {},     // nodes by node id\r\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\r\n    BREAK = 1,\r\n    /** @constant\r\n      @type {number}\r\n      @default\r\n    */\r\n    SKIP = 2;\r\n\r\n  _init(source);\r\n\r\n  function _init(source) {\r\n    if (isObject(source)) {\r\n      _roots = cloneObject(source.roots, false);\r\n      _rootsCount = cloneObject(source.rootsCount, true);\r\n      _children = cloneObject(source.children, false);\r\n      _childrenCount = cloneObject(source.childrenCount, true);\r\n      _parents = cloneObject(source.parents, false);\r\n      _parentsCount = cloneObject(source.parentsCount, true);\r\n      _nodes = cloneObject(source.nodes, true);\r\n    }\r\n  }\r\n\r\n  function _loop(thisArg, collection, itemid, onItem) {\r\n    var item, items;\r\n    if (onItem != null) {\r\n      items = collection[itemid];\r\n      if (items != null) {\r\n        for (item in items) {\r\n          if (items.hasOwnProperty(item)) {\r\n            if (onItem.call(thisArg, item, items[item])) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds new family member\r\n   * @param {string[]} parents A collection of parents ids\r\n   * @param {string} nodeid An id of the new node\r\n   * @param {object} node A reference to the new node\r\n   */\r\n  function add(parents, nodeid, node) {\r\n    var index, len,\r\n      parentid,\r\n      processed = {};\r\n\r\n    if (!parents || parents.length === 0) {\r\n      parents = [null];\r\n    }\r\n\r\n    if (_nodes[nodeid] == null && node != null) {\r\n      _nodes[nodeid] = node;\r\n      for (index = 0, len = parents.length; index < len; index += 1) {\r\n        parentid = parents[index];\r\n\r\n\r\n        if (processed[parentid] == null && parentid != nodeid) {\r\n          processed[parentid] = true;\r\n          if (_nodes[parentid] != null) {\r\n            if (_parents[nodeid] == null) {\r\n              _parents[nodeid] = {};\r\n              _parentsCount[nodeid] = 0;\r\n            }\r\n            if (!_parents[nodeid][parentid]) {\r\n              _parents[nodeid][parentid] = true;\r\n              _parentsCount[nodeid] += 1;\r\n            }\r\n\r\n            if (_children[parentid] == null) {\r\n              _children[parentid] = {};\r\n              _childrenCount[parentid] = 0;\r\n            }\r\n            if (!_children[parentid][nodeid]) {\r\n              _children[parentid][nodeid] = true;\r\n              _childrenCount[parentid] += 1;\r\n            }\r\n          } else {\r\n            if (_roots[parentid] == null) {\r\n              _roots[parentid] = {};\r\n              _rootsCount[parentid] = 0;\r\n            }\r\n            if (!_roots[parentid][nodeid]) {\r\n              _roots[parentid][nodeid] = true;\r\n              _rootsCount[parentid] += 1;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (_roots[nodeid] != null) {\r\n        _children[nodeid] = _roots[nodeid];\r\n        _childrenCount[nodeid] = _rootsCount[nodeid];\r\n        delete _roots[nodeid];\r\n        delete _rootsCount[nodeid];\r\n        _loop(this, _children, nodeid, function (itemid) {\r\n          if (_parents[itemid] == null) {\r\n            _parents[itemid] = {};\r\n            _parentsCount[itemid] = 0;\r\n          }\r\n          if (!_parents[itemid][nodeid]) {\r\n            _parents[itemid][nodeid] = true;\r\n            _parentsCount[itemid] += 1;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns family node by id\r\n   * @param {string} nodeid The id of the node\r\n   * @returns {object|undefined} A reference to the node or undefined if id does not exists\r\n   */\r\n  function node(nodeid) {\r\n    return _nodes[nodeid];\r\n  }\r\n\r\n  /**\r\n   * Makes node to be a child of every parent in the collection of parents\r\n   * @param {string[]} parents A collection of parents ids\r\n   * @param {string} nodeid An id of the new node\r\n   */\r\n  function adopt(parents, nodeid) {\r\n    var index, len,\r\n      parentid;\r\n    if (_nodes[nodeid] != null) {\r\n      for (index = 0, len = parents.length; index < len; index += 1) {\r\n        parentid = parents[index];\r\n\r\n        if (_parents[nodeid] == null) {\r\n          _parents[nodeid] = {};\r\n          _parentsCount[nodeid] = 0;\r\n        }\r\n\r\n        if (parentid != nodeid && _nodes[parentid] != null) {\r\n          if (!_parents[nodeid][parentid]) {\r\n            _parents[nodeid][parentid] = true;\r\n            _parentsCount[nodeid] += 1;\r\n          }\r\n\r\n          if (_children[parentid] == null) {\r\n            _children[parentid] = {};\r\n            _childrenCount[parentid] = 0;\r\n          }\r\n          if (!_children[parentid][nodeid]) {\r\n            _children[parentid][nodeid] = true;\r\n            _childrenCount[parentid] += 1;\r\n          }\r\n        } else {\r\n          throw \"Item cannot be parent of itself and parent should exist in the structure!\";\r\n        }\r\n      }\r\n    } else {\r\n      throw \"Child should be in hierarchy!\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes node\r\n   * @param {string} nodeid The id of the node\r\n   */\r\n  function removeNode(nodeid) {\r\n    if (_nodes[nodeid] != null) {\r\n      _loop(this, _children, nodeid, function (itemid) {\r\n        delete _parents[itemid][nodeid];\r\n        _parentsCount[itemid] -= 1;\r\n\r\n        if (!_parentsCount[itemid]) {\r\n          delete _parents[itemid];\r\n          delete _parentsCount[itemid];\r\n\r\n          if (_roots[null] == null) {\r\n            _roots[null] = {};\r\n            _rootsCount[null] = 0;\r\n          }\r\n          if (!_roots[null][itemid]) {\r\n            _roots[null][itemid] = true;\r\n            _rootsCount[null] += 1;\r\n          }\r\n        }\r\n      });\r\n      _loop(this, _parents, nodeid, function (itemid) {\r\n        delete _children[itemid][nodeid];\r\n        _childrenCount[itemid] -= 1;\r\n        if (!_childrenCount[itemid]) {\r\n          delete _children[itemid];\r\n          delete _childrenCount[itemid];\r\n        }\r\n      });\r\n      if (_roots[null] != null && _roots[null][nodeid] != null) {\r\n        delete _roots[null][nodeid];\r\n        _rootsCount[null] -= 1;\r\n\r\n        if (!_rootsCount[null]) {\r\n          delete _roots[null];\r\n          delete _rootsCount[null];\r\n        }\r\n      }\r\n      delete _children[nodeid];\r\n      delete _childrenCount[nodeid];\r\n      delete _parents[nodeid];\r\n      delete _parentsCount[nodeid];\r\n      delete _nodes[nodeid];\r\n    }\r\n  }\r\n\r\n  function _removeChildReference(parentid, childid) {\r\n    var result = false;\r\n    if (_children[parentid] != null && _children[parentid][childid] != null) {\r\n      delete _children[parentid][childid];\r\n      _childrenCount[parentid] -= 1;\r\n\r\n      delete _parents[childid][parentid];\r\n      _parentsCount[childid] -= 1;\r\n\r\n      if (!_childrenCount[parentid]) {\r\n        delete _children[parentid];\r\n        delete _childrenCount[parentid];\r\n      }\r\n\r\n      if (!_parents[childid]) {\r\n        delete _parents[childid];\r\n        delete _parentsCount[childid];\r\n\r\n        if (_roots[null] == null) {\r\n          _roots[null] = {};\r\n          _rootsCount[null] = 0;\r\n        }\r\n        _roots[null][childid] = true;\r\n        _rootsCount[null] += 1;\r\n      }\r\n      result = true;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Removes first available parent child or child parent relation\r\n   * \r\n   * @param {string} fromid From node id\r\n   * @param {string} toid To node id\r\n   * @returns {true} If relation was broken\r\n   */\r\n  function removeRelation(fromid, toid) {\r\n    var result = false;\r\n    if (_nodes[fromid] != null && _nodes[toid] != null) {\r\n      result = _removeChildReference(fromid, toid) || _removeChildReference(toid, fromid);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Removes child relation\r\n   * \r\n   * @param {string} parentid The parent node id\r\n   * @param {string} childid The child node id\r\n   * @returns {true} If relation was broken\r\n   */\r\n  function removeChildRelation(parentid, childid) {\r\n    var result = false;\r\n    if (_nodes[parentid] != null && _nodes[childid] != null) {\r\n      result = _removeChildReference(parentid, childid);\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns true if structure has nodes.\r\n   * \r\n   * @returns {boolean} Returns true if family structure has nodes\r\n   */\r\n  function hasNodes() {\r\n    return !isEmptyObject(_nodes);\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating family nodes\r\n   * \r\n   * @callback onFamilyItemCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @returns {boolean} Returns true to break the loop\r\n   */\r\n\r\n  /**\r\n   * Loops through nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family node \r\n   */\r\n  function loop(thisArg, onItem) {\r\n    var item;\r\n    if (onItem != null) {\r\n      for (item in _nodes) {\r\n        if (_nodes.hasOwnProperty(item)) {\r\n          if (onItem.call(thisArg, item, _nodes[item])) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function _loopItems(thisArg, collection, items, onItem) { // onItem(itemid, item, levelIndex)\r\n    var newItems, itemid,\r\n      processed = {},\r\n      levelIndex = 0,\r\n      hasItems = true;\r\n\r\n\r\n    while (hasItems) {\r\n      newItems = {};\r\n      hasItems = false;\r\n\r\n      for (itemid in items) {\r\n        if (items.hasOwnProperty(itemid)) {\r\n          if (!processed[itemid]) {\r\n            processed[itemid] = true;\r\n\r\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\r\n              case 1/*BREAK*/:\r\n                newItems = {};\r\n                hasItems = false;\r\n                break;\r\n              case 2/*SKIP*/:\r\n                break;\r\n              default:\r\n                _loop(this, collection, itemid, function (newItemId) {\r\n                  if (!processed[newItemId]) {\r\n                    newItems[newItemId] = true;\r\n                    hasItems = true;\r\n                  }\r\n                }); //ignore jslint\r\n                break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      items = newItems;\r\n      levelIndex += 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating family nodes level by level\r\n   * \r\n   * @callback onFamilyItemWithLevelCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} levelIndex The node level index\r\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\r\n   */\r\n\r\n  /**\r\n   * Loops through child nodes of family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The node id to start children traversing\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every child node \r\n   */\r\n  function loopChildren(thisArg, nodeid, onItem) {\r\n    if (onItem != null) {\r\n      if (nodeid != null && _nodes[nodeid] != null && _children[nodeid] != null) {\r\n        _loopItems(thisArg, _children, _children[nodeid], onItem);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops through parent nodes of family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} nodeid The node id to start parents traversing\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every parent node \r\n   */\r\n  function loopParents(thisArg, nodeid, onItem) {\r\n    if (onItem != null) {\r\n      if (nodeid != null && _nodes[nodeid] != null && _parents[nodeid] != null) {\r\n        _loopItems(thisArg, _parents, _parents[nodeid], onItem);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _loopTopo(thisArg, backwardCol, backwardCount, forwardCol, forwardCount, onItem) { // onItem(itemid, item, position)\r\n    var index, len, nodeid, references,\r\n      queue, newQueue, position;\r\n\r\n    if (onItem != null) {\r\n      /* count parents for every node */\r\n      queue = [];\r\n      references = {};\r\n      for (nodeid in _nodes) {\r\n        if (_nodes.hasOwnProperty(nodeid)) {\r\n          references[nodeid] = (backwardCount[nodeid] || 0);\r\n\r\n          if (!references[nodeid]) {\r\n            queue.push(nodeid);\r\n          }\r\n        }\r\n      }\r\n\r\n      /* iterate queue and reduce reference counts via children */\r\n      position = 0;\r\n      while (queue.length > 0) {\r\n        newQueue = [];\r\n\r\n        for (index = 0, len = queue.length; index < len; index += 1) {\r\n          nodeid = queue[index];\r\n\r\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], position)) {\r\n            newQueue = [];\r\n            break;\r\n          }\r\n\r\n          position += 1;\r\n\r\n          _loop(this, forwardCol, nodeid, function (itemid) {\r\n            references[itemid] -= 1;\r\n            if (references[itemid] === 0) {\r\n              newQueue.push(itemid);\r\n            }\r\n          }); //ignore jslint\r\n        }\r\n        queue = newQueue;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating family nodes in topological sort order\r\n   * \r\n   * @callback onFamilyTopoCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} position The node position in the sequence\r\n   * @returns {boolean} Returns true to break the loop and exit.\r\n   */\r\n\r\n  /**\r\n   * Loops through topologically sorted nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \r\n   */\r\n  function loopTopo(thisArg, onItem) {\r\n    _loopTopo(thisArg, _parents, _parentsCount, _children, _childrenCount, onItem);\r\n  }\r\n\r\n  /**\r\n   * Loops through reversed order topologically sorted nodes of family structure\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \r\n   */\r\n  function loopTopoReversed(thisArg, onItem) {\r\n    _loopTopo(thisArg, _children, _childrenCount, _parents, _parentsCount, onItem);\r\n  }\r\n\r\n\r\n  /**\r\n   * Loops through nodes of family structure level by level. This function aligns nodes top or bottom.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {boolean} parentAligned True if nodes should be placed at the next level after their parents level,\r\n   * otherwise nodes placed at levels close to their children.\r\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every node \r\n   */\r\n  function loopLevels(thisArg, parentAligned, onItem) {\r\n    var topoSorted = [],\r\n      topoSortedPositions = {},\r\n      processed = {},\r\n      margin = [],\r\n      /* result items distribution by levels */\r\n      levels = {}, levelIndex,\r\n      groups = {}, hasGroups, newGroups, groupIndex, group,\r\n      itemsAtLevel, itemid,\r\n      minimumLevel = null,\r\n      loopFunc = parentAligned ? loopTopo : loopTopoReversed,\r\n      index, len,\r\n      mIndex, mLen, mItem, mLevel,\r\n      topoSortedItem,\r\n      bestPosition, bestItem, bestLevel, bestIsParent,\r\n      newMargin, hasNeighbours;\r\n\r\n    function Group() {\r\n      this.items = {};\r\n      this.minimumLevel = null;\r\n    }\r\n\r\n    Group.prototype.addItemToLevel = function (itemid, level) {\r\n      var items = this.items[level];\r\n      if (!items) {\r\n        items = [itemid];\r\n        this.items[level] = items;\r\n      } else {\r\n        items.push(itemid);\r\n      }\r\n      this.minimumLevel = this.minimumLevel == null ? level : Math.min(this.minimumLevel, level);\r\n    };\r\n\r\n    function addItemToLevel(itemid, index, level) {\r\n      var group = groups[index];\r\n      if (!group) {\r\n        group = new Group();\r\n        groups[index] = group;\r\n      }\r\n\r\n      group.addItemToLevel(itemid, level);\r\n\r\n      minimumLevel = minimumLevel == null ? level : Math.min(minimumLevel, level);\r\n\r\n      levels[itemid] = level;\r\n      processed[itemid] = true;\r\n    }\r\n\r\n\r\n    if (onItem != null) {\r\n      /* sort items topologically */\r\n      loopFunc(this, function (itemid, item, position) {\r\n        topoSorted.push(itemid);\r\n        topoSortedPositions[itemid] = position;\r\n      });\r\n\r\n      /* search for the first available non processed item in topological order */\r\n      for (index = 0, len = topoSorted.length; index < len; index += 1) {\r\n        topoSortedItem = topoSorted[index];\r\n        if (processed[topoSortedItem] == null) {\r\n          margin.push(topoSortedItem);\r\n\r\n          addItemToLevel(topoSortedItem, index, 0);\r\n\r\n          /* use regular graph breadth first search */\r\n          while (margin.length > 0) {\r\n            bestPosition = null;\r\n            bestItem = null;\r\n            bestLevel = null;\r\n            bestIsParent = !parentAligned;\r\n            newMargin = [];\r\n            for (mIndex = 0, mLen = margin.length; mIndex < mLen; mIndex += 1) {\r\n              mItem = margin[mIndex];\r\n              mLevel = levels[mItem];\r\n              hasNeighbours = false;\r\n\r\n              if (parentAligned) {\r\n                _loop(this, _parents, mItem, function (parentid) {\r\n                  var topoSortedPosition;\r\n                  if (!processed[parentid]) {\r\n                    hasNeighbours = true;\r\n                    topoSortedPosition = topoSortedPositions[parentid];\r\n                    if (bestPosition == null || !bestIsParent || bestPosition < topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel > mLevel - 1)) {\r\n                      bestPosition = topoSortedPosition;\r\n                      bestItem = parentid;\r\n                      bestLevel = mLevel - 1;\r\n                      bestIsParent = true;\r\n                    }\r\n                  }\r\n                }); //ignore jslint\r\n                _loop(this, _children, mItem, function (childid) {\r\n                  var topoSortedPosition;\r\n                  if (!processed[childid]) {\r\n                    hasNeighbours = true;\r\n                    topoSortedPosition = topoSortedPositions[childid];\r\n                    if (bestPosition == null || (!bestIsParent && (bestPosition > topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel < mLevel + 1)))) {\r\n                      bestPosition = topoSortedPosition;\r\n                      bestItem = childid;\r\n                      bestLevel = mLevel + 1;\r\n                      bestIsParent = false;\r\n                    }\r\n                  }\r\n                }); //ignore jslint\r\n              } else {\r\n                _loop(this, _children, mItem, function (childid) {\r\n                  var topoSortedPosition;\r\n                  if (!processed[childid]) {\r\n                    hasNeighbours = true;\r\n                    topoSortedPosition = topoSortedPositions[childid];\r\n                    if (bestPosition == null || bestIsParent || bestPosition < topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel < mLevel + 1)) {\r\n                      bestPosition = topoSortedPosition;\r\n                      bestItem = childid;\r\n                      bestLevel = mLevel + 1;\r\n                      bestIsParent = false;\r\n                    }\r\n                  }\r\n                }); //ignore jslint\r\n                _loop(this, _parents, mItem, function (parentid) {\r\n                  var topoSortedPosition;\r\n                  if (!processed[parentid]) {\r\n                    hasNeighbours = true;\r\n                    topoSortedPosition = topoSortedPositions[parentid];\r\n                    if (bestPosition == null || (bestIsParent && (bestPosition > topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel > mLevel - 1)))) {\r\n                      bestPosition = topoSortedPosition;\r\n                      bestItem = parentid;\r\n                      bestLevel = mLevel - 1;\r\n                      bestIsParent = true;\r\n                    }\r\n                  }\r\n                }); //ignore jslint\r\n              }\r\n              if (hasNeighbours) {\r\n                newMargin.push(mItem);\r\n              }\r\n            }\r\n            if (bestItem != null) {\r\n              newMargin.push(bestItem);\r\n\r\n              addItemToLevel(bestItem, index, bestLevel);\r\n            }\r\n            margin = newMargin;\r\n          }\r\n        }\r\n      }\r\n\r\n      hasGroups = true;\r\n      levelIndex = minimumLevel;\r\n      while (hasGroups) {\r\n        newGroups = {};\r\n        hasGroups = false;\r\n        for (groupIndex in groups) {\r\n          if (groups.hasOwnProperty(groupIndex)) {\r\n            group = groups[groupIndex];\r\n            itemsAtLevel = group.items[(group.minimumLevel - minimumLevel) + levelIndex];\r\n            if (itemsAtLevel != null) {\r\n              newGroups[groupIndex] = group;\r\n              hasGroups = true;\r\n\r\n              for (index = 0, len = itemsAtLevel.length; index < len; index += 1) {\r\n                itemid = itemsAtLevel[index];\r\n                if (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex - minimumLevel)) {\r\n                  hasGroups = false;\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        groups = newGroups;\r\n        levelIndex += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops root nodes of family structure. \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family root node \r\n   */\r\n  function loopRoots(thisArg, onItem) {\r\n    var result = null,\r\n      minimum, counter = 0,\r\n      famMembers = {},\r\n      famCount = {},\r\n      isRoot,\r\n      roots = {},\r\n      processed = {},\r\n      famItemId, member, members, rootid,\r\n      membersRoots, memberRoots, memberRoot,\r\n      index, len;\r\n\r\n    loopTopoReversed(this, function (famItemId, famItem, position) {\r\n      /* every node has at least itself in members */\r\n      if (!famMembers.hasOwnProperty(famItemId)) {\r\n        famMembers[famItemId] = {};\r\n        famCount[famItemId] = 0;\r\n      }\r\n      famMembers[famItemId][famItemId] = true;\r\n      famCount[famItemId] += 1;\r\n\r\n      isRoot = true;\r\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\r\n        var items, itemid;\r\n        isRoot = false;\r\n        if (!famMembers.hasOwnProperty(parentid)) {\r\n          famMembers[parentid] = {};\r\n          famCount[parentid] = 0;\r\n        }\r\n        /* push famItem members to parent members collection */\r\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\r\n          famMembers[parentid] = famMembers[famItemId];\r\n          famCount[parentid] = famCount[famItemId];\r\n        } else {\r\n          items = famMembers[famItemId];\r\n          for (itemid in items) {\r\n            if (items.hasOwnProperty(itemid)) {\r\n              if (!famMembers[parentid][itemid]) {\r\n                famMembers[parentid][itemid] = true;\r\n                famCount[parentid] += 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return SKIP;\r\n      });\r\n      if (isRoot) {\r\n        roots[famItemId] = true;\r\n        counter += 1;\r\n\r\n\r\n      }\r\n    });\r\n\r\n    /* create collection of roots per member */\r\n    membersRoots = {};\r\n    for (rootid in roots) {\r\n      if (roots.hasOwnProperty(rootid)) {\r\n        members = famMembers[rootid];\r\n\r\n        for (member in members) {\r\n          if (members.hasOwnProperty(member)) {\r\n\r\n            if (!membersRoots[member]) {\r\n              membersRoots[member] = [];\r\n            }\r\n            membersRoots[member].push(rootid.toString());\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* loop minimal sub tree roots */\r\n    while (counter > 0) {\r\n      minimum = null;\r\n      for (famItemId in roots) {\r\n        if (roots.hasOwnProperty(famItemId)) {\r\n          if (!minimum || famCount[famItemId] < minimum) {\r\n            minimum = famCount[famItemId];\r\n            result = famItemId;\r\n          }\r\n        }\r\n      }\r\n      if (result != null) {\r\n        if (onItem != null) {\r\n          onItem.call(thisArg, result, _nodes[result]);\r\n        }\r\n        members = famMembers[result];\r\n\r\n        for (member in members) {\r\n          if (members.hasOwnProperty(member)) {\r\n            if (!processed[member]) {\r\n              memberRoots = membersRoots[member];\r\n              for (index = 0, len = memberRoots.length; index < len; index += 1) {\r\n                memberRoot = memberRoots[index];\r\n                famCount[memberRoot] -= 1;\r\n              }\r\n              processed[member] = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        delete roots[result];\r\n        counter -= 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds root node having largest number of nodes in its hierarchy\r\n   * \r\n   * @returns {string} Returns largest sub-hierarchy root node id.  \r\n   */\r\n  function findLargestRoot() {\r\n    var result = null,\r\n      maximum,\r\n      famMembers = {},\r\n      famCount = {},\r\n      isRoot;\r\n\r\n    maximum = null;\r\n\r\n    loopTopoReversed(this, function (famItemId, famItem, position) {\r\n      /* every node has at least itself in members */\r\n      if (!famMembers.hasOwnProperty(famItemId)) {\r\n        famMembers[famItemId] = {};\r\n        famCount[famItemId] = 0;\r\n      }\r\n      famMembers[famItemId][famItemId] = true;\r\n      famCount[famItemId] += 1;\r\n\r\n      isRoot = true;\r\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\r\n        var items, itemid;\r\n        isRoot = false;\r\n        if (!famMembers.hasOwnProperty(parentid)) {\r\n          famMembers[parentid] = {};\r\n          famCount[parentid] = 0;\r\n        }\r\n        /* push famItem members to parent members collection */\r\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\r\n          famMembers[parentid] = famMembers[famItemId];\r\n          famCount[parentid] = famCount[famItemId];\r\n        } else {\r\n          items = famMembers[famItemId];\r\n          for (itemid in items) {\r\n            if (items.hasOwnProperty(itemid)) {\r\n              famMembers[parentid][itemid] = true;\r\n              famCount[parentid] += 1;\r\n            }\r\n          }\r\n        }\r\n        return SKIP;\r\n      });\r\n      if (isRoot && (!maximum || famCount[famItemId] > maximum)) {\r\n        maximum = famCount[famItemId];\r\n        result = famItemId;\r\n      }\r\n\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Checks whether parents share a child node. Common child should belong only to the given collection\r\n   * of parents, if child's parents don't match given collection of parents, \r\n   * it is not considered as common child. \r\n   * @param {string[]} parents Collection of parents\r\n   * @returns {boolean} Returns true if common child exist. \r\n   */\r\n  function hasCommonChild(parents) {\r\n    var result = false,\r\n      parentsHash, childrenHash,\r\n      parentsCount,\r\n      pIndex, pLen,\r\n      parent, child;\r\n\r\n    /* convert parents collection to hash, remove duplicates and ignore non-existing items */\r\n    parentsHash = {};\r\n    parentsCount = 0;\r\n    for (pIndex = 0, pLen = parents.length; pIndex < pLen; pIndex += 1) {\r\n      parent = parents[pIndex];\r\n      if (_nodes[parent] != null && !parentsHash[parent]) {\r\n        parentsHash[parent] = true;\r\n        parentsCount += 1;\r\n      }\r\n    }\r\n\r\n    /* collect number of parents referencing each child */\r\n    childrenHash = {};\r\n    for (parent in parentsHash) {\r\n      if (parentsHash.hasOwnProperty(parent)) {\r\n        _loop(this, _children, parent, function (child) {\r\n          if (!childrenHash[child]) {\r\n            childrenHash[child] = 1;\r\n          } else {\r\n            childrenHash[child] += 1;\r\n          }\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n\r\n    /* find common child having number of references equal to number of existing parents */\r\n    for (child in childrenHash) {\r\n      if (childrenHash.hasOwnProperty(child)) {\r\n        if (_parents[child] != null && (_parentsCount[child] || 0) == childrenHash[child] && childrenHash[child] == parentsCount) {\r\n          result = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function _bundleNodes(fromItem, items, bundleItemId, bundleItem, backwardCol, backwardCount, forwardCol, forwardCount, checkChildren) {\r\n    var isValid = false,\r\n      index, len,\r\n      child;\r\n\r\n    if (_nodes[fromItem] != null && forwardCol[fromItem] != null) {\r\n      /* validate target items */\r\n      isValid = true;\r\n      if (checkChildren) {\r\n        /* if we add new bundle all items should present */\r\n        for (index = 0, len = items.length; index < len; index += 1) {\r\n          child = items[index];\r\n          if (_nodes[child] == null || forwardCol[fromItem][child] == null) {\r\n            isValid = false;\r\n          }\r\n        }\r\n      }\r\n      if (isValid) {\r\n        if (bundleItem != null) {\r\n          /* add bundle node */\r\n          _nodes[bundleItemId] = bundleItem;\r\n        }\r\n\r\n        if (_nodes[bundleItemId] != null) {\r\n          /* update references */\r\n          if (!backwardCol[bundleItemId]) {\r\n            backwardCol[bundleItemId] = {};\r\n            backwardCount[bundleItemId] = 0;\r\n          }\r\n          if (!forwardCol[bundleItemId]) {\r\n            forwardCol[bundleItemId] = {};\r\n            forwardCount[bundleItemId] = 0;\r\n          }\r\n\r\n          if (!backwardCol[bundleItemId][fromItem]) {\r\n            backwardCol[bundleItemId][fromItem] = true;\r\n            backwardCount[bundleItemId] += 1;\r\n          }\r\n\r\n          if (!forwardCol[fromItem][bundleItemId]) {\r\n            forwardCol[fromItem][bundleItemId] = true;\r\n            forwardCount[fromItem] += 1;\r\n          }\r\n\r\n          for (index = 0, len = items.length; index < len; index += 1) {\r\n            child = items[index];\r\n\r\n            if (bundleItemId != child) {\r\n              if (forwardCol[fromItem][child] != null) {\r\n                delete forwardCol[fromItem][child];\r\n                forwardCount[fromItem] -= 1;\r\n              }\r\n\r\n              if (backwardCol[child][fromItem] != null) {\r\n                delete backwardCol[child][fromItem];\r\n                backwardCount[child] -= 1;\r\n              }\r\n\r\n              if (!backwardCol[child][bundleItemId]) {\r\n                backwardCol[child][bundleItemId] = true;\r\n                backwardCount[child] += 1;\r\n              }\r\n\r\n              if (!forwardCol[bundleItemId][child]) {\r\n                forwardCol[bundleItemId][child] = true;\r\n                forwardCount[bundleItemId] += 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return isValid;\r\n  }\r\n\r\n  /**\r\n   * Adds extra bundle item in between parent and its children. The parent node becomes parent of the bundle node,\r\n   * and bundle becomes parent of the children. Existing parent child relations are removed.\r\n   * @param {string} parent The parent node id\r\n   * @param {string[]} children The collection of child nodes ids\r\n   * @param {string} bundleItemId The bundle node id\r\n   * @param {object} bundleItem The bundle item context object\r\n   * @returns {boolean} Returns true if nodes bundle is valid\r\n   */\r\n  function bundleChildren(parent, children, bundleItemId, bundleItem) {\r\n    return _bundleNodes(parent, children, bundleItemId, bundleItem, _parents, _parentsCount, _children, _childrenCount, true);\r\n  }\r\n\r\n  /**\r\n   * Adds extra bundle item in between child node and its parents. The child node becomes child of the bundle node,\r\n   * and bundle becomes child of the parents. Existing parent child relations are removed.\r\n   * @param {string} child The parent node id\r\n   * @param {string[]} parents The collection of child nodes ids\r\n   * @param {string} bundleItemId The bundle node id\r\n   * @param {object} bundleItem The bundle item context object\r\n   * @returns {boolean} Returns true if the bundle is valid\r\n   */\r\n  function bundleParents(child, parents, bundleItemId, bundleItem) {\r\n    return _bundleNodes(child, parents, bundleItemId, bundleItem, _children, _childrenCount, _parents, _parentsCount, true);\r\n  }\r\n\r\n  function ReferenceItem() {\r\n    this.id = \"\";\r\n    this.key = \"\";\r\n    this.children = [];\r\n    this.childrenHash = {};\r\n    this.processed = false;\r\n  }\r\n\r\n  function ReferencesEdge(arg0) {\r\n    this.items = [];\r\n    this.weight = 0;\r\n    this.difference = 0;\r\n\r\n    if (arguments.length > 0) {\r\n      this.difference = arg0;\r\n    }\r\n  }\r\n\r\n  function _getReferencesGraph(currentItems) {\r\n    var result = Graph(),\r\n      item, parents,\r\n      index1, index2, len,\r\n      from, to, difference,\r\n      processed = {};\r\n\r\n    for (item in currentItems) {\r\n      if (currentItems.hasOwnProperty(item)) {\r\n\r\n        _loop(this, _children, item, function (child) {\r\n          if (!processed.hasOwnProperty(child)) {\r\n            processed[child] = true;\r\n            /* create array of parents from hash references */\r\n            parents = [];\r\n            _loop(this, _parents, child, function (parent) {\r\n              parents.push(parent);\r\n            });\r\n\r\n            /* create all possible combinations between items */\r\n            for (index1 = 0, len = parents.length; index1 < len - 1; index1 += 1) {\r\n              from = parents[index1];\r\n              if (currentItems.hasOwnProperty(from)) {\r\n\r\n                for (index2 = index1 + 1; index2 < len; index2 += 1) {\r\n                  to = parents[index2];\r\n                  if (currentItems.hasOwnProperty(to)) {\r\n                    difference = Math.abs(currentItems[from].children.length - currentItems[to].children.length);\r\n\r\n                    var edge = result.edge(from, to);\r\n                    if (edge == null) {\r\n                      edge = new ReferencesEdge(difference);\r\n                      result.addEdge(from, to, edge);\r\n                    }\r\n                    edge.items.push(child);\r\n                    edge.weight += 1;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Callback function for creation of new family nodes\r\n   * \r\n   * @callback onNewFamilyNodeCallback\r\n   * @returns {object} Returns new family node.\r\n   */\r\n\r\n  /**\r\n   * Optimizes references between family members.\r\n   * It creates bundles eliminating excessive intersections between nodes relations.\r\n   * \r\n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function to create a new family node context object. \r\n   */\r\n  function optimizeReferences(onNewBundleItem) {\r\n    var sharedItemsByKey = {},\r\n      sharedItemsById = {},\r\n      currentItems = {},\r\n      nodeid, newReferenceItem,\r\n      nextItems, graph, node,\r\n      maximumTree,\r\n      counter = 0,\r\n      power = 10,\r\n      processed;\r\n\r\n    if (onNewBundleItem != null) {\r\n      for (nodeid in _nodes) {\r\n        counter += 1;\r\n        if (_nodes.hasOwnProperty(nodeid)) {\r\n          newReferenceItem = new ReferenceItem();\r\n\r\n          _loop(this, _children, nodeid, function (child) {\r\n            newReferenceItem.children.push(child);\r\n            newReferenceItem.childrenHash[child] = true;\r\n          }); //ignore jslint\r\n\r\n          newReferenceItem.children.sort();\r\n          newReferenceItem.id = nodeid;\r\n          newReferenceItem.key = newReferenceItem.children.join(\",\");\r\n\r\n          currentItems[newReferenceItem.id] = newReferenceItem;\r\n        }\r\n      }\r\n\r\n      power = Math.pow(10, (counter).toString().length);\r\n\r\n      while (!isEmptyObject(currentItems)) {\r\n        nextItems = {};\r\n        processed = {};\r\n\r\n        graph = _getReferencesGraph(currentItems);\r\n\r\n        for (nodeid in currentItems) {\r\n          if (currentItems.hasOwnProperty(nodeid)) {\r\n            node = currentItems[nodeid];\r\n\r\n            if (!node.processed) {\r\n\r\n              maximumTree = graph.getSpanningTree(nodeid, function (edge) {\r\n                return edge.weight * power + power - edge.difference;\r\n              }); //ignore jslint\r\n\r\n              maximumTree.loopLevels(this, function (treeKey, treeKeyNode, levelid) {\r\n                currentItems[treeKey].processed = true;\r\n\r\n                maximumTree.loopChildren(this, treeKey, function (child, childNode) {\r\n                  var relation = graph.edge(treeKey, child),\r\n                    nextBundleItem = null, newItem,\r\n                    key, index, len,\r\n                    childrenToBind, isSharedItem,\r\n                    relationItem;\r\n\r\n                  currentItems[child].processed = true;\r\n\r\n                  if (relation.weight > 1) {\r\n                    relation.items.sort();\r\n                    key = relation.items.join(',');\r\n\r\n                    if (!sharedItemsByKey.hasOwnProperty(key)) {\r\n                      newItem = onNewBundleItem();\r\n                      _nodes[newItem.id] = newItem; /* add new bundle node to the family */\r\n\r\n                      nextBundleItem = new ReferenceItem();\r\n                      nextBundleItem.id = newItem.id;\r\n                      nextBundleItem.key = key;\r\n                      for (index = 0, len = relation.items.length; index < len; index += 1) {\r\n                        relationItem = relation.items[index];\r\n                        nextBundleItem.children.push(relationItem);\r\n                        nextBundleItem.childrenHash[relationItem] = true;\r\n                        processed[relationItem] = true;\r\n                      }\r\n                      nextBundleItem.children.sort();\r\n\r\n                      sharedItemsByKey[nextBundleItem.key] = nextBundleItem;\r\n                      sharedItemsById[nextBundleItem.id] = nextBundleItem;\r\n                      nextItems[nextBundleItem.id] = nextBundleItem;\r\n                      processed[nextBundleItem.id] = nextBundleItem;\r\n\r\n                      childrenToBind = nextBundleItem.children.slice(0);\r\n                      loopChildren(this, treeKeyNode.replacementItem || treeKey, function (childid, child, level) {\r\n                        // if child item is bundle and it is not child of new bundle item\r\n                        if (!nextBundleItem.childrenHash[childid] && sharedItemsById[childid] != null) {\r\n                          isSharedItem = true;\r\n                          // if all children of that child are in the next bundle item we add it to that new bundle item as well\r\n                          loopChildren(this, childid, function (childid, child, level) {\r\n                            if (!nextBundleItem.childrenHash[childid]) {\r\n                              isSharedItem = false;\r\n                              return 1/*BREAK*/;\r\n                            }\r\n                            if (!processed.hasOwnProperty(childid)) {\r\n                              return SKIP;\r\n                            }\r\n                          });\r\n                          if (isSharedItem) {\r\n                            childrenToBind.push(childid);\r\n                          }\r\n                        }\r\n                        return 2/*SKIP*/;\r\n                      });\r\n\r\n                      _bundleNodes(treeKeyNode.replacementItem || treeKey, childrenToBind, nextBundleItem.id, newItem, _parents, _parentsCount, _children, _childrenCount, false);\r\n\r\n                      if ((_childrenCount[treeKey] || 0) <= 1 && treeKeyNode.replacementItem == null) {\r\n                        treeKeyNode.replacementItem = nextBundleItem.id;\r\n                      }\r\n                    } else {\r\n                      nextBundleItem = sharedItemsByKey[key];\r\n                    }\r\n\r\n                    /* don't add shared item to itself on next items loop*/\r\n                    if (nextBundleItem.id != child) {\r\n\r\n                      childrenToBind = nextBundleItem.children.slice(0);\r\n                      loopChildren(this, childNode.replacementItem || child, function (childid, child, level) {\r\n                        if (sharedItemsById[childid] != null && !nextBundleItem.childrenHash[childid]) {\r\n\r\n                          isSharedItem = true;\r\n                          loopChildren(this, childid, function (childid, child, level) {\r\n                            if (!nextBundleItem.childrenHash[childid]) {\r\n                              isSharedItem = false;\r\n                              return 1/*BREAK*/;\r\n                            }\r\n                            if (!processed.hasOwnProperty(childid)) {\r\n                              return 2/*SKIP*/;\r\n                            }\r\n                            return SKIP;\r\n                          });\r\n                          if (isSharedItem) {\r\n                            childrenToBind.push(childid);\r\n                          }\r\n                        }\r\n                        return 2/*SKIP*/;\r\n                      });\r\n\r\n\r\n                      _bundleNodes(childNode.replacementItem || child, childrenToBind, nextBundleItem.id, null, _parents, _parentsCount, _children, _childrenCount, false);\r\n\r\n                      /* if all items bundled then use bundle item for following transformations of references instead of original item if references graph*/\r\n                      if ((_childrenCount[child] || 0) <= 1 && childNode.replacementItem == null) {\r\n                        childNode.replacementItem = nextBundleItem.id;\r\n                      }\r\n                    }\r\n                  }\r\n                });\r\n              }); //ignore jslint\r\n            }\r\n          }\r\n        }\r\n        currentItems = nextItems;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Eliminates many to many relations in family structure\r\n   * It is needed to simplify layout process of the diagram\r\n   * \r\n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function for creation of new bundle node  \r\n   */\r\n  function eliminateManyToMany(onNewBundleItem) {\r\n    var parent, bundleNode;\r\n\r\n    for (parent in _children) {\r\n      if (_children.hasOwnProperty(parent)) {\r\n\r\n        if ((_childrenCount[parent] || 0) > 1) {\r\n          _loop(this, _children, parent, function (child) {\r\n            if ((_parentsCount[child] || 0) > 1) {\r\n              bundleNode = onNewBundleItem();\r\n              bundleChildren(parent, [child], bundleNode.id, bundleNode);\r\n            }\r\n          }); //ignore jslint\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function FamilyEdge(parentid, childid) {\r\n    this.parentid = parentid;\r\n    this.childid = childid;\r\n    this.key = parentid + \",\" + childid;\r\n  }\r\n\r\n  /**\r\n   * Eliminates crossing parent child relations between nodes based of nodes order in treeLevels structure.\r\n   * @param {treeLevels} treeLevels Tree levels structure keeps orders of nodes level by level.\r\n   * @returns {family} Returns planar family structure. \r\n   */\r\n  function getPlanarFamily(treeLevels) {\r\n    var result = new Family(),\r\n      familyEdgeIndex, familyEdgeLen,\r\n      familyEdgeKey;\r\n\r\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\r\n      var sequence = new LinkedHashItems(),\r\n        crossings = {},\r\n        familyEdges = {},\r\n        firstBucket = [];\r\n\r\n      treeLevels.loopLevelItems(this, levelIndex, function (parentid, parentItem, position) {\r\n        loopChildren(this, parentid, function (childid, childItem) {\r\n          var childPosition = treeLevels.getItemPosition(childid);\r\n          var familyEdge = new FamilyEdge(parentid, childid);\r\n\r\n          familyEdges[familyEdge.key] = familyEdge;\r\n\r\n          var crossEdges = [];\r\n          if (sequence.isEmpty()) {\r\n            sequence.add(childPosition, [familyEdge]);\r\n          } else {\r\n            sequence.iterateBack(function (sequenceItem, itemPosition) {\r\n              if (itemPosition < childPosition) {\r\n                // add new sequence after itemPosition and exit\r\n                sequence.insertAfter(itemPosition, childPosition, [familyEdge]);\r\n                return true;\r\n              } else if (itemPosition == childPosition) {\r\n                // add new link to existing sequenceItem and exit\r\n                sequenceItem.push(familyEdge);\r\n                return true;\r\n              } else {\r\n                // merge links into output\r\n                for (var crossEdgesIndex = 0, crossEdgesLen = sequenceItem.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\r\n                  var crossEdge = sequenceItem[crossEdgesIndex];\r\n                  if (crossEdge.parentid != parentid) {\r\n                    crossEdges.push(crossEdge);\r\n                  }\r\n                }\r\n              }\r\n            });\r\n            if (sequence.startKey() > childPosition) {\r\n              sequence.unshift(childPosition, [familyEdge]);\r\n            }\r\n          }\r\n\r\n          crossings[familyEdge.key] = crossEdges;\r\n          for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\r\n            crossings[crossEdges[crossEdgesIndex].key].push(familyEdge);\r\n          }\r\n\r\n          return SKIP;\r\n        });\r\n\r\n        if (countChildren(parentid) == 1) {\r\n          var childid = firstChild(parentid);\r\n          if (countParents(childid) == 1) {\r\n            var familyEdge = new FamilyEdge(parentid, childid);\r\n            firstBucket.push(familyEdge.key);\r\n          }\r\n        }\r\n      });\r\n\r\n      // distribute edges by number of crossings into buckets\r\n      var buckets = [],\r\n        crossEdges;\r\n      for (var familyEdgeKey in crossings) {\r\n        crossEdges = crossings[familyEdgeKey];\r\n        var len = crossEdges.length;\r\n        if (buckets[len] != null) {\r\n          buckets[len].push(familyEdgeKey);\r\n        } else {\r\n          buckets[len] = [familyEdgeKey];\r\n        }\r\n      }\r\n\r\n      var processed = {};\r\n\r\n      // leave single parent child relations\r\n      buckets.unshift(firstBucket);\r\n\r\n      // break relations having \r\n      for (var bucketIndex = 0, bucketsLen = buckets.length; bucketIndex < bucketsLen; bucketIndex += 1) {\r\n        var bucket = buckets[bucketIndex];\r\n        if (bucket != null) {\r\n          for (familyEdgeIndex = 0, familyEdgeLen = bucket.length; familyEdgeIndex < familyEdgeLen; familyEdgeIndex += 1) {\r\n            familyEdgeKey = bucket[familyEdgeIndex];\r\n            if (!processed.hasOwnProperty(familyEdgeKey)) {\r\n              processed[familyEdgeKey] = true;\r\n\r\n              var familyEdge = familyEdges[familyEdgeKey];\r\n\r\n              if (result.node(familyEdge.parentid) == null) {\r\n                result.add(null, familyEdge.parentid, {});\r\n              }\r\n              if (result.node(familyEdge.childid) == null) {\r\n                result.add([familyEdge.parentid], familyEdge.childid, {});\r\n              } else {\r\n                result.adopt([familyEdge.parentid], familyEdge.childid);\r\n              }\r\n\r\n              crossEdges = crossings[familyEdgeKey];\r\n              for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\r\n                processed[crossEdges[crossEdgesIndex].key] = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  function Link(from, to, distance) {\r\n    this.from = from;\r\n    this.to = to;\r\n    this.distance = 0;\r\n  }\r\n\r\n  /**\r\n   * Eliminates direct relations between grand parent nodes.\r\n   * \r\n   * @returns {family} Returns family structure without direct grand parent relations. \r\n   */\r\n  function getFamilyWithoutGrandParentsRelations() {\r\n    var result = new Family();\r\n\r\n    var hash = {};\r\n    var links = [];\r\n    var level = 0;\r\n    for (var from in _parents) {\r\n      if (_parents.hasOwnProperty(from)) {\r\n        _loop(this, _parents, from, function (to) {\r\n          var fromHash = hash[from];\r\n          if (fromHash == null) {\r\n            fromHash = {};\r\n            hash[from] = fromHash;\r\n          }\r\n          if (!fromHash.hasOwnProperty(to)) {\r\n            var link = new Link(from, to, level);\r\n            links.push(link);\r\n            hash[from][to] = link;\r\n          }\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n\r\n    while (links.length > 0) {\r\n      var newLinks = [];\r\n      level += 1;\r\n      for (var index = 0, len = links.length; index < len; index += 1) {\r\n        var link = links[index];\r\n        from = link.to;\r\n        if (_parents.hasOwnProperty(from)) {\r\n          _loop(this, _parents, from, function (to) {\r\n            var fromHash = hash[link.from];\r\n            if (fromHash == null) {\r\n              fromHash = {};\r\n              hash[link.from] = fromHash;\r\n            }\r\n            if (fromHash.hasOwnProperty(to)) {\r\n              fromHash[to].distance = level;\r\n            } else {\r\n              var newLink = new Link(from, to, level);\r\n              newLinks.push(newLink);\r\n              fromHash[to] = newLink;\r\n            }\r\n          });\r\n        }\r\n      }\r\n      links = newLinks;\r\n    }\r\n\r\n    // return only references to immidiate parents\r\n    loop(this, function (nodeid, node) {\r\n      var parents = [];\r\n      _loop(this, _parents, nodeid, function (to) {\r\n        if (hash[nodeid][to].distance === 0) {\r\n          parents.push(to);\r\n        }\r\n      });\r\n      result.add(parents, nodeid, node);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns number of children\r\n   * @param {string} parent The parent node id\r\n   * @returns {number} Number of children\r\n   */\r\n  function countChildren(parent) {\r\n    return _childrenCount[parent] || 0;\r\n  }\r\n\r\n  /**\r\n   * Returns number of parents\r\n   * @param {string} child The child node id\r\n   * @returns {number} Number of parents\r\n   */\r\n  function countParents(child) {\r\n    return _parentsCount[child] || 0;\r\n  }\r\n\r\n  /**\r\n   * First available child\r\n   * @param {string} parent The parent node id\r\n   * @returns {string} Returns first available child id or null.\r\n   */\r\n  function firstChild(parent) {\r\n    var result = null,\r\n      children = _children[parent] || {};\r\n    for (result in children) {\r\n      if (children.hasOwnProperty(result)) {\r\n        return result; //ignore jslint\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * First available parent\r\n   * @param {string} child The child node id\r\n   * @returns {string} Returns first available parent id or null.\r\n   */\r\n  function firstParent(child) {\r\n    var result = null,\r\n      parents = _parents[child] || {};\r\n    for (result in parents) {\r\n      if (parents.hasOwnProperty(result)) {\r\n        return result; //ignore jslint\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating family node neighbours level by level\r\n   * \r\n   * @callback onFamilyItemNeighbourCallback\r\n   * @param {string} itemid The node id\r\n   * @param {object} item The node\r\n   * @param {number} levelIndex The neigbour node distance from the start node\r\n   * @returns {number} Returns true to skip further neighbous traversing.\r\n   */\r\n\r\n  /**\r\n   * Loops through the node neighbours of the family structure level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid The node id to start traversing neighbour nodes\r\n   * @param {onFamilyItemNeighbourCallback} onItem A callback function to call for every neighbour node \r\n   */\r\n  function loopNeighbours(thisArg, itemid, onItem) {\r\n    var processed = {};\r\n\r\n    if (onItem != null) {\r\n      loopChildren(this, itemid, function (childid, child, childLevel) {\r\n        if (!processed.hasOwnProperty(childid)) {\r\n          processed[childid] = null;\r\n\r\n          if (onItem.call(thisArg, childid, child, 1)) {\r\n            processed[childid] = SKIP;\r\n          }\r\n\r\n          loopParents(this, childid, function (parentid, parent, parentLevel) {\r\n            if (!processed.hasOwnProperty(parentid)) {\r\n              processed[parentid] = null;\r\n\r\n              if (onItem.call(thisArg, parentid, parent, 2)) {\r\n                processed[parentid] = SKIP;\r\n              }\r\n            }\r\n            return processed[parentid];\r\n          });\r\n        }\r\n        return processed[childid];\r\n      });\r\n\r\n      loopParents(this, itemid, function (parentid, parent, parentLevel) {\r\n        if (!processed.hasOwnProperty(parentid)) {\r\n          processed[parentid] = null;\r\n\r\n          if (onItem.call(thisArg, parentid, parent, 1)) {\r\n            processed[parentid] = SKIP;\r\n          }\r\n\r\n          loopChildren(this, parentid, function (childid, child, childLevel) {\r\n            if (!processed.hasOwnProperty(childid)) {\r\n              processed[childid] = true;\r\n\r\n              if (onItem.call(thisArg, childid, child, 2)) {\r\n                processed[childid] = SKIP;\r\n              }\r\n            }\r\n            return processed[childid];\r\n          });\r\n\r\n        }\r\n        return processed[parentid];\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for getting default edge value\r\n   * \r\n   * @callback onFamilyEdgeCallback\r\n   * @param {string} from From node id\r\n   * @param {string} to The node\r\n   * @returns {object} Returns new edge object.\r\n   */\r\n\r\n  /**\r\n   * Creates graph structure out of the family structure.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyEdgeCallback} onEdge A callback function to call for every new edge added to the final graph\r\n   * @returns {graph} Returns graph structure of the family.\r\n   */\r\n  function getGraph(thisArg, onEdge) {\r\n    var result = Graph(),\r\n      from, to;\r\n\r\n    for (from in _children) {\r\n      if (_children.hasOwnProperty(from)) {\r\n        _loop(this, _children, from, function (to) {\r\n          var edge = result.edge(from, to);\r\n          if (edge == null) {\r\n            if (onEdge == null) {\r\n              edge = new ReferencesEdge({});\r\n            } else {\r\n              edge = onEdge.call(thisArg, from, to);\r\n            }\r\n            result.addEdge(from, to, edge);\r\n          }\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n\r\n\r\n  function GroupBy(parents, children) {\r\n    this.parents = parents;\r\n    this.children = children;\r\n    this.nodes = [];\r\n  }\r\n\r\n  /**\r\n   * Callback for grouping nodes having common single parent and child\r\n   * \r\n   * @callback onFamilyGroupCallback\r\n   * @param {string} parent The common parent node id\r\n   * @param {string} child The common child node id\r\n   * @param {Array.<Array.<FamilyNode>>} nodes Collection of collections of grouped items\r\n   */\r\n\r\n  /**\r\n   * Callback for getting group id for group of nodes\r\n   * \r\n   * @callback onFamilyGroupIdCallback\r\n   * @param {Array.<FamilyNode>} nodes Collection of nodes to get group id for.\r\n   * @returns {string} Returns group id or null. Null adds node to default group. Return -1 to disable grouping.\r\n  */\r\n\r\n  /**\r\n   * Creates graph structure out of the family structure.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onFamilyGroupCallback} onGroup A callback function to call for every new group of nodes found\r\n   * @param {onFamilyGroupIdCallback} onGroupId A callback function to call for every new group of nodes found\r\n   */\r\n  function groupBy(thisArg, size, onGroup, onGroupId) {\r\n    if (onGroup != null) {\r\n      var groups = {};\r\n      var processed = {};\r\n      for (var nodeid in _nodes) {\r\n        if(!processed.hasOwnProperty(nodeid) ) {\r\n          processed[nodeid] = true;\r\n          if ((_parentsCount[nodeid] || 0) <= 1 && (_childrenCount[nodeid] || 0) <= 1) {\r\n            var nodes = [new FamilyNode(nodeid, _nodes[nodeid])];\r\n            loopChainParents(this, nodeid, (parentId) => {\r\n              processed[parentId] = true;\r\n              nodes.unshift({id: parentId, node: _nodes[parentId]});\r\n            });\r\n            loopChainChildren(this, nodeid, (childId) => {\r\n              processed[childId] = true;\r\n              nodes.push(new FamilyNode(childId, _nodes[childId]));\r\n            });\r\n\r\n            /* find group id*/\r\n            var groupId = null;\r\n            if(onGroupId != null) {\r\n              groupId = onGroupId.call(thisArg, nodes);\r\n            }\r\n            \r\n            /* add node or list of nodes to group */\r\n            if(groupId !== -1) {\r\n\r\n              var parents = [];\r\n              loopParents(this, nodes[0].id, function(parentId, parent, levelIndex) {\r\n                if(levelIndex == 0) {\r\n                  parents.push(parentId);\r\n                  return;\r\n                }\r\n                return BREAK;\r\n              });\r\n              parents.sort();\r\n\r\n              var children = [];\r\n              loopChildren(this, nodes[nodes.length-1].id, function(childId, child, levelIndex) {\r\n                if(levelIndex == 0) {\r\n                  children.push(childId);\r\n                  return;\r\n                }\r\n                return BREAK;\r\n              });\r\n              children.sort();\r\n\r\n              var key = parents.join(\",\") + \" * \" + children.join(\",\");\r\n\r\n              if(groupId !== null) {\r\n                key += \" * \" + groupId;\r\n              }\r\n              if (!groups.hasOwnProperty(key)) {\r\n                groups[key] = new GroupBy(parents, children);\r\n              }\r\n              groups[key].nodes.push(nodes);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      for (key in groups) {\r\n        if (groups.hasOwnProperty(key)) {\r\n          var group = groups[key];\r\n          if (group.nodes.length >= size) {\r\n            if (onGroup.call(thisArg, group.parents, group.children, group.nodes)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function loopChainParents(thisArg, nodeid, onItem) {\r\n    while(_parentsCount[nodeid] === 1) {\r\n      var parentId = firstParent(nodeid);\r\n      if(_childrenCount[parentId] === 1) {\r\n        onItem.call(thisArg, parentId);\r\n        nodeid = parentId;\r\n      } else {\r\n        break;\r\n      }      \r\n    }\r\n  }\r\n\r\n  function loopChainChildren(thisArg, nodeid, onItem) {\r\n    while(_childrenCount[nodeid] === 1) {\r\n      var childId = firstChild(nodeid);\r\n      if(_parentsCount[childId] === 1) {\r\n        onItem.call(thisArg, childId);\r\n        nodeid = childId;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates internal data structure consistency of the family.\r\n   * @param {object} info Optional validation object. \r\n   */\r\n  function validate(info) {\r\n    var parent, child;\r\n\r\n    function _count(items) {\r\n      var result = 0, key;\r\n      if (items != null) {\r\n        for (key in items) {\r\n          if (items.hasOwnProperty(key)) {\r\n            result += 1;\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    loop(this, function (nodeId, node) {\r\n      _loop(this, _children, nodeId, function (child) {\r\n        if (!_parents.hasOwnProperty(child) || !_parents[child].hasOwnProperty(nodeId)) {\r\n          if (info != null) {\r\n            info.message = \"Child #\" + child + \" does not reference parent #\" + nodeId;\r\n          }\r\n          return false;\r\n        }\r\n      });\r\n      _loop(this, _parents, nodeId, function (parent) {\r\n        if (!_children.hasOwnProperty(parent) || !_children[parent].hasOwnProperty(nodeId)) {\r\n          if (info != null) {\r\n            info.message = \"Parent #\" + parent + \" does not reference child #\" + nodeId;\r\n          }\r\n          return false;\r\n        }\r\n      });\r\n    });\r\n\r\n    for (parent in _parents) {\r\n      if (_parents.hasOwnProperty(parent)) {\r\n        if ((_parentsCount[parent] || 0) != _count(_parents[parent])) {\r\n          if (info != null) {\r\n            info.message = \"Parents count for item #\" + parent + \" missmatch.\";\r\n          }\r\n          return false;\r\n        }\r\n        if (_parents.hasOwnProperty(parent) && !_nodes.hasOwnProperty(parent)) {\r\n          if (info != null) {\r\n            info.message = \"Orphant parents for item #\" + parent;\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (child in _children) {\r\n      if (_children.hasOwnProperty(child)) {\r\n        if ((_childrenCount[child] || 0) != _count(_children[child])) {\r\n          if (info != null) {\r\n            info.message = \"Children count for item \" + child + \" missmatch.\";\r\n          }\r\n          return false;\r\n        }\r\n        if (_children.hasOwnProperty(child) && !_nodes.hasOwnProperty(child)) {\r\n          if (info != null) {\r\n            info.message = \"Orphant children of item \" + child;\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (child in _roots) {\r\n      if (_roots.hasOwnProperty(child)) {\r\n        if ((_rootsCount[child] || 0) != _count(_roots[child])) {\r\n          if (info != null) {\r\n            info.message = \"Root children count for item @\" + child + \" missmatch.\";\r\n          }\r\n          return false;\r\n        }\r\n        _loop(this, _roots, child, function (nodeid) {\r\n          if (!_nodes.hasOwnProperty(nodeid)) {\r\n            if (info != null) {\r\n              info.message = \"Child #\" + nodeid + \"of root #\" + child + \" does not exists.\";\r\n            }\r\n            return false;\r\n          }\r\n        }); //ignore jslint\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if family structure has loops in references. \r\n   * @returns {boolean} Returns true if family structure contains loops in references.\r\n   */\r\n  function hasLoops() {\r\n    var tempFamily = clone();\r\n    loopTopo(this, function (itemid, item, levelIndex) {\r\n      tempFamily.removeNode(itemid);\r\n    });\r\n\r\n    return tempFamily.hasNodes();\r\n  }\r\n\r\n  /**\r\n   * Clones family structure.\r\n   * \r\n   * @returns {family} Returns copy of the family structure.\r\n   */\r\n  function clone() {\r\n    return Family({\r\n      roots: _roots,\r\n      rootsCount: _rootsCount,\r\n      children: _children,\r\n      childrenCount: _childrenCount,\r\n      parents: _parents,\r\n      parentsCount: _parentsCount,\r\n      nodes: _nodes\r\n    });\r\n  }\r\n\r\n  return {\r\n    /* family structure modification */\r\n    add: add,\r\n    adopt: adopt,\r\n    bundleChildren: bundleChildren,\r\n    bundleParents: bundleParents,\r\n    optimizeReferences: optimizeReferences,\r\n    eliminateManyToMany: eliminateManyToMany,\r\n    groupBy: groupBy,\r\n    getPlanarFamily: getPlanarFamily,\r\n    getFamilyWithoutGrandParentsRelations: getFamilyWithoutGrandParentsRelations,\r\n    getGraph: getGraph,\r\n\r\n    removeNode: removeNode,\r\n    removeRelation: removeRelation,\r\n    removeChildRelation: removeChildRelation,\r\n\r\n    /* referencing and looping */\r\n    node: node,\r\n    loop: loop,\r\n    loopLevels: loopLevels,\r\n    loopTopo: loopTopo,\r\n    loopTopoReversed: loopTopoReversed,\r\n    loopChildren: loopChildren,\r\n    loopParents: loopParents,\r\n    findLargestRoot: findLargestRoot,\r\n    loopRoots: loopRoots,\r\n    hasNodes: hasNodes,\r\n    hasCommonChild: hasCommonChild,\r\n    loopNeighbours: loopNeighbours,\r\n    countChildren: countChildren,\r\n    countParents: countParents,\r\n    firstParent: firstParent,\r\n    firstChild: firstChild,\r\n\r\n    /* force validation */\r\n    validate: validate,\r\n    hasLoops: hasLoops,\r\n    clone: clone,\r\n\r\n    // callback return codes\r\n    BREAK: BREAK, // break loop immidiatly\r\n    SKIP: SKIP // skip loop of current node children \r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}