{"ast":null,"code":"import Rect from '../../../graphics/structs/Rect';\nimport { VerticalAlignmentType, HorizontalAlignmentType, Visibility, GroupByType, SideFlag } from '../../../enums';\nimport TreeLevelPosition from '../../../models/TreeLevelPosition';\nimport TreeItemPosition from '../../../models/TreeItemPosition';\nfunction ChildLayoutPosition(offset, leftPadding, rightPadding) {\n  this.offset = offset;\n  this.leftPadding = leftPadding;\n  this.rightPadding = rightPadding;\n}\nexport default function OrgLayout(visualTree, treeLevels, leftMargins, rightMargins, getConnectorsStacksSizes) {\n  this.visualTree = visualTree;\n  this.treeLevels = treeLevels; // TreeLevels of OrgItem used properties: isVisible\n  this.leftMargins = leftMargins;\n  this.rightMargins = rightMargins;\n  this.getConnectorsStacksSizes = getConnectorsStacksSizes;\n  this.treeLevelsPositions = [];\n  this.childLayoutsPositions = {};\n}\n;\nOrgLayout.prototype.loop = function (thisArg, onItem) {\n  if (onItem != null) {\n    var zeroBasedLevelIndex = 0;\n    this.treeLevels.loopLevels(this, function (levelIndex) {\n      this.treeLevels.loopLevelItems(this, levelIndex, function (treeItemId, treeItem) {\n        onItem.call(thisArg, treeItem, zeroBasedLevelIndex);\n      });\n      zeroBasedLevelIndex += 1;\n    });\n  }\n};\nOrgLayout.prototype.measure = function (levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {\n  this.treeLevelsPositions = [];\n  this.treeLevels.loopLevels(this, function (index, levelContext) {\n    var treeLevelPosition = new TreeLevelPosition();\n    this.treeLevelsPositions.push(treeLevelPosition);\n  });\n  this.setOffsets(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, this.visualTree, this.rightMargins, this.leftMargins, options.intervals, options.arrowsDirection, options.linesWidth, options.cousinsIntervalMultiplier, options.horizontalAlignment, options.padding);\n  this.setLevelsDepth(this.treeLevels, treeItemsPositions, this.treeLevelsPositions, options.verticalAlignment);\n  this.shiftLevels(this.treeLevelsPositions, options.padding.top, options.shifts, options.arrowsDirection, options.linesWidth, this.getConnectorsStacksSizes);\n  var treeItemPosition = new TreeItemPosition();\n  treeItemPosition.actualVisibility = Visibility.Normal;\n  treeItemPosition.actualSize = this.getLayoutSize(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, options.padding);\n  return treeItemPosition;\n};\nOrgLayout.prototype.getLayoutSize = function (treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, padding) {\n  return new Rect(0, 0, Math.round(this.getLayoutWidth(treeLevels, treeItemsPositions, childLayoutsPositions, padding)), Math.round(this.getLayoutHeight(treeLevelsPositions, padding)));\n};\nOrgLayout.prototype.getLayoutWidth = function (treeLevels, treeItemsPositions, childLayoutsPositions, padding) {\n  var result = 0;\n  treeLevels.loopLevels(this, function (levelIndex, level) {\n    var levelLength = treeLevels.getLevelLength(levelIndex);\n    if (levelLength > 0) {\n      var itemId = treeLevels.getItemAtPosition(levelIndex, levelLength - 1),\n        treeItemPosition = treeItemsPositions[itemId],\n        childLayoutPosition = childLayoutsPositions[itemId];\n      result = Math.max(result, childLayoutPosition.offset + treeItemPosition.actualSize.width + padding.right);\n    }\n  });\n  return result;\n};\nOrgLayout.prototype.getLayoutHeight = function (treeLevelsPositions, padding) {\n  var len = treeLevelsPositions.length,\n    treeLevel = treeLevelsPositions[len - 1];\n  return treeLevel.getNodesBottom() + padding.bottom;\n};\nOrgLayout.prototype.setLevelsDepth = function (treeLevels, treeItemsPositions, treeLevelsPositions, verticalAlignment) {\n  var minimalDepth, dotsDepth;\n  treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n    var treeLevelPosition = treeLevelsPositions[levelIndex];\n    treeLevelPosition.shift = 0.0;\n    treeLevelPosition.depth = 0.0;\n    treeLevelPosition.actualVisibility = Visibility.Invisible;\n    minimalDepth = null; /* minimum  height of non-dot items in level */\n    dotsDepth = null; /* maximum dots height */\n\n    treeLevels.loopLevelItems(this, levelIndex, function (itemId, treeItem, position) {\n      var treeItemPosition = treeItemsPositions[itemId];\n      treeLevelPosition.depth = Math.max(treeLevelPosition.depth, treeItemPosition.actualSize.height);\n      switch (treeItemPosition.actualVisibility) {\n        case Visibility.Dot:\n        case Visibility.Line:\n        case Visibility.Invisible:\n          dotsDepth = !dotsDepth ? treeItemPosition.actualSize.height : Math.min(dotsDepth, treeItemPosition.actualSize.height);\n          break;\n        default:\n          minimalDepth = !minimalDepth ? treeItemPosition.actualSize.height : Math.min(minimalDepth, treeItemPosition.actualSize.height);\n          break;\n      }\n      treeLevelPosition.actualVisibility = Math.min(treeLevelPosition.actualVisibility, treeItemPosition.actualVisibility);\n    });\n    if (minimalDepth == null) {\n      minimalDepth = treeLevelPosition.depth;\n    }\n    if (dotsDepth != null && dotsDepth > minimalDepth) {\n      minimalDepth = dotsDepth;\n    }\n    switch (verticalAlignment) {\n      case VerticalAlignmentType.Top:\n        treeLevelPosition.horizontalConnectorsDepth = minimalDepth / 2.0;\n        break;\n      case VerticalAlignmentType.Middle:\n        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth / 2.0;\n        break;\n      case VerticalAlignmentType.Bottom:\n        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth - minimalDepth / 2.0;\n        break;\n    }\n  });\n};\nOrgLayout.prototype.shiftLevels = function (treeLevelsPositions, shift, shifts, arrowsDirection, linesWidth, getConnectorsStacksSizes) {\n  var index,\n    len,\n    treeLevelPosition,\n    childrenSpace = 0,\n    parentsSpace = 0,\n    arrowTipLength = linesWidth * 8;\n  switch (arrowsDirection) {\n    case GroupByType.Parents:\n      childrenSpace = arrowTipLength;\n      parentsSpace = 0;\n      break;\n    case GroupByType.Children:\n      childrenSpace = 0;\n      parentsSpace = arrowTipLength;\n      break;\n  }\n  var isTopLevel = true;\n  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {\n    treeLevelPosition = treeLevelsPositions[index];\n    if (isTopLevel && treeLevelPosition.actualVisibility == Visibility.Invisible) {\n      treeLevelPosition.setShift(0, 0, 0, 0, 0);\n    } else {\n      var parentsStackSize = getConnectorsStacksSizes(index).parentsStackSize;\n      shift += treeLevelPosition.setShift(shift, shifts[treeLevelPosition.actualVisibility], parentsSpace, childrenSpace, parentsStackSize);\n      isTopLevel = false;\n    }\n  }\n};\nOrgLayout.prototype.setOffsets = function (treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, visualTree, rightMargins, leftMargins, intervals, arrowsDirection, linesWidth, cousinsIntervalMultiplier, horizontalAlignment, padding) {\n  var index, len;\n  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {\n    treeLevelsPositions[index].currentOffset = 0.0;\n  }\n  visualTree.loopPostOrder(this, function (treeItemId, treeItem, parentId, parent) {\n    var treeItemPosition = treeItemsPositions[treeItemId],\n      treeItemVisibility = treeItemPosition.actualVisibility,\n      treeItemLevelIndex = treeLevels.getLevelIndex(treeItemId),\n      treeLevelPosition = treeLevelsPositions[treeItemLevelIndex],\n      treeItemPadding = intervals[treeItemVisibility === Visibility.Auto ? treeLevelPosition.currentvisibility : treeItemVisibility] / 2.0,\n      index,\n      len,\n      offset,\n      siblings,\n      gaps,\n      gap,\n      leftMargin,\n      parentItem,\n      groups,\n      items,\n      item1,\n      item2,\n      groupIndex,\n      groupOffset,\n      group,\n      sibling,\n      leftPadding = treeLevelPosition.currentOffset > 0 ? treeItemPadding + treeItemPadding * treeItem.relationDegree * cousinsIntervalMultiplier : padding.left,\n      arrowTipLength = linesWidth * 8;\n    childLayoutsPositions[treeItemId] = new ChildLayoutPosition(0, leftPadding, treeItemPadding);\n    var childLayoutPosition = childLayoutsPositions[treeItemId];\n    if (arrowsDirection != GroupByType.None) {\n      if (treeItem.connectorPlacement & SideFlag.Left) {\n        childLayoutPosition.leftPadding += arrowTipLength;\n      }\n      if (treeItem.connectorPlacement & SideFlag.Right) {\n        childLayoutPosition.rightPadding += arrowTipLength;\n      }\n    }\n    childLayoutPosition.offset = treeLevelPosition.currentOffset + childLayoutPosition.leftPadding;\n    treeLevelPosition.currentOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;\n    if (visualTree.hasChildren(treeItemId)) {\n      offset = this.getChildrenOffset(treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment);\n      if (offset > 0) {\n        this.offsetItemChildren(treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n      } else if (offset < 0) {\n        offset = -offset;\n        this.offsetItem(treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n        siblings = null;\n        gaps = {};\n        leftMargin = null;\n        parentItem = visualTree.parent(treeItem.id);\n        if (parentItem !== null) {\n          visualTree.loopChildrenReversed(this, parentItem.id, function (childItemId, childItem, index) {\n            if (childItem === treeItem) {\n              siblings = [];\n            } else if (siblings !== null) {\n              gap = this.getGapBetweenSiblings(childItem, treeItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions);\n              gaps[childItem.id] = gap;\n              if (gap > 0) {\n                siblings.splice(0, 0, childItem);\n              } else {\n                leftMargin = childItem;\n                return true;\n              }\n            }\n          });\n          if (siblings.length > 0) {\n            groups = null;\n            if (leftMargin !== null) {\n              items = [leftMargin];\n              items = items.concat(siblings);\n              items.push(treeItem);\n              groups = [[leftMargin]];\n              for (index = 1, len = items.length; index < len; index += 1) {\n                item1 = items[index - 1];\n                item2 = items[index];\n                if (item1.gravity == HorizontalAlignmentType.Right || item2.gravity == HorizontalAlignmentType.Left) {\n                  groups[groups.length - 1].push(item2);\n                } else {\n                  groups.push([item2]);\n                }\n              }\n            } else {\n              groups = [siblings.slice(0)];\n              groups[groups.length - 1].push(treeItem);\n            }\n\n            // align items to the right\n            if (groups.length > 0) {\n              siblings = groups[groups.length - 1];\n              for (index = siblings.length - 2; index >= 0; index -= 1) {\n                sibling = siblings[index];\n                gap = gaps[sibling.id];\n                offset = Math.min(gap, offset);\n                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n              }\n            }\n\n            // spread items proportionally\n            groupOffset = offset / (groups.length - 1);\n            for (groupIndex = groups.length - 2; groupIndex > 0; groupIndex -= 1) {\n              group = groups[groupIndex];\n              for (index = group.length - 1; index >= 0; index -= 1) {\n                sibling = group[index];\n                gap = gaps[sibling.id];\n                offset = Math.min(groupIndex * groupOffset, Math.min(gap, offset));\n                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n};\nOrgLayout.prototype.getGapBetweenSiblings = function (leftItem, rightItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions) {\n  var result = null,\n    itemRightMargins = this.getRightMargins(leftItem, rightMargins, treeItemsPositions, childLayoutsPositions),\n    itemLeftMargins = this.getLeftMargins(rightItem, leftMargins, childLayoutsPositions),\n    depth = Math.min(itemRightMargins.length, itemLeftMargins.length);\n  for (var index = 0; index < depth; index += 1) {\n    var gap = itemLeftMargins[index] - itemRightMargins[index];\n    result = result !== null ? Math.min(result, gap) : gap;\n    if (gap <= 0) {\n      break;\n    }\n  }\n  return Math.floor(result);\n};\nOrgLayout.prototype.getRightMargins = function (treeItem, rightMargins, treeItemsPositions, childLayoutsPositions) {\n  var result = [],\n    itemRightMargins = rightMargins[treeItem.id];\n  if (itemRightMargins === undefined) {\n    itemRightMargins = [];\n  }\n  itemRightMargins = itemRightMargins.slice();\n  itemRightMargins.splice(0, 0, treeItem.id);\n  for (var index = 0, len = itemRightMargins.length; index < len; index += 1) {\n    var treeItemId = itemRightMargins[index];\n    var treeItemPosition = treeItemsPositions[treeItemId];\n    var childLayoutPosition = childLayoutsPositions[treeItemId];\n    result[index] = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;\n  }\n  return result;\n};\nOrgLayout.prototype.getLeftMargins = function (treeItem, leftMargins, childLayoutsPositions) {\n  var result = [],\n    itemLeftMargins = leftMargins[treeItem.id];\n  if (itemLeftMargins === undefined) {\n    itemLeftMargins = [];\n  }\n  itemLeftMargins = itemLeftMargins.slice();\n  itemLeftMargins.splice(0, 0, treeItem.id);\n  for (var index = 0, len = itemLeftMargins.length; index < len; index += 1) {\n    var childLayoutPosition = childLayoutsPositions[itemLeftMargins[index]];\n    result[index] = childLayoutPosition.offset - childLayoutPosition.leftPadding;\n  }\n  return result;\n};\nOrgLayout.prototype.getChildrenOffset = function (treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment) {\n  var treeItemPosition = treeItemsPositions[treeItem.id],\n    childLayoutPosition = childLayoutsPositions[treeItem.id],\n    treeItemCenterOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width / 2.0,\n    childrenCenterOffset = null;\n  if (treeItem.visualAggregatorId === null) {\n    var firstItem = null;\n    visualTree.loopChildren(this, treeItem.id, function (childItemId, childItem, index) {\n      firstItem = childItem;\n      if (firstItem.connectorPlacement & SideFlag.Top) {\n        return true;\n      }\n    });\n    var firstItemPosition = treeItemsPositions[firstItem.id];\n    var firstLayoutPosition = childLayoutsPositions[firstItem.id];\n    var lastItem = null;\n    visualTree.loopChildrenReversed(this, treeItem.id, function (childItemId, childItem, index) {\n      lastItem = childItem;\n      if (lastItem.connectorPlacement & SideFlag.Top) {\n        return true;\n      }\n    });\n    var lastItemPosition = treeItemsPositions[lastItem.id];\n    var lastLayoutPosition = childLayoutsPositions[lastItem.id];\n    switch (horizontalAlignment) {\n      case HorizontalAlignmentType.Left:\n        childrenCenterOffset = firstLayoutPosition.offset + firstItemPosition.actualSize.width / 2.0;\n        break;\n      case HorizontalAlignmentType.Right:\n        childrenCenterOffset = lastLayoutPosition.offset + lastItemPosition.actualSize.width / 2.0;\n        break;\n      case HorizontalAlignmentType.Center:\n        childrenCenterOffset = (firstLayoutPosition.offset + lastLayoutPosition.offset + lastItemPosition.actualSize.width) / 2.0;\n        break;\n    }\n  } else {\n    var visualAggregatorPosition = treeItemsPositions[treeItem.visualAggregatorId];\n    var visualAggregatorLayoutPosition = childLayoutsPositions[treeItem.visualAggregatorId];\n    childrenCenterOffset = visualAggregatorLayoutPosition.offset + visualAggregatorPosition.actualSize.width / 2.0;\n  }\n  return treeItemCenterOffset - childrenCenterOffset;\n};\nOrgLayout.prototype.offsetItem = function (treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions) {\n  var treeItemPosition = treeItemsPositions[treeItem.id];\n  var childLayoutPosition = childLayoutsPositions[treeItem.id];\n  childLayoutPosition.offset += offset;\n  var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(treeItem.id)];\n  treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding);\n};\nOrgLayout.prototype.offsetItemChildren = function (treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions) {\n  visualTree.loopLevels(this, treeItem.id, function (childItemId, childItem, levelid) {\n    var treeItemPosition = treeItemsPositions[childItemId];\n    var childLayoutPosition = childLayoutsPositions[childItemId];\n    childLayoutPosition.offset += offset;\n    var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(childItemId)];\n    treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width);\n    return true;\n  });\n};\nOrgLayout.prototype.arrange = function (thisArg, position, layoutDirection, treeItemsPositions, options, onItemPositioned) {\n  var prevLevelPosition = null;\n  if (onItemPositioned != null) {\n    this.treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var treeLevelPosition = this.treeLevelsPositions[levelIndex];\n      this.treeLevels.loopLevelItems(this, levelIndex, function (itemId, treeItem, position) {\n        var treeItemPosition = treeItemsPositions[itemId];\n        var childLayoutPosition = this.childLayoutsPositions[itemId];\n        var result = this.getItemPosition(treeItemPosition.actualVisibility, childLayoutPosition.offset, treeItemPosition.actualSize, prevLevelPosition, treeLevelPosition, options.verticalAlignment);\n        onItemPositioned.call(thisArg, itemId, {\n          ...treeItemPosition,\n          ...result\n        });\n      });\n      prevLevelPosition = treeLevelPosition;\n    });\n  }\n};\nOrgLayout.prototype.getItemPosition = function (visibility, offset, size, prevLevel, level, verticalAlignment) {\n  var itemShift = 0;\n  switch (visibility) {\n    case Visibility.Normal:\n      switch (verticalAlignment) {\n        case VerticalAlignmentType.Top:\n          itemShift = 0;\n          break;\n        case VerticalAlignmentType.Middle:\n          itemShift = (level.depth - size.height) / 2.0;\n          break;\n        case VerticalAlignmentType.Bottom:\n          itemShift = level.depth - size.height;\n          break;\n      }\n      break;\n    case Visibility.Dot:\n    case Visibility.Line:\n    case Visibility.Invisible:\n      itemShift = level.horizontalConnectorsDepth - size.height / 2.0;\n      break;\n  }\n  return {\n    actualPosition: new Rect(offset, level.shift + itemShift, size.width, size.height),\n    horizontalConnectorsShift: level.shift + level.horizontalConnectorsDepth,\n    topConnectorShift: prevLevel != null ? prevLevel.shift + prevLevel.connectorShift : null,\n    topConnectorInterval: prevLevel != null ? prevLevel.levelSpace / 2 : null,\n    bottomConnectorShift: level.shift + level.connectorShift,\n    bottomConnectorInterval: level.levelSpace / 2\n  };\n};","map":{"version":3,"names":["Rect","VerticalAlignmentType","HorizontalAlignmentType","Visibility","GroupByType","SideFlag","TreeLevelPosition","TreeItemPosition","ChildLayoutPosition","offset","leftPadding","rightPadding","OrgLayout","visualTree","treeLevels","leftMargins","rightMargins","getConnectorsStacksSizes","treeLevelsPositions","childLayoutsPositions","prototype","loop","thisArg","onItem","zeroBasedLevelIndex","loopLevels","levelIndex","loopLevelItems","treeItemId","treeItem","call","measure","levelVisibility","isCursor","isSelected","treeItemTemplate","treeItemsPositions","options","index","levelContext","treeLevelPosition","push","setOffsets","intervals","arrowsDirection","linesWidth","cousinsIntervalMultiplier","horizontalAlignment","padding","setLevelsDepth","verticalAlignment","shiftLevels","top","shifts","treeItemPosition","actualVisibility","Normal","actualSize","getLayoutSize","Math","round","getLayoutWidth","getLayoutHeight","result","level","levelLength","getLevelLength","itemId","getItemAtPosition","childLayoutPosition","max","width","right","len","length","treeLevel","getNodesBottom","bottom","minimalDepth","dotsDepth","shift","depth","Invisible","position","height","Dot","Line","min","Top","horizontalConnectorsDepth","Middle","Bottom","childrenSpace","parentsSpace","arrowTipLength","Parents","Children","isTopLevel","setShift","parentsStackSize","currentOffset","loopPostOrder","parentId","parent","treeItemVisibility","treeItemLevelIndex","getLevelIndex","treeItemPadding","Auto","currentvisibility","siblings","gaps","gap","leftMargin","parentItem","groups","items","item1","item2","groupIndex","groupOffset","group","sibling","relationDegree","left","None","connectorPlacement","Left","Right","hasChildren","getChildrenOffset","offsetItemChildren","offsetItem","id","loopChildrenReversed","childItemId","childItem","getGapBetweenSiblings","splice","concat","gravity","slice","leftItem","rightItem","itemRightMargins","getRightMargins","itemLeftMargins","getLeftMargins","floor","undefined","treeItemCenterOffset","childrenCenterOffset","visualAggregatorId","firstItem","loopChildren","firstItemPosition","firstLayoutPosition","lastItem","lastItemPosition","lastLayoutPosition","Center","visualAggregatorPosition","visualAggregatorLayoutPosition","levelid","arrange","layoutDirection","onItemPositioned","prevLevelPosition","getItemPosition","visibility","size","prevLevel","itemShift","actualPosition","horizontalConnectorsShift","topConnectorShift","connectorShift","topConnectorInterval","levelSpace","bottomConnectorShift","bottomConnectorInterval"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/tasks/transformations/layouts/OrgLayout.js"],"sourcesContent":["import Rect from '../../../graphics/structs/Rect';\r\nimport { VerticalAlignmentType, HorizontalAlignmentType, Visibility, GroupByType, SideFlag } from '../../../enums';\r\nimport TreeLevelPosition from '../../../models/TreeLevelPosition';\r\nimport TreeItemPosition from '../../../models/TreeItemPosition';\r\n\r\nfunction ChildLayoutPosition( offset, leftPadding, rightPadding ) {\r\n  this.offset = offset;\r\n  this.leftPadding = leftPadding;\r\n  this.rightPadding = rightPadding;\r\n}\r\n\r\nexport default function OrgLayout(visualTree, treeLevels, leftMargins, rightMargins, getConnectorsStacksSizes) {\r\n  this.visualTree = visualTree;\r\n  this.treeLevels = treeLevels; // TreeLevels of OrgItem used properties: isVisible\r\n  this.leftMargins = leftMargins;\r\n  this.rightMargins = rightMargins;\r\n  this.getConnectorsStacksSizes = getConnectorsStacksSizes;\r\n\r\n  this.treeLevelsPositions = [];\r\n  this.childLayoutsPositions = {};\r\n};\r\n\r\nOrgLayout.prototype.loop = function (thisArg, onItem) {\r\n  if(onItem != null) {\r\n    var zeroBasedLevelIndex = 0;\r\n    this.treeLevels.loopLevels(this, function (levelIndex) {\r\n      this.treeLevels.loopLevelItems(this, levelIndex, function (treeItemId, treeItem) {\r\n        onItem.call(thisArg, treeItem, zeroBasedLevelIndex);\r\n      });\r\n      zeroBasedLevelIndex+=1;\r\n    });\r\n  }\r\n};\r\n\r\n\r\nOrgLayout.prototype.measure = function (levelVisibility, isCursor, isSelected, treeItemTemplate, treeItemsPositions, options) {\r\n  this.treeLevelsPositions = [];\r\n\r\n  this.treeLevels.loopLevels(this, function (index, levelContext) {\r\n    var treeLevelPosition = new TreeLevelPosition();\r\n    this.treeLevelsPositions.push(treeLevelPosition);\r\n  });\r\n\r\n  this.setOffsets(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, this.visualTree, this.rightMargins, this.leftMargins, options.intervals, options.arrowsDirection, options.linesWidth, options.cousinsIntervalMultiplier, options.horizontalAlignment, options.padding);\r\n  this.setLevelsDepth(this.treeLevels, treeItemsPositions, this.treeLevelsPositions, options.verticalAlignment);\r\n  this.shiftLevels(this.treeLevelsPositions, options.padding.top, options.shifts, options.arrowsDirection, options.linesWidth, this.getConnectorsStacksSizes);\r\n\r\n  var treeItemPosition = new TreeItemPosition();\r\n  treeItemPosition.actualVisibility = Visibility.Normal;\r\n  treeItemPosition.actualSize = this.getLayoutSize(this.treeLevels, treeItemsPositions, this.childLayoutsPositions, this.treeLevelsPositions, options.padding);\r\n  return treeItemPosition;\r\n};\r\n\r\nOrgLayout.prototype.getLayoutSize = function (treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, padding) {\r\n  return new Rect(0, 0, Math.round(this.getLayoutWidth(treeLevels, treeItemsPositions, childLayoutsPositions, padding)), Math.round(this.getLayoutHeight(treeLevelsPositions, padding)));\r\n};\r\n\r\nOrgLayout.prototype.getLayoutWidth = function (treeLevels, treeItemsPositions, childLayoutsPositions, padding) {\r\n  var result = 0;\r\n  treeLevels.loopLevels(this, function (levelIndex, level) {\r\n    var levelLength = treeLevels.getLevelLength(levelIndex);\r\n\r\n    if (levelLength > 0) {\r\n      var itemId = treeLevels.getItemAtPosition(levelIndex, levelLength - 1),\r\n        treeItemPosition = treeItemsPositions[itemId],\r\n        childLayoutPosition = childLayoutsPositions[itemId];\r\n      result = Math.max(result, childLayoutPosition.offset + treeItemPosition.actualSize.width + padding.right);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\nOrgLayout.prototype.getLayoutHeight = function (treeLevelsPositions, padding) {\r\n  var len = treeLevelsPositions.length,\r\n    treeLevel = treeLevelsPositions[len - 1];\r\n  return treeLevel.getNodesBottom() + padding.bottom;\r\n};\r\n\r\nOrgLayout.prototype.setLevelsDepth = function (treeLevels, treeItemsPositions, treeLevelsPositions, verticalAlignment) {\r\n  var minimalDepth,\r\n    dotsDepth;\r\n\r\n  treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\r\n    var treeLevelPosition = treeLevelsPositions[levelIndex];\r\n    treeLevelPosition.shift = 0.0;\r\n    treeLevelPosition.depth = 0.0;\r\n    treeLevelPosition.actualVisibility = Visibility.Invisible;\r\n\r\n    minimalDepth = null; /* minimum  height of non-dot items in level */\r\n    dotsDepth = null; /* maximum dots height */\r\n\r\n    treeLevels.loopLevelItems(this, levelIndex, function (itemId, treeItem, position) {\r\n      var treeItemPosition = treeItemsPositions[itemId];\r\n      treeLevelPosition.depth = Math.max(treeLevelPosition.depth, treeItemPosition.actualSize.height);\r\n      switch (treeItemPosition.actualVisibility) {\r\n        case Visibility.Dot:\r\n        case Visibility.Line:\r\n        case Visibility.Invisible:\r\n          dotsDepth = !dotsDepth ? treeItemPosition.actualSize.height : Math.min(dotsDepth, treeItemPosition.actualSize.height);\r\n          break;\r\n        default:\r\n          minimalDepth = !minimalDepth ? treeItemPosition.actualSize.height : Math.min(minimalDepth, treeItemPosition.actualSize.height);\r\n          break;\r\n      }\r\n\r\n      treeLevelPosition.actualVisibility = Math.min(treeLevelPosition.actualVisibility, treeItemPosition.actualVisibility);\r\n    });\r\n\r\n    if (minimalDepth == null) {\r\n      minimalDepth = treeLevelPosition.depth;\r\n    }\r\n    if (dotsDepth != null && dotsDepth > minimalDepth) {\r\n      minimalDepth = dotsDepth;\r\n    }\r\n\r\n    switch (verticalAlignment) {\r\n      case VerticalAlignmentType.Top:\r\n        treeLevelPosition.horizontalConnectorsDepth = minimalDepth / 2.0;\r\n        break;\r\n      case VerticalAlignmentType.Middle:\r\n        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth / 2.0;\r\n        break;\r\n      case VerticalAlignmentType.Bottom:\r\n        treeLevelPosition.horizontalConnectorsDepth = treeLevelPosition.depth - minimalDepth / 2.0;\r\n        break;\r\n    }\r\n  });\r\n};\r\n\r\nOrgLayout.prototype.shiftLevels = function (treeLevelsPositions, shift, shifts, arrowsDirection, linesWidth, getConnectorsStacksSizes) {\r\n  var index,\r\n    len,\r\n    treeLevelPosition,\r\n    childrenSpace = 0,\r\n    parentsSpace = 0,\r\n    arrowTipLength = linesWidth * 8;\r\n\r\n  switch (arrowsDirection) {\r\n    case GroupByType.Parents:\r\n      childrenSpace = arrowTipLength;\r\n      parentsSpace = 0;\r\n      break;\r\n    case GroupByType.Children:\r\n      childrenSpace = 0;\r\n      parentsSpace = arrowTipLength;\r\n      break;\r\n  }\r\n\r\n  var isTopLevel = true;\r\n  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {\r\n    treeLevelPosition = treeLevelsPositions[index];\r\n    \r\n    if(isTopLevel && treeLevelPosition.actualVisibility == Visibility.Invisible) {\r\n      treeLevelPosition.setShift(0, 0, 0, 0, 0);\r\n    } else {\r\n      var parentsStackSize = getConnectorsStacksSizes(index).parentsStackSize;\r\n      shift += treeLevelPosition.setShift(shift, shifts[treeLevelPosition.actualVisibility], parentsSpace, childrenSpace, parentsStackSize);\r\n      isTopLevel = false;\r\n    }\r\n  }\r\n};\r\n\r\nOrgLayout.prototype.setOffsets = function (treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions, visualTree, rightMargins, leftMargins, intervals, arrowsDirection, linesWidth, cousinsIntervalMultiplier, horizontalAlignment, padding) {\r\n  var index, len;\r\n\r\n  for (index = 0, len = treeLevelsPositions.length; index < len; index += 1) {\r\n    treeLevelsPositions[index].currentOffset = 0.0;\r\n  }\r\n\r\n  visualTree.loopPostOrder(this, function (treeItemId, treeItem, parentId, parent) {\r\n    var treeItemPosition = treeItemsPositions[treeItemId],\r\n      treeItemVisibility = treeItemPosition.actualVisibility,\r\n      treeItemLevelIndex = treeLevels.getLevelIndex(treeItemId),\r\n      treeLevelPosition = treeLevelsPositions[treeItemLevelIndex],\r\n      treeItemPadding = intervals[treeItemVisibility === Visibility.Auto ? treeLevelPosition.currentvisibility : treeItemVisibility] / 2.0,\r\n      index,\r\n      len,\r\n      offset,\r\n      siblings,\r\n      gaps,\r\n      gap,\r\n      leftMargin,\r\n      parentItem,\r\n      groups,\r\n      items,\r\n      item1,\r\n      item2,\r\n      groupIndex,\r\n      groupOffset,\r\n      group,\r\n      sibling,\r\n      leftPadding = treeLevelPosition.currentOffset > 0 ? treeItemPadding + treeItemPadding * (treeItem.relationDegree) * cousinsIntervalMultiplier : padding.left,\r\n      arrowTipLength = linesWidth * 8;\r\n\r\n    childLayoutsPositions[treeItemId] = new ChildLayoutPosition(0,  leftPadding, treeItemPadding);\r\n    var childLayoutPosition = childLayoutsPositions[treeItemId];\r\n\r\n    if (arrowsDirection != GroupByType.None) {\r\n      if (treeItem.connectorPlacement & SideFlag.Left) {\r\n        childLayoutPosition.leftPadding += arrowTipLength;\r\n      }\r\n      if (treeItem.connectorPlacement & SideFlag.Right) {\r\n        childLayoutPosition.rightPadding += arrowTipLength;\r\n      }\r\n    }\r\n    childLayoutPosition.offset = treeLevelPosition.currentOffset + childLayoutPosition.leftPadding;\r\n    treeLevelPosition.currentOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;\r\n\r\n    if (visualTree.hasChildren(treeItemId)) {\r\n      offset = this.getChildrenOffset(treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment);\r\n      if (offset > 0) {\r\n        this.offsetItemChildren(treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n      }\r\n      else if (offset < 0) {\r\n        offset = -offset;\r\n        this.offsetItem(treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n\r\n        siblings = null;\r\n        gaps = {};\r\n        leftMargin = null;\r\n        parentItem = visualTree.parent(treeItem.id);\r\n        if (parentItem !== null) {\r\n          visualTree.loopChildrenReversed(this, parentItem.id, function (childItemId, childItem, index) {\r\n            if (childItem === treeItem) {\r\n              siblings = [];\r\n            }\r\n            else if (siblings !== null) {\r\n              gap = this.getGapBetweenSiblings(childItem, treeItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions);\r\n              gaps[childItem.id] = gap;\r\n              if (gap > 0) {\r\n                siblings.splice(0, 0, childItem);\r\n              }\r\n              else {\r\n                leftMargin = childItem;\r\n                return true;\r\n              }\r\n            }\r\n          });\r\n\r\n          if (siblings.length > 0) {\r\n            groups = null;\r\n            if (leftMargin !== null) {\r\n              items = [leftMargin];\r\n              items = items.concat(siblings);\r\n              items.push(treeItem);\r\n\r\n              groups = [[leftMargin]];\r\n              for (index = 1, len = items.length; index < len; index += 1) {\r\n                item1 = items[index - 1];\r\n                item2 = items[index];\r\n                if (item1.gravity == HorizontalAlignmentType.Right || item2.gravity == HorizontalAlignmentType.Left) {\r\n                  groups[groups.length - 1].push(item2);\r\n                }\r\n                else {\r\n                  groups.push([item2]);\r\n                }\r\n              }\r\n            }\r\n            else {\r\n              groups = [siblings.slice(0)];\r\n              groups[groups.length - 1].push(treeItem);\r\n            }\r\n\r\n            // align items to the right\r\n            if (groups.length > 0) {\r\n              siblings = groups[groups.length - 1];\r\n              for (index = siblings.length - 2; index >= 0; index -= 1) {\r\n                sibling = siblings[index];\r\n                gap = gaps[sibling.id];\r\n                offset = Math.min(gap, offset);\r\n\r\n                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n              }\r\n            }\r\n\r\n            // spread items proportionally\r\n            groupOffset = offset / (groups.length - 1);\r\n            for (groupIndex = groups.length - 2; groupIndex > 0; groupIndex -= 1) {\r\n              group = groups[groupIndex];\r\n              for (index = group.length - 1; index >= 0; index -= 1) {\r\n                sibling = group[index];\r\n                gap = gaps[sibling.id];\r\n                offset = Math.min(groupIndex * groupOffset, Math.min(gap, offset));\r\n\r\n                this.offsetItem(sibling, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n                this.offsetItemChildren(sibling, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nOrgLayout.prototype.getGapBetweenSiblings = function(leftItem, rightItem, rightMargins, leftMargins, treeItemsPositions, childLayoutsPositions) {\r\n  var result = null,\r\n    itemRightMargins = this.getRightMargins(leftItem, rightMargins, treeItemsPositions, childLayoutsPositions),\r\n    itemLeftMargins = this.getLeftMargins(rightItem, leftMargins, childLayoutsPositions),\r\n    depth = Math.min(itemRightMargins.length, itemLeftMargins.length);\r\n\r\n  for (var index = 0; index < depth; index += 1) {\r\n    var gap = itemLeftMargins[index] - itemRightMargins[index];\r\n    result = (result !== null) ? Math.min(result, gap) : gap;\r\n\r\n    if (gap <= 0) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return Math.floor(result);\r\n}\r\n\r\nOrgLayout.prototype.getRightMargins = function(treeItem, rightMargins, treeItemsPositions, childLayoutsPositions) {\r\n  var result = [],\r\n    itemRightMargins = rightMargins[treeItem.id];\r\n  if (itemRightMargins === undefined) {\r\n    itemRightMargins = [];\r\n  }\r\n  itemRightMargins = itemRightMargins.slice();\r\n  itemRightMargins.splice(0, 0, treeItem.id);\r\n  for (var index = 0, len = itemRightMargins.length; index < len; index += 1) {\r\n    var treeItemId = itemRightMargins[index];\r\n    var treeItemPosition = treeItemsPositions[treeItemId];\r\n    var childLayoutPosition = childLayoutsPositions[treeItemId];\r\n    result[index] = childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nOrgLayout.prototype.getLeftMargins = function(treeItem, leftMargins, childLayoutsPositions) {\r\n  var result = [],\r\n    itemLeftMargins = leftMargins[treeItem.id];\r\n  if (itemLeftMargins === undefined) {\r\n    itemLeftMargins = [];\r\n  }\r\n  itemLeftMargins = itemLeftMargins.slice();\r\n  itemLeftMargins.splice(0, 0, treeItem.id);\r\n  for (var index = 0, len = itemLeftMargins.length; index < len; index += 1) {\r\n    var childLayoutPosition = childLayoutsPositions[itemLeftMargins[index]];\r\n    result[index] = childLayoutPosition.offset - childLayoutPosition.leftPadding;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nOrgLayout.prototype.getChildrenOffset = function(treeItem, treeItemsPositions, childLayoutsPositions, visualTree, horizontalAlignment) {\r\n  var treeItemPosition = treeItemsPositions[treeItem.id],\r\n    childLayoutPosition = childLayoutsPositions[treeItem.id],\r\n    treeItemCenterOffset = childLayoutPosition.offset + treeItemPosition.actualSize.width / 2.0,\r\n    childrenCenterOffset = null;\r\n  if (treeItem.visualAggregatorId === null) {\r\n    var firstItem = null;\r\n    visualTree.loopChildren(this, treeItem.id, function (childItemId, childItem, index) {\r\n      firstItem = childItem;\r\n      if (firstItem.connectorPlacement & SideFlag.Top) {\r\n        return true;\r\n      }\r\n    });\r\n    var firstItemPosition = treeItemsPositions[firstItem.id];\r\n    var firstLayoutPosition = childLayoutsPositions[firstItem.id];\r\n\r\n    var lastItem = null;\r\n    visualTree.loopChildrenReversed(this, treeItem.id, function (childItemId, childItem, index) {\r\n      lastItem = childItem;\r\n      if (lastItem.connectorPlacement & SideFlag.Top) {\r\n        return true;\r\n      }\r\n    });\r\n    var lastItemPosition = treeItemsPositions[lastItem.id];\r\n    var lastLayoutPosition = childLayoutsPositions[lastItem.id];\r\n\r\n    switch (horizontalAlignment) {\r\n      case HorizontalAlignmentType.Left:\r\n        childrenCenterOffset = firstLayoutPosition.offset + firstItemPosition.actualSize.width / 2.0;\r\n        break;\r\n      case HorizontalAlignmentType.Right:\r\n        childrenCenterOffset = lastLayoutPosition.offset + lastItemPosition.actualSize.width / 2.0;\r\n        break;\r\n      case HorizontalAlignmentType.Center:\r\n        childrenCenterOffset = (firstLayoutPosition.offset + lastLayoutPosition.offset + lastItemPosition.actualSize.width) / 2.0;\r\n        break;\r\n    }\r\n  }\r\n  else {\r\n    var visualAggregatorPosition = treeItemsPositions[treeItem.visualAggregatorId];\r\n    var visualAggregatorLayoutPosition = childLayoutsPositions[treeItem.visualAggregatorId];\r\n    childrenCenterOffset = visualAggregatorLayoutPosition.offset + visualAggregatorPosition.actualSize.width / 2.0;\r\n  }\r\n\r\n  return treeItemCenterOffset - childrenCenterOffset;\r\n}\r\n\r\nOrgLayout.prototype.offsetItem = function(treeItem, offset, treeLevels, treeItemsPositions, childLayoutsPositions, treeLevelsPositions ) {\r\n  var treeItemPosition = treeItemsPositions[treeItem.id];\r\n  var childLayoutPosition = childLayoutsPositions[treeItem.id];\r\n  childLayoutPosition.offset += offset;\r\n\r\n  var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(treeItem.id)];\r\n  treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width + childLayoutPosition.rightPadding);\r\n}\r\n\r\nOrgLayout.prototype.offsetItemChildren = function(treeItem, offset, treeLevels, visualTree, treeItemsPositions, childLayoutsPositions, treeLevelsPositions) {\r\n  visualTree.loopLevels(this, treeItem.id, function (childItemId, childItem, levelid) {\r\n    var treeItemPosition = treeItemsPositions[childItemId];\r\n    var childLayoutPosition = childLayoutsPositions[childItemId];\r\n    childLayoutPosition.offset += offset;\r\n\r\n    var treeLevelPosition = treeLevelsPositions[treeLevels.getLevelIndex(childItemId)];\r\n    treeLevelPosition.currentOffset = Math.max(treeLevelPosition.currentOffset, childLayoutPosition.offset + treeItemPosition.actualSize.width);\r\n\r\n    return true;\r\n  });\r\n}\r\n\r\nOrgLayout.prototype.arrange = function (thisArg, position, layoutDirection, treeItemsPositions, options, onItemPositioned) {\r\n  var prevLevelPosition = null;\r\n  if (onItemPositioned != null) {\r\n    this.treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\r\n      var treeLevelPosition = this.treeLevelsPositions[levelIndex];\r\n\r\n      this.treeLevels.loopLevelItems(this, levelIndex, function (itemId, treeItem, position) {\r\n        var treeItemPosition = treeItemsPositions[itemId];\r\n        var childLayoutPosition = this.childLayoutsPositions[itemId];\r\n        var result = this.getItemPosition(treeItemPosition.actualVisibility, childLayoutPosition.offset, treeItemPosition.actualSize, prevLevelPosition, treeLevelPosition, options.verticalAlignment);\r\n\r\n        onItemPositioned.call(thisArg, itemId, { ...treeItemPosition, ...result});\r\n      });\r\n\r\n      prevLevelPosition = treeLevelPosition;\r\n    });\r\n  }\r\n};\r\n\r\nOrgLayout.prototype.getItemPosition = function (visibility, offset, size, prevLevel, level, verticalAlignment) {\r\n  var itemShift = 0;\r\n\r\n  switch (visibility) {\r\n    case Visibility.Normal:\r\n      switch (verticalAlignment) {\r\n        case VerticalAlignmentType.Top:\r\n          itemShift = 0;\r\n          break;\r\n        case VerticalAlignmentType.Middle:\r\n          itemShift = (level.depth - size.height) / 2.0;\r\n          break;\r\n        case VerticalAlignmentType.Bottom:\r\n          itemShift = level.depth - size.height;\r\n          break;\r\n      }\r\n      break;\r\n    case Visibility.Dot:\r\n    case Visibility.Line:\r\n    case Visibility.Invisible:\r\n      itemShift = level.horizontalConnectorsDepth - size.height / 2.0;\r\n      break;\r\n  }\r\n\r\n  return {\r\n    actualPosition: new Rect(offset, level.shift + itemShift, size.width, size.height),\r\n    horizontalConnectorsShift: level.shift + level.horizontalConnectorsDepth,\r\n    topConnectorShift: prevLevel != null ? prevLevel.shift + prevLevel.connectorShift : null,\r\n    topConnectorInterval: prevLevel != null ? prevLevel.levelSpace / 2 : null,\r\n    bottomConnectorShift: level.shift + level.connectorShift,\r\n    bottomConnectorInterval: level.levelSpace / 2\r\n  };\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}