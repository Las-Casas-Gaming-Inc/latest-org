{"ast":null,"code":"import Size from '../graphics/structs/Size';\nimport { Colors, Enabled, ItemType, AdviserPlacementType, ChildrenPlacementType, TextOrientationType, PlacementType } from '../enums';\n\n/**\r\n * @class OrgItemConfig\r\n * @classdesc Item Configuration Object defines properties of individual node in the organizational chart hierarchy. See `items` collection property\r\n * of organizational chart control configuration object. \r\n * \r\n * @param {OrgItemConfig} arg0 Item config properties\r\n * \r\n * @param {string} arg0 Item id\r\n * @param {string} arg1 Parent id\r\n * @param {string} arg2 Title\r\n * @param {string} arg3 Description \r\n * @param {string} arg4 Image\r\n */\nexport default function OrgItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\r\n   * Item id. It should be unique per chart.\r\n   * \r\n   * @type {string}\r\n   */\n  this.id = null;\n\n  /**\r\n   * Parent item id. If `null` then node is the root item of the hierarchy.\r\n   * @type {string}\r\n   */\n  this.parent = null;\n\n  /**\r\n   * Title\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.title = null;\n\n  /**\r\n   * Description\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.description = null;\n\n  /**\r\n   * Image\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.image = null;\n\n  /**\r\n   * Context object\r\n   * \r\n   * @group Template\r\n   * @type {object}\r\n   */\n  this.context = null;\n\n  /**\r\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.itemTitleColor = Colors.RoyalBlue;\n\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for individual node.\r\n   * \r\n   * @group Template\r\n   * @type {ShapeType}\r\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\r\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\r\n   * It gives extra dimension for nodes visual grouping in the diagram.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\n  this.groupTitle = null;\n\n  /**\r\n   * The group title background color.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\n  this.groupTitleColor = Colors.RoyalBlue;\n\n  /**\r\n   * If `false` it makes item invisible in the layout. If item has no visible parents then its connections are hidden as well.\r\n   * From navigation perspective invisible items make all their children to be children of their parents.\r\n   * \r\n   * @type {boolean}\r\n   */\n  this.isVisible = true;\n\n  /**\r\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\r\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\r\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\r\n   * indicating that upon reaching them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\n  this.isActive = true;\n\n  /**\r\n   * Shows selection check box for the node.\r\n   * If Auto then selection check box visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasSelectorCheckbox` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @type {Enabled}\r\n   */\n  this.hasSelectorCheckbox = Enabled.Auto;\n\n  /**\r\n   * Shows context buttons panel for the node.\r\n   * If Auto then context buttons panel visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasButtons` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @group Template\r\n   * @type {Enabled}\r\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\r\n   * Item type. This property defines child node placement relative to its parent node. By default all children that belong \r\n   * to a parent node are of the same rank and status between each other and due to that, are always aligned below\r\n   * the parent and are organized in the same way. However for special cases were the end user wishes to have a child\r\n   * that is separate from the rest of it's siblings, we provide custom child types that the end user can use to\r\n   * place different ranking nodes anywhere around the parent node. These placement options give a lot of space for\r\n   * the creation of roles such as an Assistant, Adviser, various Partners and co-heads that may be in the organization.\r\n   * Additionally, by default `Regular` children are always placed in a horizontal line below the parent node.\r\n   * \r\n   * @type {ItemType}\r\n   */\n  this.itemType = ItemType.Regular;\n\n  /**\r\n   * Sets node level offset relative to parent node. This property is ignored if it is not applicable.\r\n   * \r\n   * @type {number}\r\n   */\n  this.levelOffset = null;\n\n  /**\r\n   * Defines leftward or rightward item placement relative to the parent item.\r\n   * By default it is `Auto` and depends on general diagram layout orientation.\r\n   *  \r\n   * @type {AdviserPlacementType}\r\n   */\n  this.adviserPlacementType = AdviserPlacementType.Auto;\n\n  /**\r\n   * The property defines children's layout formation. By default, control places children\r\n   * in a horizontal line below the parent node. On a large scale, this may result in the end-user\r\n   * having to scroll screens to view all nodes. To compensate for this, we place children \r\n   * in a square/matrix formation. That will reduce sideways screen scrolling by compacting\r\n   * the child nodes into a much smaller area on the screen.\r\n   *   \r\n   * @type {ChildrenPlacementType}\r\n   */\n  this.childrenPlacementType = ChildrenPlacementType.Auto;\n\n  /**\r\n   * The property sets the default placement of assistants hierarchies relative to the regular \r\n   * children of the node. If the assistant node has its children, then control adds extra levels,\r\n   * so the assistant's children are placed above the regular children.\r\n   * \r\n   * @type {Enabled}\r\n   */\n  this.placeAssistantsAboveChildren = Enabled.Auto;\n\n  /**\r\n   * The property sets default placement of advisers hierarchies relative to the regular \r\n   * children of the node. If the adviser node has its children, then control adds extra levels,\r\n   * so the adviser's children are placed above the regular children.\r\n   * \r\n   * @type {Enabled}\r\n   */\n  this.placeAdvisersAboveChildren = Enabled.Auto;\n\n  /**\r\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * This option lets individually assign rendering template per individual node of the diagram.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.templateName = null;\n\n  /**\r\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\r\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\r\n   * current template of the node it is rendered for.\r\n   * \r\n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\r\n   * to change their template.\r\n   * \r\n   * Auto - depends on `showCallout` property of the control\r\n   * True - shown regardless of node's visibility\r\n   * False - hidden\r\n   * \r\n   * @group Callout\r\n   * @type {Enabled}\r\n   */\n  this.showCallout = Enabled.Auto;\n\n  /**\r\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\r\n   * per individual node of the diagram.\r\n   * \r\n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * \r\n   * @group Callout\r\n   * @type {string}\r\n   */\n  this.calloutTemplateName = null;\n\n  /**\r\n   * Marker label.\r\n   * \r\n   * @group Label\r\n   * @type {string}\r\n   */\n  this.label = null;\n\n  /**\r\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \r\n   * \r\n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\r\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\r\n   * \r\n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\r\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\r\n   * is going to stay visible.\r\n   * \r\n   * Auto - displays label only when it has space to be rendered.\r\n   * True - shows label regardless, even if it overlaps other labels and nodes.\r\n   * False - hidden.\r\n   * \r\n   * @group Label\r\n   * @type {Enabled}\r\n   */\n  this.showLabel = Enabled.Auto;\n\n  /**\r\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\r\n   * If `null` then it is set to `labelSize` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {Size}\r\n   */\n  this.labelSize = null;\n\n  /**\r\n   * Label orientation.\r\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {TextOrientationType}\r\n   */\n  this.labelOrientation = TextOrientationType.Auto;\n\n  /**\r\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\r\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {PlacementType}\r\n   */\n  this.labelPlacement = PlacementType.Auto;\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n      break;\n    case 5:\n      this.id = arg0;\n      this.parent = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n}\n;","map":{"version":3,"names":["Size","Colors","Enabled","ItemType","AdviserPlacementType","ChildrenPlacementType","TextOrientationType","PlacementType","OrgItemConfig","arg0","arg1","arg2","arg3","arg4","property","id","parent","title","description","image","context","itemTitleColor","RoyalBlue","minimizedItemShapeType","groupTitle","groupTitleColor","isVisible","isActive","hasSelectorCheckbox","Auto","hasButtons","itemType","Regular","levelOffset","adviserPlacementType","childrenPlacementType","placeAssistantsAboveChildren","placeAdvisersAboveChildren","templateName","showCallout","calloutTemplateName","label","showLabel","labelSize","labelOrientation","labelPlacement","arguments","length","hasOwnProperty"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/configs/OrgItemConfig.js"],"sourcesContent":["import Size from '../graphics/structs/Size';\r\nimport { Colors, Enabled, ItemType, AdviserPlacementType, ChildrenPlacementType, TextOrientationType, PlacementType } from '../enums';\r\n\r\n/**\r\n * @class OrgItemConfig\r\n * @classdesc Item Configuration Object defines properties of individual node in the organizational chart hierarchy. See `items` collection property\r\n * of organizational chart control configuration object. \r\n * \r\n * @param {OrgItemConfig} arg0 Item config properties\r\n * \r\n * @param {string} arg0 Item id\r\n * @param {string} arg1 Parent id\r\n * @param {string} arg2 Title\r\n * @param {string} arg3 Description \r\n * @param {string} arg4 Image\r\n */\r\nexport default function OrgItemConfig(arg0, arg1, arg2, arg3, arg4) {\r\n  var property;\r\n  /**\r\n   * Item id. It should be unique per chart.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.id = null;\r\n\r\n  /**\r\n   * Parent item id. If `null` then node is the root item of the hierarchy.\r\n   * @type {string}\r\n   */\r\n  this.parent = null;\r\n\r\n  /**\r\n   * Title\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.title = null;\r\n\r\n  /**\r\n   * Description\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.description = null;\r\n\r\n  /**\r\n   * Image\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.image = null;\r\n\r\n  /**\r\n   * Context object\r\n   * \r\n   * @group Template\r\n   * @type {object}\r\n   */\r\n  this.context = null;\r\n\r\n  /**\r\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.itemTitleColor = Colors.RoyalBlue;\r\n\r\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for individual node.\r\n   * \r\n   * @group Template\r\n   * @type {ShapeType}\r\n   */\r\n  this.minimizedItemShapeType = null;\r\n\r\n  /**\r\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\r\n   * It gives extra dimension for nodes visual grouping in the diagram.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\r\n  this.groupTitle = null;\r\n\r\n  /**\r\n   * The group title background color.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\r\n  this.groupTitleColor = Colors.RoyalBlue;\r\n\r\n  /**\r\n   * If `false` it makes item invisible in the layout. If item has no visible parents then its connections are hidden as well.\r\n   * From navigation perspective invisible items make all their children to be children of their parents.\r\n   * \r\n   * @type {boolean}\r\n   */\r\n  this.isVisible = true;\r\n\r\n  /**\r\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\r\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\r\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\r\n   * indicating that upon reaching them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\r\n  this.isActive = true;\r\n\r\n  /**\r\n   * Shows selection check box for the node.\r\n   * If Auto then selection check box visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasSelectorCheckbox` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @type {Enabled}\r\n   */\r\n  this.hasSelectorCheckbox = Enabled.Auto;\r\n\r\n  /**\r\n   * Shows context buttons panel for the node.\r\n   * If Auto then context buttons panel visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasButtons` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @group Template\r\n   * @type {Enabled}\r\n   */\r\n  this.hasButtons = Enabled.Auto;\r\n\r\n  /**\r\n   * Item type. This property defines child node placement relative to its parent node. By default all children that belong \r\n   * to a parent node are of the same rank and status between each other and due to that, are always aligned below\r\n   * the parent and are organized in the same way. However for special cases were the end user wishes to have a child\r\n   * that is separate from the rest of it's siblings, we provide custom child types that the end user can use to\r\n   * place different ranking nodes anywhere around the parent node. These placement options give a lot of space for\r\n   * the creation of roles such as an Assistant, Adviser, various Partners and co-heads that may be in the organization.\r\n   * Additionally, by default `Regular` children are always placed in a horizontal line below the parent node.\r\n   * \r\n   * @type {ItemType}\r\n   */\r\n  this.itemType = ItemType.Regular;\r\n\r\n  /**\r\n   * Sets node level offset relative to parent node. This property is ignored if it is not applicable.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.levelOffset = null;\r\n\r\n  /**\r\n   * Defines leftward or rightward item placement relative to the parent item.\r\n   * By default it is `Auto` and depends on general diagram layout orientation.\r\n   *  \r\n   * @type {AdviserPlacementType}\r\n   */\r\n  this.adviserPlacementType = AdviserPlacementType.Auto;\r\n\r\n  /**\r\n   * The property defines children's layout formation. By default, control places children\r\n   * in a horizontal line below the parent node. On a large scale, this may result in the end-user\r\n   * having to scroll screens to view all nodes. To compensate for this, we place children \r\n   * in a square/matrix formation. That will reduce sideways screen scrolling by compacting\r\n   * the child nodes into a much smaller area on the screen.\r\n   *   \r\n   * @type {ChildrenPlacementType}\r\n   */\r\n  this.childrenPlacementType = ChildrenPlacementType.Auto;\r\n\r\n  /**\r\n   * The property sets the default placement of assistants hierarchies relative to the regular \r\n   * children of the node. If the assistant node has its children, then control adds extra levels,\r\n   * so the assistant's children are placed above the regular children.\r\n   * \r\n   * @type {Enabled}\r\n   */\r\n  this.placeAssistantsAboveChildren = Enabled.Auto;\r\n\r\n  /**\r\n   * The property sets default placement of advisers hierarchies relative to the regular \r\n   * children of the node. If the adviser node has its children, then control adds extra levels,\r\n   * so the adviser's children are placed above the regular children.\r\n   * \r\n   * @type {Enabled}\r\n   */\r\n  this.placeAdvisersAboveChildren = Enabled.Auto;\r\n\r\n  /**\r\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * This option lets individually assign rendering template per individual node of the diagram.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.templateName = null;\r\n\r\n  /**\r\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\r\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\r\n   * current template of the node it is rendered for.\r\n   * \r\n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\r\n   * to change their template.\r\n   * \r\n   * Auto - depends on `showCallout` property of the control\r\n   * True - shown regardless of node's visibility\r\n   * False - hidden\r\n   * \r\n   * @group Callout\r\n   * @type {Enabled}\r\n   */\r\n  this.showCallout = Enabled.Auto;\r\n\r\n  /**\r\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\r\n   * per individual node of the diagram.\r\n   * \r\n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * \r\n   * @group Callout\r\n   * @type {string}\r\n   */\r\n  this.calloutTemplateName = null;\r\n\r\n  /**\r\n   * Marker label.\r\n   * \r\n   * @group Label\r\n   * @type {string}\r\n   */\r\n  this.label = null;\r\n\r\n  /**\r\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \r\n   * \r\n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\r\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\r\n   * \r\n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\r\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\r\n   * is going to stay visible.\r\n   * \r\n   * Auto - displays label only when it has space to be rendered.\r\n   * True - shows label regardless, even if it overlaps other labels and nodes.\r\n   * False - hidden.\r\n   * \r\n   * @group Label\r\n   * @type {Enabled}\r\n   */\r\n  this.showLabel = Enabled.Auto;\r\n\r\n  /**\r\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\r\n   * If `null` then it is set to `labelSize` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {Size}\r\n   */\r\n  this.labelSize = null;\r\n\r\n  /**\r\n   * Label orientation.\r\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {TextOrientationType}\r\n   */\r\n  this.labelOrientation = TextOrientationType.Auto;\r\n\r\n  /**\r\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\r\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {PlacementType}\r\n   */\r\n  this.labelPlacement = PlacementType.Auto;\r\n\r\n  switch (arguments.length) {\r\n    case 1:\r\n      for (property in arg0) {\r\n        if (arg0.hasOwnProperty(property)) {\r\n          this[property] = arg0[property];\r\n        }\r\n      }\r\n      break;\r\n    case 5:\r\n      this.id = arg0;\r\n      this.parent = arg1;\r\n      this.title = arg2;\r\n      this.description = arg3;\r\n      this.image = arg4;\r\n      break;\r\n  }\r\n};\r\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,0BAA0B;AAC3C,SAASC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,oBAAoB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,aAAa,QAAQ,UAAU;;AAErI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAClE,IAAIC,QAAQ;EACZ;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,EAAE,GAAG,IAAI;;EAEd;AACF;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,IAAI;;EAElB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI;;EAEvB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG,IAAI;;EAEnB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGpB,MAAM,CAACqB,SAAS;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAG,IAAI;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;;EAEtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGxB,MAAM,CAACqB,SAAS;;EAEvC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,SAAS,GAAG,IAAI;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG1B,OAAO,CAAC2B,IAAI;;EAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG5B,OAAO,CAAC2B,IAAI;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACE,QAAQ,GAAG5B,QAAQ,CAAC6B,OAAO;;EAEhC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI;;EAEvB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAG9B,oBAAoB,CAACyB,IAAI;;EAErD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACM,qBAAqB,GAAG9B,qBAAqB,CAACwB,IAAI;;EAEvD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACO,4BAA4B,GAAGlC,OAAO,CAAC2B,IAAI;;EAEhD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACQ,0BAA0B,GAAGnC,OAAO,CAAC2B,IAAI;;EAE9C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACS,YAAY,GAAG,IAAI;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAGrC,OAAO,CAAC2B,IAAI;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACW,mBAAmB,GAAG,IAAI;;EAE/B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,SAAS,GAAGxC,OAAO,CAAC2B,IAAI;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACc,SAAS,GAAG,IAAI;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAGtC,mBAAmB,CAACuB,IAAI;;EAEhD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACgB,cAAc,GAAGtC,aAAa,CAACsB,IAAI;EAExC,QAAQiB,SAAS,CAACC,MAAM;IACtB,KAAK,CAAC;MACJ,KAAKjC,QAAQ,IAAIL,IAAI,EAAE;QACrB,IAAIA,IAAI,CAACuC,cAAc,CAAClC,QAAQ,CAAC,EAAE;UACjC,IAAI,CAACA,QAAQ,CAAC,GAAGL,IAAI,CAACK,QAAQ,CAAC;QACjC;MACF;MACA;IACF,KAAK,CAAC;MACJ,IAAI,CAACC,EAAE,GAAGN,IAAI;MACd,IAAI,CAACO,MAAM,GAAGN,IAAI;MAClB,IAAI,CAACO,KAAK,GAAGN,IAAI;MACjB,IAAI,CAACO,WAAW,GAAGN,IAAI;MACvB,IAAI,CAACO,KAAK,GAAGN,IAAI;MACjB;EACJ;AACF;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}