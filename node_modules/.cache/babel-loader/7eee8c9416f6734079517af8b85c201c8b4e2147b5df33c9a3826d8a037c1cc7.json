{"ast":null,"code":"import Graph from '../../algorithms/Graph';\nimport EdgeItem from '../../models/EdgeItem';\nimport FamilyItem from '../../models/FamilyItem';\nimport { GroupByType } from '../../enums';\nexport default function AddLabelAnnotationsTask(labelAnnotationPlacementOptionTask, removeLoopsTask) {\n  var _data = {\n    logicalFamily: null,\n    maximumId: null\n  };\n  function process(debug) {\n    var logicalFamily = removeLoopsTask.getLogicalFamily(),\n      annotations = labelAnnotationPlacementOptionTask.getAnnotations();\n    logicalFamily = logicalFamily.clone();\n    addLabelAnnotations(logicalFamily, annotations);\n    _data.logicalFamily = logicalFamily;\n    _data.maximumId = labelAnnotationPlacementOptionTask.getMaximumId();\n    if (debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n    return true;\n  }\n  function addLabelAnnotations(logicalFamily, annotations) {\n    var edges = Graph(),\n      /* edge item is new EdgeItem(fromItem, toItem); */\n      configsHash = {},\n      configs,\n      config,\n      fromItem,\n      index,\n      len;\n    if (annotations.length > 0) {\n      /* group annotations by from item */\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        config = annotations[index];\n        if (!configsHash.hasOwnProperty(config.fromItem)) {\n          configsHash[config.fromItem] = [config];\n\n          /* create edges hash for item */\n          logicalFamily.loopChildren(this, config.fromItem, function (childid, child, level) {\n            edges.addEdge(config.fromItem, childid, new EdgeItem(config.fromItem, config.fromItem, childid, childid));\n            return logicalFamily.SKIP;\n          }); //ignore jslint\n          logicalFamily.loopParents(this, config.fromItem, function (parentid, parent, level) {\n            edges.addEdge(parentid, config.fromItem, new EdgeItem(parentid, parentid, config.fromItem, config.fromItem));\n            return logicalFamily.SKIP;\n          }); //ignore jslint\n        } else {\n          configsHash[config.fromItem].push(config);\n        }\n      }\n      for (fromItem in configsHash) {\n        if (configsHash.hasOwnProperty(fromItem)) {\n          configs = configsHash[fromItem];\n\n          /* process annotations having greater number of references first */\n          configs.sort(function (a, b) {\n            return b.toItems.length - a.toItems.length;\n          }); //ignore jslint\n\n          for (index = 0; index < configs.length; index += 1) {\n            config = configs[index];\n            addLabelAnnotation(logicalFamily, edges, config.fromItem, config.toItems, function () {\n              /* add label annotation as new diagram family item */\n              return new FamilyItem({\n                id: config.id,\n                isVisible: true,\n                isLevelNeutral: true,\n                isActive: false,\n                itemConfig: config\n              });\n            }); //ignore jslint\n          }\n        }\n      }\n    }\n  }\n  function addLabelAnnotation(logicalFamily, edges, fromItem, toItems, onCreate) {\n    var edge,\n      isValid = true,\n      commonParentId = null,\n      toItem,\n      index,\n      len,\n      bundleItem,\n      bundleItems = [];\n    for (index = 0, len = toItems.length; index < len; index += 1) {\n      toItem = toItems[index];\n      edge = edges.edge(fromItem, toItem);\n      if (edge != null) {\n        if (commonParentId == null) {\n          commonParentId = edge.getFar(toItem);\n        } else {\n          if (commonParentId != edge.getFar(toItem)) {\n            isValid = false;\n            break;\n          }\n        }\n        bundleItems.push(edge.getNear(toItem));\n      } else {\n        isValid = false;\n        break;\n      }\n    }\n    if (isValid) {\n      bundleItem = onCreate();\n      if (logicalFamily.bundleParents(commonParentId, bundleItems, bundleItem.id, bundleItem)) {\n        bundleItem.levelGravity = GroupByType.Children;\n        isValid = true;\n      } else if (logicalFamily.bundleChildren(commonParentId, bundleItems, bundleItem.id, bundleItem)) {\n        bundleItem.levelGravity = GroupByType.Parents;\n        isValid = true;\n      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {\n        bundleItem.levelGravity = GroupByType.Children;\n        isValid = true;\n      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {\n        bundleItem.levelGravity = GroupByType.Parents;\n        isValid = true;\n      }\n      if (isValid) {\n        for (index = 0, len = toItems.length; index < len; index += 1) {\n          toItem = toItems[index];\n          edge = edges.edge(fromItem, toItem);\n          edge.setFar(toItem, bundleItem.id);\n        }\n      }\n    }\n  }\n  function getLogicalFamily() {\n    return _data.logicalFamily;\n  }\n  function getMaximumId() {\n    return _data.maximumId;\n  }\n  return {\n    process: process,\n    getLogicalFamily: getLogicalFamily,\n    getMaximumId: getMaximumId\n  };\n}\n;","map":{"version":3,"names":["Graph","EdgeItem","FamilyItem","GroupByType","AddLabelAnnotationsTask","labelAnnotationPlacementOptionTask","removeLoopsTask","_data","logicalFamily","maximumId","process","debug","getLogicalFamily","annotations","getAnnotations","clone","addLabelAnnotations","getMaximumId","validate","edges","configsHash","configs","config","fromItem","index","len","length","hasOwnProperty","loopChildren","childid","child","level","addEdge","SKIP","loopParents","parentid","parent","push","sort","a","b","toItems","addLabelAnnotation","id","isVisible","isLevelNeutral","isActive","itemConfig","onCreate","edge","isValid","commonParentId","toItem","bundleItem","bundleItems","getFar","getNear","bundleParents","levelGravity","Children","bundleChildren","Parents","setFar"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/tasks/transformations/AddLabelAnnotationsTask.js"],"sourcesContent":["import Graph from '../../algorithms/Graph';\r\nimport EdgeItem from '../../models/EdgeItem';\r\nimport FamilyItem from '../../models/FamilyItem';\r\nimport { GroupByType } from '../../enums';\r\n\r\nexport default function AddLabelAnnotationsTask(labelAnnotationPlacementOptionTask, removeLoopsTask) {\r\n  var _data = {\r\n    logicalFamily: null,\r\n    maximumId: null\r\n  };\r\n\r\n  function process(debug) {\r\n    var logicalFamily = removeLoopsTask.getLogicalFamily(),\r\n      annotations = labelAnnotationPlacementOptionTask.getAnnotations();\r\n\r\n    logicalFamily = logicalFamily.clone();\r\n\r\n    addLabelAnnotations(logicalFamily, annotations);\r\n\r\n    _data.logicalFamily = logicalFamily;\r\n\r\n    _data.maximumId = labelAnnotationPlacementOptionTask.getMaximumId();\r\n\r\n    if (debug && !logicalFamily.validate()) {\r\n      throw \"References are broken in family structure!\";\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function addLabelAnnotations(logicalFamily, annotations) {\r\n    var edges = Graph(), /* edge item is new EdgeItem(fromItem, toItem); */\r\n      configsHash = {},\r\n      configs, config,\r\n      fromItem,\r\n      index, len;\r\n\r\n    if (annotations.length > 0) {\r\n      /* group annotations by from item */\r\n      for (index = 0, len = annotations.length; index < len; index += 1) {\r\n        config = annotations[index];\r\n        if (!configsHash.hasOwnProperty(config.fromItem)) {\r\n          configsHash[config.fromItem] = [config];\r\n\r\n          /* create edges hash for item */\r\n          logicalFamily.loopChildren(this, config.fromItem, function (childid, child, level) {\r\n            edges.addEdge(config.fromItem, childid, new EdgeItem(config.fromItem, config.fromItem, childid, childid));\r\n            return logicalFamily.SKIP;\r\n          });//ignore jslint\r\n          logicalFamily.loopParents(this, config.fromItem, function (parentid, parent, level) {\r\n            edges.addEdge(parentid, config.fromItem, new EdgeItem(parentid, parentid, config.fromItem, config.fromItem));\r\n            return logicalFamily.SKIP;\r\n          });//ignore jslint\r\n\r\n        } else {\r\n          configsHash[config.fromItem].push(config);\r\n        }\r\n      }\r\n\r\n      for (fromItem in configsHash) {\r\n        if (configsHash.hasOwnProperty(fromItem)) {\r\n          configs = configsHash[fromItem];\r\n\r\n          /* process annotations having greater number of references first */\r\n          configs.sort(function (a, b) {\r\n            return b.toItems.length - a.toItems.length;\r\n          }); //ignore jslint\r\n\r\n\r\n          for (index = 0; index < configs.length; index += 1) {\r\n            config = configs[index];\r\n\r\n            addLabelAnnotation(logicalFamily, edges, config.fromItem, config.toItems, function () {\r\n              /* add label annotation as new diagram family item */\r\n              return new FamilyItem({\r\n                id: config.id,\r\n                isVisible: true,\r\n                isLevelNeutral: true,\r\n                isActive: false,\r\n                itemConfig: config\r\n              });\r\n            }); //ignore jslint\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function addLabelAnnotation(logicalFamily, edges, fromItem, toItems, onCreate) {\r\n    var edge,\r\n      isValid = true,\r\n      commonParentId = null,\r\n      toItem,\r\n      index, len,\r\n      bundleItem,\r\n      bundleItems = [];\r\n\r\n    for (index = 0, len = toItems.length; index < len; index += 1) {\r\n      toItem = toItems[index];\r\n\r\n      edge = edges.edge(fromItem, toItem);\r\n      if (edge != null) {\r\n        if (commonParentId == null) {\r\n          commonParentId = edge.getFar(toItem);\r\n        } else {\r\n          if (commonParentId != edge.getFar(toItem)) {\r\n            isValid = false;\r\n            break;\r\n          }\r\n        }\r\n        bundleItems.push(edge.getNear(toItem));\r\n      } else {\r\n        isValid = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (isValid) {\r\n      bundleItem = onCreate();\r\n      if (logicalFamily.bundleParents(commonParentId, bundleItems, bundleItem.id, bundleItem)) {\r\n        bundleItem.levelGravity = GroupByType.Children;\r\n        isValid = true;\r\n      } else if (logicalFamily.bundleChildren(commonParentId, bundleItems, bundleItem.id, bundleItem)) {\r\n        bundleItem.levelGravity = GroupByType.Parents;\r\n        isValid = true;\r\n      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {\r\n        bundleItem.levelGravity = GroupByType.Children;\r\n        isValid = true;\r\n      } else if (logicalFamily.bundleParents(commonParentId, toItems, bundleItem.id, bundleItem)) {\r\n        bundleItem.levelGravity = GroupByType.Parents;\r\n        isValid = true;\r\n      }\r\n\r\n      if (isValid) {\r\n        for (index = 0, len = toItems.length; index < len; index += 1) {\r\n          toItem = toItems[index];\r\n\r\n          edge = edges.edge(fromItem, toItem);\r\n          edge.setFar(toItem, bundleItem.id);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function getLogicalFamily() {\r\n    return _data.logicalFamily;\r\n  }\r\n\r\n  function getMaximumId() {\r\n    return _data.maximumId;\r\n  }\r\n\r\n  return {\r\n    process: process,\r\n    getLogicalFamily: getLogicalFamily,\r\n    getMaximumId: getMaximumId\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}