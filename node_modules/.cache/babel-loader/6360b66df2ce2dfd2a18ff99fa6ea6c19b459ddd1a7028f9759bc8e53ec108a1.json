{"ast":null,"code":"/**\r\n * Creates pile structure used to sort and stack segments on top of each other \r\n * so they occupy minimum number of rows.\r\n * @class Pile\r\n * \r\n * @returns {Pile} Returns pile structure\r\n */\nexport default function Pile() {\n  var _items = [];\n\n  /**\r\n   * Adds new segment to pile object.\r\n   * \r\n   * @param {number} from Left margin of segment.\r\n   * @param {number} to Right margin of segment.\r\n   * @param {object} context Any reference to user object. It is returned as parameter in callback function of resolve method.\r\n   */\n  function add(from, to, context) {\n    if (from < to) {\n      _items.push(new Segment(from, to, context, 1));\n    } else {\n      _items.push(new Segment(to, from, context, -1));\n    }\n  }\n\n  /**\r\n   * Callback function or iterating result offsets of the pile items in the stack.\r\n   * \r\n   * @callback onPileItemCallback\r\n   * @param {number} from The left margin of the segment \r\n   * @param {number} to The right margin of the segment\r\n   * @param {object} context The context of the pile item\r\n   * @param {number} offset Index of the pile item in the stack\r\n   */\n\n  /**\r\n   * Sorts and stack segments on top of each other so they occupy minimum number of rows.\r\n   * \r\n   * @param {object} thisArg A context object of the callback function invocation.\r\n   * @param {onPileItemCallback} onItem Callback function for setting segments offsets in the pile.\r\n   * @returns {number} Number of stacked rows in pile.\r\n   */\n  function resolve(thisArg, onItem) {\n    var hash,\n      backtraceNext,\n      backtraceTaken,\n      items,\n      item,\n      rowItems,\n      rows,\n      rowIndex,\n      index,\n      offset = 0;\n    if (onItem != null) {\n      items = _items.slice(0);\n      items.sort(function (a, b) {\n        return a.from - b.from;\n      });\n      rows = [];\n      while (items.length > 0) {\n        hash = {};\n        backtraceNext = {};\n        backtraceTaken = {};\n        getMax(0, items, hash, backtraceNext, backtraceTaken);\n        rowItems = [];\n        rows[offset] = [];\n        index = 0;\n        while (backtraceNext.hasOwnProperty(index)) {\n          if (backtraceTaken[index]) {\n            rowItems.push(index);\n            rows[offset].push(items[index]);\n          }\n          index = backtraceNext[index];\n        }\n        for (index = rowItems.length - 1; index >= 0; index -= 1) {\n          items.splice(rowItems[index], 1);\n        }\n        offset += 1;\n      }\n      for (rowIndex = 0; rowIndex < offset; rowIndex += 1) {\n        rowItems = rows[rowIndex];\n        for (index = 0; index < rowItems.length; index += 1) {\n          item = rowItems[index];\n          if (onItem.call(thisArg, item.from, item.to, item.context, rowIndex, offset, item.direction)) {\n            return offset;\n          }\n        }\n      }\n    }\n    return offset;\n  }\n  function Segment(from, to, context, direction) {\n    this.context = context;\n    this.from = from;\n    this.to = to;\n    this.offset = null;\n    this.direction = direction;\n  }\n  function getMax(index, items, hash, backtraceNext, backtraceTaken) {\n    var result = 0;\n    if (index >= items.length) {\n      return 0;\n    }\n    if (hash.hasOwnProperty(index)) {\n      return hash[index];\n    }\n    var item = items[index];\n    var withoutItem = getMax(index + 1, items, hash, backtraceNext, backtraceTaken);\n    var nextIndex = index + 1;\n    while (nextIndex < items.length) {\n      var nextItem = items[nextIndex];\n      if (nextItem.from >= item.to) {\n        break;\n      }\n      nextIndex += 1;\n    }\n    var withItem = 1 + getMax(nextIndex, items, hash, backtraceNext, backtraceTaken);\n    if (withItem > withoutItem) {\n      hash[index] = withItem;\n      backtraceNext[index] = nextIndex;\n      backtraceTaken[index] = true;\n    } else {\n      hash[index] = withoutItem;\n      backtraceNext[index] = index + 1;\n      backtraceTaken[index] = false;\n    }\n    return hash[index];\n  }\n  return {\n    add: add,\n    resolve: resolve\n  };\n}\n;","map":{"version":3,"names":["Pile","_items","add","from","to","context","push","Segment","resolve","thisArg","onItem","hash","backtraceNext","backtraceTaken","items","item","rowItems","rows","rowIndex","index","offset","slice","sort","a","b","length","getMax","hasOwnProperty","splice","call","direction","result","withoutItem","nextIndex","nextItem","withItem"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/Pile.js"],"sourcesContent":["/**\r\n * Creates pile structure used to sort and stack segments on top of each other \r\n * so they occupy minimum number of rows.\r\n * @class Pile\r\n * \r\n * @returns {Pile} Returns pile structure\r\n */\r\nexport default function Pile () {\r\n  var _items = [];\r\n\r\n  /**\r\n   * Adds new segment to pile object.\r\n   * \r\n   * @param {number} from Left margin of segment.\r\n   * @param {number} to Right margin of segment.\r\n   * @param {object} context Any reference to user object. It is returned as parameter in callback function of resolve method.\r\n   */\r\n  function add(from, to, context) {\r\n    if (from < to) {\r\n      _items.push(new Segment(from, to, context, 1));\r\n    } else {\r\n      _items.push(new Segment(to, from, context, -1));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function or iterating result offsets of the pile items in the stack.\r\n   * \r\n   * @callback onPileItemCallback\r\n   * @param {number} from The left margin of the segment \r\n   * @param {number} to The right margin of the segment\r\n   * @param {object} context The context of the pile item\r\n   * @param {number} offset Index of the pile item in the stack\r\n   */\r\n\r\n  /**\r\n   * Sorts and stack segments on top of each other so they occupy minimum number of rows.\r\n   * \r\n   * @param {object} thisArg A context object of the callback function invocation.\r\n   * @param {onPileItemCallback} onItem Callback function for setting segments offsets in the pile.\r\n   * @returns {number} Number of stacked rows in pile.\r\n   */\r\n  function resolve(thisArg, onItem) {\r\n    var hash,\r\n      backtraceNext,\r\n      backtraceTaken,\r\n      items, item,\r\n      rowItems,\r\n      rows,\r\n      rowIndex, index,\r\n      offset = 0;\r\n\r\n    if (onItem != null) {\r\n      items = _items.slice(0);\r\n      items.sort(function (a, b) {\r\n        return a.from - b.from;\r\n      });\r\n\r\n      rows = [];\r\n      while (items.length > 0) {\r\n        hash = {};\r\n        backtraceNext = {};\r\n        backtraceTaken = {};\r\n\r\n        getMax(0, items, hash, backtraceNext, backtraceTaken);\r\n\r\n        rowItems = [];\r\n        rows[offset] = [];\r\n        index = 0;\r\n        while (backtraceNext.hasOwnProperty(index)) {\r\n          if (backtraceTaken[index]) {\r\n            rowItems.push(index);\r\n\r\n            rows[offset].push(items[index]);\r\n          }\r\n          index = backtraceNext[index];\r\n        }\r\n\r\n        for (index = rowItems.length - 1; index >= 0; index -= 1) {\r\n          items.splice(rowItems[index], 1);\r\n        }\r\n        offset += 1;\r\n      }\r\n\r\n      for (rowIndex = 0; rowIndex < offset; rowIndex += 1) {\r\n        rowItems = rows[rowIndex];\r\n        for (index = 0; index < rowItems.length; index += 1) {\r\n          item = rowItems[index];\r\n          if (onItem.call(thisArg, item.from, item.to, item.context, rowIndex, offset, item.direction)) {\r\n            return offset;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return offset;\r\n  }\r\n\r\n  function Segment(from, to, context, direction) {\r\n    this.context = context;\r\n    this.from = from;\r\n    this.to = to;\r\n    this.offset = null;\r\n    this.direction = direction;\r\n  }\r\n\r\n  function getMax(index, items, hash, backtraceNext, backtraceTaken) {\r\n    var result = 0;\r\n\r\n    if (index >= items.length) {\r\n      return 0;\r\n    }\r\n\r\n    if (hash.hasOwnProperty(index)) {\r\n      return hash[index];\r\n    }\r\n\r\n    var item = items[index];\r\n    var withoutItem = getMax(index + 1, items, hash, backtraceNext, backtraceTaken);\r\n\r\n    var nextIndex = index + 1;\r\n    while (nextIndex < items.length) {\r\n      var nextItem = items[nextIndex];\r\n      if (nextItem.from >= item.to) {\r\n        break;\r\n      }\r\n      nextIndex += 1;\r\n    }\r\n    var withItem = 1 + getMax(nextIndex, items, hash, backtraceNext, backtraceTaken);\r\n\r\n    if (withItem > withoutItem) {\r\n      hash[index] = withItem;\r\n      backtraceNext[index] = nextIndex;\r\n      backtraceTaken[index] = true;\r\n    } else {\r\n      hash[index] = withoutItem;\r\n      backtraceNext[index] = index + 1;\r\n      backtraceTaken[index] = false;\r\n    }\r\n\r\n    return hash[index];\r\n  }\r\n\r\n  return {\r\n    add: add,\r\n    resolve: resolve\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}