{"ast":null,"code":"import getLiniarBreaks from './getLiniarBreaks';\nimport QuadTree from './QuadTree';\nimport Rect from '../graphics/structs/Rect';\n/**\r\n * Create spatial index structure. It uses collection of sizes to distribute \r\n * rectangles into buckets of similar size elements. Elements of the same bucket \r\n * are approximated to points. The search of rectangles is transformed to search of points \r\n * within given range plus offset for maximum linear rectangle size.\r\n * \r\n * @class SpatialIndex\r\n * \r\n * @param {Array} sizes Reference to optional collection of possible sizes of items we plan to store\r\n * in the index\r\n * \r\n * @returns {SpatialIndex} Returns spacial index data structure.\r\n */\nexport default function SpatialIndex(sizes) {\n  var _buckets = [];\n  sizes.sort(function (a, b) {\n    return a - b;\n  });\n  switch (sizes.length) {\n    case 0:\n      _buckets.push(new Bucket(0, 1000000));\n      break;\n    case 1:\n      var size1 = sizes[0];\n      _buckets.push(new Bucket(0, size1));\n      break;\n    case 2:\n      size1 = sizes[0];\n      var size2 = sizes[1];\n      if (size2 > size1 * 2) {\n        _buckets.push(new Bucket(0, size1));\n        _buckets.push(new Bucket(size1, size2));\n      } else {\n        _buckets.push(new Bucket(0, size2));\n      }\n      break;\n    default:\n      var breaks = getLiniarBreaks(sizes);\n      var minimum = 0;\n      for (var index = 0; index < breaks.length; index += 1) {\n        var maximum = sizes[breaks[index]];\n        _buckets.push(new Bucket(minimum, maximum));\n        minimum = maximum;\n      }\n      break;\n  }\n  function Bucket(minimum, maximum) {\n    this.minimum = minimum;\n    this.maximum = maximum;\n    this.quadTree = QuadTree(maximum * 2);\n  }\n\n  /**\r\n   * Adds rectangle to spacial index\r\n   * @param {Rect} rect Rectangle\r\n   */\n  function addRect(rect) {\n    var size = Math.max(rect.width, rect.height);\n    var point = rect.centerPoint();\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n      if (size <= bucket.maximum || index == len - 1) {\n        point.context = rect;\n        bucket.quadTree.addPoint(point);\n        break;\n      }\n    }\n  }\n\n  /**\r\n   * Callback function for iteration of spacial index rectangles\r\n   * \r\n   * @callback onSpatialIndexItemCallback\r\n   * @param {React} rect Rectangle\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops rectangular area of spacial index\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {Rect} rect Rectangular search area\r\n   * @param {onSpatialIndexItemCallback} onItem Callback function to call for every rectangle intersecting given rectangular search area\r\n   */\n  function loopArea(thisArg, rect, onItem) {\n    // onItem = function(itemid) {}\n    if (onItem != null) {\n      for (var index = 0, len = _buckets.length; index < len; index += 1) {\n        var bucket = _buckets[index];\n        var bucketRect = new Rect(rect);\n        bucketRect.offset(bucket.maximum / 2.0);\n        bucket.quadTree.loopArea(this, bucketRect, function (point) {\n          var pointRect = point.context;\n          if (rect.overlaps(pointRect)) {\n            return onItem.call(thisArg, pointRect);\n          }\n        });\n      }\n    }\n  }\n\n  /**\r\n   * Validates internal data consistency of spacial index data structure\r\n   * \r\n   * @ignore\r\n   * @returns {boolean} Returns true if structure pass validation\r\n   */\n  function validate() {\n    var result = true;\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n      result = result && bucket.quadTree.validate();\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns collection of quadrants created in spacial index\r\n   * Quadrants exists only when elements exists in them.\r\n   * This method is used for visual debugging of the structure.\r\n   * \r\n   * @ignore\r\n   * @param {React} selection Rectangular test area to highlight quadrants\r\n   * @returns {Rect[]} Returns collection of available quadrants.\r\n   * Quadrants containing points within selection area have context.highlight property set to true.\r\n   */\n  function getPositions(selection) {\n    var result = [];\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n      result = result.concat(bucket.quadTree.getPositions(selection));\n    }\n    return result;\n  }\n  return {\n    addRect: addRect,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n}\n;","map":{"version":3,"names":["getLiniarBreaks","QuadTree","Rect","SpatialIndex","sizes","_buckets","sort","a","b","length","push","Bucket","size1","size2","breaks","minimum","index","maximum","quadTree","addRect","rect","size","Math","max","width","height","point","centerPoint","len","bucket","context","addPoint","loopArea","thisArg","onItem","bucketRect","offset","pointRect","overlaps","call","validate","result","getPositions","selection","concat"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/SpatialIndex.js"],"sourcesContent":["import getLiniarBreaks from './getLiniarBreaks';\r\nimport QuadTree from './QuadTree';\r\nimport Rect from '../graphics/structs/Rect';\r\n/**\r\n * Create spatial index structure. It uses collection of sizes to distribute \r\n * rectangles into buckets of similar size elements. Elements of the same bucket \r\n * are approximated to points. The search of rectangles is transformed to search of points \r\n * within given range plus offset for maximum linear rectangle size.\r\n * \r\n * @class SpatialIndex\r\n * \r\n * @param {Array} sizes Reference to optional collection of possible sizes of items we plan to store\r\n * in the index\r\n * \r\n * @returns {SpatialIndex} Returns spacial index data structure.\r\n */\r\nexport default function SpatialIndex(sizes) {\r\n  var _buckets = [];\r\n\r\n  sizes.sort(function (a, b) { return a - b; });\r\n\r\n  switch (sizes.length) {\r\n    case 0:\r\n      _buckets.push(new Bucket(0, 1000000));\r\n      break;\r\n    case 1:\r\n      var size1 = sizes[0];\r\n      _buckets.push(new Bucket(0, size1));\r\n      break;\r\n    case 2:\r\n      size1 = sizes[0];\r\n      var size2 = sizes[1];\r\n      if (size2 > size1 * 2) {\r\n        _buckets.push(new Bucket(0, size1));\r\n        _buckets.push(new Bucket(size1, size2));\r\n      } else {\r\n        _buckets.push(new Bucket(0, size2));\r\n      }\r\n      break;\r\n    default:\r\n      var breaks = getLiniarBreaks(sizes);\r\n      var minimum = 0;\r\n      for (var index = 0; index < breaks.length; index += 1) {\r\n        var maximum = sizes[breaks[index]];\r\n        _buckets.push(new Bucket(minimum, maximum));\r\n        minimum = maximum;\r\n      }\r\n      break;\r\n  }\r\n\r\n  function Bucket(minimum, maximum) {\r\n    this.minimum = minimum;\r\n    this.maximum = maximum;\r\n    this.quadTree = QuadTree(maximum * 2);\r\n  }\r\n\r\n  /**\r\n   * Adds rectangle to spacial index\r\n   * @param {Rect} rect Rectangle\r\n   */\r\n  function addRect(rect) {\r\n    var size = Math.max(rect.width, rect.height);\r\n    var point = rect.centerPoint();\r\n\r\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\r\n      var bucket = _buckets[index];\r\n\r\n      if (size <= bucket.maximum || index == len - 1) {\r\n        point.context = rect;\r\n        bucket.quadTree.addPoint(point);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function for iteration of spacial index rectangles\r\n   * \r\n   * @callback onSpatialIndexItemCallback\r\n   * @param {React} rect Rectangle\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops rectangular area of spacial index\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {Rect} rect Rectangular search area\r\n   * @param {onSpatialIndexItemCallback} onItem Callback function to call for every rectangle intersecting given rectangular search area\r\n   */\r\n  function loopArea(thisArg, rect, onItem) { // onItem = function(itemid) {}\r\n    if (onItem != null) {\r\n      for (var index = 0, len = _buckets.length; index < len; index += 1) {\r\n        var bucket = _buckets[index];\r\n        var bucketRect = new Rect(rect);\r\n        bucketRect.offset(bucket.maximum / 2.0);\r\n        bucket.quadTree.loopArea(this, bucketRect, function (point) {\r\n          var pointRect = point.context;\r\n\r\n          if (rect.overlaps(pointRect)) {\r\n            return onItem.call(thisArg, pointRect);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates internal data consistency of spacial index data structure\r\n   * \r\n   * @ignore\r\n   * @returns {boolean} Returns true if structure pass validation\r\n   */\r\n  function validate() {\r\n    var result = true;\r\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\r\n      var bucket = _buckets[index];\r\n\r\n      result = result && bucket.quadTree.validate();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns collection of quadrants created in spacial index\r\n   * Quadrants exists only when elements exists in them.\r\n   * This method is used for visual debugging of the structure.\r\n   * \r\n   * @ignore\r\n   * @param {React} selection Rectangular test area to highlight quadrants\r\n   * @returns {Rect[]} Returns collection of available quadrants.\r\n   * Quadrants containing points within selection area have context.highlight property set to true.\r\n   */\r\n  function getPositions(selection) {\r\n    var result = [];\r\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\r\n      var bucket = _buckets[index];\r\n\r\n      result = result.concat(bucket.quadTree.getPositions(selection));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    addRect: addRect,\r\n    loopArea: loopArea,\r\n    validate: validate,\r\n    getPositions: getPositions\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}