{"ast":null,"code":"/**\r\n * Graph edge structure\r\n * @class Edge\r\n * @property {string} from From node id\r\n * @property {string} to To node id\r\n */\nexport function Edge(from, to) {\n  this.from = from;\n  this.to = to;\n}\n\n/**\r\n * This function finds [optimal collection of feedback edges](https://en.wikipedia.org/wiki/Feedback_arc_set) needed to be cut in \r\n * order to eliminate loops in family structure.\r\n * \r\n * @param {Family} family Family structure\r\n * @returns {Edge[]} Returns optimal collection of feedback loops \r\n */\nexport default function getFamilyLoops(family, debug) {\n  var loops = [],\n    loop,\n    index,\n    len,\n    index2,\n    len2,\n    fromNode,\n    toNode,\n    edge;\n  var tempFamily = family.clone();\n  family.loopTopo(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  });\n  family.loopTopoReversed(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  });\n  var cleanFamily = tempFamily.clone();\n  cleanFamily.loop(this, function (itemid) {\n    if (tempFamily.node(itemid) != null) {\n      tempFamily.loopParents(this, itemid, function (parentid) {\n        loops.push(new Edge(parentid, itemid));\n        tempFamily.removeChildRelation(parentid, itemid);\n        return tempFamily.SKIP;\n      });\n      var itemsToRemove = [];\n      tempFamily.loopTopo(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n      tempFamily.loopTopoReversed(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n      for (var index = 0; index < itemsToRemove.length; index += 1) {\n        tempFamily.removeNode(itemsToRemove[index]);\n      }\n    }\n  });\n\n  /* Invert loops */\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n    if (!cleanFamily.removeChildRelation(loop.from, loop.to)) {\n      throw \"Relation does not exists\";\n    }\n  }\n  if (debug && cleanFamily.hasLoops()) {\n    throw \"Failed to clean loops in family\";\n  }\n  var graph = cleanFamily.getGraph(this, function (from, to) {\n    return {\n      from: from,\n      to: to,\n      capacity: 1,\n      flow: 0\n    };\n  });\n  var from = \"__1000__\";\n  var to = \"__2000__\";\n  var defaultMinimalFlow = loops.length;\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n    edge = graph.edge(loop.from, to);\n    if (edge == null) {\n      graph.addEdge(loop.from, to, {\n        from: loop.from,\n        to: to,\n        capacity: 1,\n        flow: 0,\n        tos: [loop.to]\n      });\n    } else {\n      edge.capacity += 1;\n      edge.tos.push(loop.to);\n    }\n    edge = graph.edge(from, loop.to);\n    if (edge == null) {\n      graph.addEdge(from, loop.to, {\n        from: from,\n        to: loop.to,\n        capacity: 1,\n        flow: 0,\n        froms: [loop.from]\n      });\n    } else {\n      edge.capacity += 1;\n      edge.froms.push(loop.from);\n    }\n  }\n  var totalFlow = 0;\n  var levelGraph = null;\n  while (true) {\n    levelGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      } else {\n        return edge.flow > 0;\n      }\n    });\n    if (!levelGraph.hasNode(to)) {\n      break;\n    }\n    while (true) {\n      var connectionPath = graph.dfsPath(this, from, to, function (fromNode, toNode, edge) {\n        if (fromNode == edge.from) {\n          return edge.capacity > edge.flow;\n        } else {\n          return edge.flow > 0;\n        }\n      });\n      if (connectionPath.length == 0) {\n        break;\n      }\n\n      // Find maximum flow for given path\n      var flow = Infinity;\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n        var edgeFlow = 0;\n        if (edge.from == fromNode) {\n          edgeFlow = edge.capacity - edge.flow;\n        } else {\n          edgeFlow = edge.flow;\n        }\n        if (edgeFlow == 0) {\n          throw \"Broken flow path\";\n        }\n        flow = Math.min(flow, edgeFlow);\n      }\n\n      // Update graph\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n        if (edge.from == fromNode) {\n          edge.flow += flow;\n        } else {\n          edge.flow -= flow;\n        }\n      }\n      totalFlow += flow;\n    }\n  }\n  if (totalFlow < defaultMinimalFlow) {\n    var residueGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      }\n      return false;\n    });\n\n    // graph.loopNodes(this, from, function (nodeid) {\n    //   console.log(\"Nodeid: \" + nodeid);\n    //   graph.loopNodeEdges(this, nodeid, function (neighbour, edge) {\n    //     if (edge.to == neighbour) {\n    //       console.log(\"neighbour: \" + neighbour + \", edge=\" + JSON.stringify(edge));\n    //     }\n    //   })\n    // });\n\n    // var resedueNodes = [];\n    // residueGraph.loopNodes(this, from, function (nodeid) {\n    //   resedueNodes.push(nodeid);\n    // });\n    // console.log(\"Residue graph: \" + resedueNodes.join(\", \"));\n\n    var edgesToBreak = [];\n    residueGraph.loopNodes(this, from, function (nodeid) {\n      graph.loopNodeEdges(this, nodeid, function (toNode, edge) {\n        if (edge.to == toNode) {\n          if (!residueGraph.hasNode(toNode)) {\n            // console.log(\"Edge to test: from: \" + nodeid + \", to \" + toNode);\n            var isIsolated = false;\n            graph.dfsLoop(this, toNode, function (fromNode, toNode2, edge) {\n              if (edge.from == fromNode && !residueGraph.hasNode(fromNode)) {\n                return true;\n              }\n              return false;\n            }, function (foundid) {\n              if (foundid == to) {\n                // console.log(\"Isolated: \" + toNode + \", may access exit node\" + foundid);\n                isIsolated = true;\n                return true;\n              }\n              return false;\n            });\n            if (isIsolated) {\n              edgesToBreak.push(new Edge(nodeid, toNode));\n            }\n          }\n        }\n      });\n    });\n\n    // collect loops to break\n    var optimizedLoops = [];\n    var validatedFlow = 0;\n    for (index = 0, len = edgesToBreak.length; index < len; index += 1) {\n      var edgeToBreak = edgesToBreak[index];\n      if (edgeToBreak.from == from) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n        for (index2 = 0, len2 = edge.froms.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edge.froms[index2], edgeToBreak.to));\n          validatedFlow += 1;\n        }\n      } else if (edgeToBreak.to == to) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n        for (index2 = 0, len2 = edge.tos.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edgeToBreak.from, edge.tos[index2]));\n          validatedFlow += 1;\n        }\n      } else {\n        optimizedLoops.push(edgeToBreak);\n        validatedFlow += 1;\n      }\n    }\n    if (validatedFlow == totalFlow) {\n      loops = optimizedLoops;\n    }\n  }\n  return loops;\n}\n;","map":{"version":3,"names":["Edge","from","to","getFamilyLoops","family","debug","loops","loop","index","len","index2","len2","fromNode","toNode","edge","tempFamily","clone","loopTopo","itemid","removeNode","loopTopoReversed","cleanFamily","node","loopParents","parentid","push","removeChildRelation","SKIP","itemsToRemove","length","hasLoops","graph","getGraph","capacity","flow","defaultMinimalFlow","addEdge","tos","froms","totalFlow","levelGraph","getLevelGraph","hasNode","connectionPath","dfsPath","Infinity","edgeFlow","Math","min","residueGraph","edgesToBreak","loopNodes","nodeid","loopNodeEdges","isIsolated","dfsLoop","toNode2","foundid","optimizedLoops","validatedFlow","edgeToBreak"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/getFamilyLoops.js"],"sourcesContent":["/**\r\n * Graph edge structure\r\n * @class Edge\r\n * @property {string} from From node id\r\n * @property {string} to To node id\r\n */\r\nexport function Edge(from, to) {\r\n  this.from = from;\r\n  this.to = to;\r\n}\r\n\r\n/**\r\n * This function finds [optimal collection of feedback edges](https://en.wikipedia.org/wiki/Feedback_arc_set) needed to be cut in \r\n * order to eliminate loops in family structure.\r\n * \r\n * @param {Family} family Family structure\r\n * @returns {Edge[]} Returns optimal collection of feedback loops \r\n */\r\nexport default function getFamilyLoops(family, debug) {\r\n  var loops = [], loop,\r\n    index, len,\r\n    index2, len2,\r\n    fromNode, toNode, edge;\r\n\r\n  var tempFamily = family.clone();\r\n\r\n  family.loopTopo(this, function (itemid) {\r\n    tempFamily.removeNode(itemid);\r\n  })\r\n  family.loopTopoReversed(this, function (itemid) {\r\n    tempFamily.removeNode(itemid);\r\n  })\r\n  var cleanFamily = tempFamily.clone();\r\n\r\n  cleanFamily.loop(this, function (itemid) {\r\n    if (tempFamily.node(itemid) != null) {\r\n      tempFamily.loopParents(this, itemid, function (parentid) {\r\n        loops.push(new Edge(parentid, itemid));\r\n        tempFamily.removeChildRelation(parentid, itemid);\r\n        return tempFamily.SKIP;\r\n      });\r\n      var itemsToRemove = [];\r\n      tempFamily.loopTopo(this, function (itemid) {\r\n        itemsToRemove.push(itemid);\r\n      });\r\n      tempFamily.loopTopoReversed(this, function (itemid) {\r\n        itemsToRemove.push(itemid);\r\n      });\r\n      for (var index = 0; index < itemsToRemove.length; index += 1) {\r\n        tempFamily.removeNode(itemsToRemove[index]);\r\n      }\r\n    }\r\n  });\r\n\r\n  /* Invert loops */\r\n  for (index = 0, len = loops.length; index < len; index += 1) {\r\n    loop = loops[index];\r\n    if (!cleanFamily.removeChildRelation(loop.from, loop.to)) {\r\n      throw \"Relation does not exists\";\r\n    }\r\n  }\r\n\r\n  if (debug && cleanFamily.hasLoops()) {\r\n    throw \"Failed to clean loops in family\";\r\n  }\r\n\r\n  var graph = cleanFamily.getGraph(this, function (from, to) {\r\n    return { from: from, to: to, capacity: 1, flow: 0 };\r\n  });\r\n\r\n  var from = \"__1000__\";\r\n  var to = \"__2000__\";\r\n  var defaultMinimalFlow = loops.length;\r\n  for (index = 0, len = loops.length; index < len; index += 1) {\r\n    loop = loops[index];\r\n    edge = graph.edge(loop.from, to);\r\n    if (edge == null) {\r\n      graph.addEdge(loop.from, to, { from: loop.from, to: to, capacity: 1, flow: 0, tos: [loop.to] });\r\n    } else {\r\n      edge.capacity += 1;\r\n      edge.tos.push(loop.to);\r\n    }\r\n    edge = graph.edge(from, loop.to);\r\n    if (edge == null) {\r\n      graph.addEdge(from, loop.to, { from: from, to: loop.to, capacity: 1, flow: 0, froms: [loop.from] });\r\n    } else {\r\n      edge.capacity += 1;\r\n      edge.froms.push(loop.from);\r\n    }\r\n  }\r\n\r\n  var totalFlow = 0;\r\n  var levelGraph = null;\r\n  while (true) {\r\n    levelGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\r\n      if (fromNode == edge.from) {\r\n        return edge.capacity > edge.flow;\r\n      } else {\r\n        return edge.flow > 0;\r\n      }\r\n    });\r\n\r\n    if (!levelGraph.hasNode(to)) {\r\n      break;\r\n    }\r\n\r\n    while (true) {\r\n      var connectionPath = graph.dfsPath(this, from, to, function (fromNode, toNode, edge) {\r\n        if (fromNode == edge.from) {\r\n          return edge.capacity > edge.flow;\r\n        } else {\r\n          return edge.flow > 0;\r\n        }\r\n      });\r\n\r\n      if (connectionPath.length == 0) {\r\n        break;\r\n      }\r\n\r\n      // Find maximum flow for given path\r\n      var flow = Infinity;\r\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\r\n        fromNode = connectionPath[index];\r\n        toNode = connectionPath[index + 1];\r\n        edge = graph.edge(fromNode, toNode);\r\n        var edgeFlow = 0;\r\n        if (edge.from == fromNode) {\r\n          edgeFlow = edge.capacity - edge.flow;\r\n        } else {\r\n          edgeFlow = edge.flow;\r\n        }\r\n        if (edgeFlow == 0) {\r\n          throw \"Broken flow path\";\r\n        }\r\n        flow = Math.min(flow, edgeFlow);\r\n      }\r\n\r\n      // Update graph\r\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\r\n        fromNode = connectionPath[index];\r\n        toNode = connectionPath[index + 1];\r\n        edge = graph.edge(fromNode, toNode);\r\n        if (edge.from == fromNode) {\r\n          edge.flow += flow;\r\n        } else {\r\n          edge.flow -= flow;\r\n        }\r\n      }\r\n      totalFlow += flow;\r\n    }\r\n  }\r\n\r\n  if (totalFlow < defaultMinimalFlow) {\r\n    var residueGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\r\n      if (fromNode == edge.from) {\r\n        return edge.capacity > edge.flow;\r\n      }\r\n      return false;\r\n    });\r\n\r\n    // graph.loopNodes(this, from, function (nodeid) {\r\n    //   console.log(\"Nodeid: \" + nodeid);\r\n    //   graph.loopNodeEdges(this, nodeid, function (neighbour, edge) {\r\n    //     if (edge.to == neighbour) {\r\n    //       console.log(\"neighbour: \" + neighbour + \", edge=\" + JSON.stringify(edge));\r\n    //     }\r\n    //   })\r\n    // });\r\n\r\n    // var resedueNodes = [];\r\n    // residueGraph.loopNodes(this, from, function (nodeid) {\r\n    //   resedueNodes.push(nodeid);\r\n    // });\r\n    // console.log(\"Residue graph: \" + resedueNodes.join(\", \"));\r\n\r\n    var edgesToBreak = [];\r\n    residueGraph.loopNodes(this, from, function (nodeid) {\r\n      graph.loopNodeEdges(this, nodeid, function (toNode, edge) {\r\n        if (edge.to == toNode) {\r\n          if (!residueGraph.hasNode(toNode)) {\r\n            // console.log(\"Edge to test: from: \" + nodeid + \", to \" + toNode);\r\n            var isIsolated = false;\r\n            graph.dfsLoop(this, toNode, function (fromNode, toNode2, edge) {\r\n              if (edge.from == fromNode && !residueGraph.hasNode(fromNode)) {\r\n                return true;\r\n              }\r\n              return false;\r\n            }, function (foundid) {\r\n              if (foundid == to) {\r\n                // console.log(\"Isolated: \" + toNode + \", may access exit node\" + foundid);\r\n                isIsolated = true;\r\n                return true;\r\n              }\r\n              return false;\r\n            });\r\n            if (isIsolated) {\r\n              edgesToBreak.push(new Edge(nodeid, toNode));\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // collect loops to break\r\n    var optimizedLoops = [];\r\n    var validatedFlow = 0;\r\n    for (index = 0, len = edgesToBreak.length; index < len; index += 1) {\r\n      var edgeToBreak = edgesToBreak[index];\r\n\r\n      if (edgeToBreak.from == from) {\r\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\r\n        for (index2 = 0, len2 = edge.froms.length; index2 < len2; index2 += 1) {\r\n          optimizedLoops.push(new Edge(edge.froms[index2], edgeToBreak.to));\r\n          validatedFlow += 1;\r\n        }\r\n      } else if (edgeToBreak.to == to) {\r\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\r\n        for (index2 = 0, len2 = edge.tos.length; index2 < len2; index2 += 1) {\r\n          optimizedLoops.push(new Edge(edgeToBreak.from, edge.tos[index2]));\r\n          validatedFlow += 1;\r\n        }\r\n      } else {\r\n        optimizedLoops.push(edgeToBreak);\r\n        validatedFlow += 1;\r\n      }\r\n    }\r\n    if (validatedFlow == totalFlow) {\r\n      loops = optimizedLoops;\r\n    }\r\n  }\r\n  return loops;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}