{"ast":null,"code":"import { isObject, cloneObject } from '../common';\nimport commonBinarySearch from './binarySearch';\nimport commonMergeSort from './mergeSort';\n/**\r\n * Creates Tree Levels structure. It is diagraming specific auxiliary structure\r\n * that keeps tree nodes order level by level.\r\n * @class TreeLevels\r\n * \r\n * @param {TreeLevels} [source=undefined] Optional source object to clone content from into the new instance of the structure.\r\n * @returns {TreeLevels} Returns tree levels structure.\r\n */\nexport default function TreeLevels(source) {\n  var _levels = [],\n    _items = {},\n    _minimum = null,\n    _maximum = null;\n  _init(source);\n  function _init(source) {\n    if (isObject(source)) {\n      _levels = cloneObject(source.levels, true);\n      _items = cloneObject(source.items, true);\n      _minimum = cloneObject(source.minimum, true);\n      _maximum = cloneObject(source.maximum, true);\n    }\n  }\n  function LevelContext(context) {\n    this.context = context;\n    this.items = [];\n  }\n  function ItemContext(context, position, level) {\n    this.context = context;\n    this.positions = {};\n    this.positions[level] = position;\n    this.startLevel = level;\n    this.endLevel = level;\n  }\n\n  /**\r\n   * Checks if structure has elements.\r\n   * \r\n   * @returns {boolean} Returns true if structure has elements.\r\n   */\n  function isEmpty() {\n    return !_levels.length;\n  }\n\n  /**\r\n   * Number of levels\r\n   * \r\n   * @returns {number} Returns number of levels in structure.\r\n   */\n  function length() {\n    return _levels.length;\n  }\n\n  /**\r\n   * Adds new level. Structure keeps levels sorted by their indexes. The level index can be positive and negative as well.\r\n   * Structure auto expands collection of levels in both directions and keeps them ordered.\r\n   * @param {number} level New level index\r\n   * @param {object} context Context object\r\n   */\n  function addLevel(level, context) {\n    var treeLevel = createLevel(level);\n    treeLevel.context = context;\n  }\n\n  /**\r\n   * Returns element's start level index in the structure. Element may occupy multiple levels of the tree levels structure.\r\n   * \r\n   * @param {string} itemid The element id\r\n   * @returns {number} Returns start level index\r\n   */\n  function getStartLevelIndex(itemid) {\n    return _items.hasOwnProperty(itemid) ? _items[itemid].startLevel : null;\n  }\n\n  /**\r\n   * Returns element's end level index in the structure. Element may occupy multiple levels of the tree levels structure.\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @returns {number} Returns end level index\r\n   */\n  function getEndLevelIndex(itemid) {\n    return _items.hasOwnProperty(itemid) ? _items[itemid].endLevel : null;\n  }\n\n  /**\r\n   * Gets element position at level\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} level Level index\r\n   * @returns {number} Returns position of the element \r\n   */\n  function getItemPosition(itemid, level) {\n    var context = _items[itemid];\n    if (context != null) {\n      if (level != null) {\n        return context.positions[level];\n      } else {\n        return context.positions[context.startLevel];\n      }\n    }\n    return null;\n  }\n\n  /**\r\n   * Gets element at position\r\n   * \r\n   * @param {number} levelIndex Level index\r\n   * @param {number} position Item position\r\n   * @returns {number} Returns element id\r\n   */\n  function getItemAtPosition(levelIndex, position) {\n    var level = _levels[levelIndex],\n      itemid = null;\n    if (level != null) {\n      itemid = level.items[position];\n    }\n    return itemid;\n  }\n\n  /**\r\n   * Gets previous element\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} itemLevel Level index\r\n   * @returns {number} Returns previous element id\r\n   */\n  function getPrevItem(itemid, itemLevel) {\n    var result = null;\n    if (_items.hasOwnProperty(itemid)) {\n      var item = _items[itemid];\n      itemLevel = itemLevel || item.startLevel;\n      var level = _levels[itemLevel];\n      result = level.items[item.positions[itemLevel] - 1];\n    }\n    return result;\n  }\n\n  /**\r\n   * Gets next element\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} itemLevel Level index\r\n   * @returns {number} Returns next element id\r\n   */\n  function getNextItem(itemid, itemLevel) {\n    var result = null;\n    if (_items.hasOwnProperty(itemid)) {\n      var item = _items[itemid];\n      itemLevel = itemLevel || item.startLevel;\n      var level = _levels[itemLevel];\n      result = level.items[item.positions[itemLevel] + 1];\n    }\n    return result;\n  }\n\n  /**\r\n   * Checks if structure contains element\r\n   * @param {string} itemid Element id\r\n   * @returns {boolean} Returns true if structure contains given element id\r\n   */\n  function hasItem(itemid) {\n    return _items.hasOwnProperty(itemid);\n  }\n\n  /**\r\n   * Checks if structure contains level\r\n   * @param {number} levelIndex Level index\r\n   * @returns {boolean} Returns true if structure contains given level index\r\n   */\n  function hasLevel(levelIndex) {\n    return _levels[levelIndex] != null;\n  }\n\n  /**\r\n   * Gets element context object\r\n   * @param {string} itemid Element id\r\n   * @returns {object} Returns context object of the element\r\n   */\n  function getItemContext(itemid) {\n    var result = null;\n    if (_items.hasOwnProperty(itemid)) {\n      result = _items[itemid].context;\n    }\n    return result;\n  }\n\n  /**\r\n   * Creates new level\r\n   * @param {index} index New level index\r\n   * @returns {object} Returns new level empty context object\r\n   */\n  function createLevel(index) {\n    if (_levels[index] == null) {\n      _levels[index] = new LevelContext(null);\n      _minimum = _minimum === null ? index : Math.min(_minimum, index);\n      _maximum = _maximum === null ? index : Math.max(_maximum, index);\n    }\n    return _levels[index];\n  }\n\n  /**\r\n   * Adds element\r\n   * @param {number} levelIndex Level index\r\n   * @param {string} itemid New element id\r\n   * @param {object} context Context object\r\n   */\n  function addItem(levelIndex, itemid, context) {\n    var level, itemContext;\n    if (!_items.hasOwnProperty(itemid)) {\n      level = createLevel(levelIndex);\n      level.items.push(itemid);\n      _items[itemid] = new ItemContext(context, level.items.length - 1, levelIndex);\n    } else {\n      level = createLevel(levelIndex);\n      level.items.push(itemid);\n      itemContext = _items[itemid];\n      itemContext.positions[levelIndex] = level.items.length - 1;\n      itemContext.startLevel = Math.min(itemContext.startLevel, levelIndex);\n      itemContext.endLevel = Math.max(itemContext.endLevel, levelIndex);\n    }\n  }\n\n  /**\r\n   * Callback function for iteration of levels\r\n   * \r\n   * @callback onTreeLevelCallback\r\n   * @param {number} levelIndex Level index\r\n   * @param {object} level Context object\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops levels\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelCallback} onItem A callback function to call for every level\r\n   */\n  function loopLevels(thisArg, onItem) {\n    var index, level;\n    if (onItem != null) {\n      for (index = _minimum; index <= _maximum; index += 1) {\n        level = _levels[index];\n        if (level != null) {\n          if (onItem.call(thisArg, index, level.context)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Loops levels in reversed order\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelCallback} onItem A callback function to call for every level\r\n   */\n  function loopLevelsReversed(thisArg, onItem) {\n    var index, level;\n    if (onItem != null) {\n      for (index = _maximum; index >= _minimum; index -= 1) {\n        level = _levels[index];\n        if (level != null) {\n          if (onItem.call(thisArg, index, level.context)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Gets number of elements at level\r\n   * \r\n   * @param {number} levelIndex Level index\r\n   * @returns {number} Returns number of elements at the level\r\n   */\n  function getLevelLength(levelIndex) {\n    var result = 0,\n      level = _levels[levelIndex];\n    if (level != null) {\n      result = level.items.length;\n    }\n    return result;\n  }\n\n  /**\r\n   * Callback function for iteration of level elements\r\n   * \r\n   * @callback onTreeLevelItemCallback\r\n   * @param {string} itemid Element id\r\n   * @param {object} item Context object of the element\r\n   * @param {number} position Position of the element at level\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops level elements\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {number} levelIndex Level index\r\n   * @param {onTreeLevelItemCallback} onItem A callback function to call for every item\r\n   */\n  function loopLevelItems(thisArg, levelIndex, onItem) {\n    var index, len, level, itemid;\n    if (onItem != null) {\n      level = _levels[levelIndex];\n      if (level != null) {\n        for (index = 0, len = level.items.length; index < len; index += 1) {\n          itemid = level.items[index];\n          if (onItem.call(thisArg, itemid, _items[itemid].context, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback function for iteration of elements level by level\r\n   * \r\n   * @callback onTreeLevelsItemCallback\r\n   * @param {string} itemid Element id\r\n   * @param {object} item Element context object\r\n   * @param {number} position Position of the element at level\r\n   * @param {number} levelIndex Level index\r\n   * @param {object} level Level context object\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops elements level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelsItemCallback} onItem A callback function to call for every item\r\n   */\n  function loopItems(thisArg, onItem) {\n    // function onItem(itemid, item, position, levelIndex, level)\n    var index,\n      len,\n      level,\n      levelIndex,\n      items,\n      itemid,\n      processed = {};\n    if (onItem != null) {\n      for (levelIndex = _minimum; levelIndex <= _maximum; levelIndex += 1) {\n        level = _levels[levelIndex];\n        if (level != null) {\n          items = level.items;\n          for (index = 0, len = items.length; index < len; index += 1) {\n            itemid = items[index];\n            if (!processed.hasOwnProperty(itemid)) {\n              processed[itemid] = true;\n              if (onItem.call(thisArg, itemid, _items[itemid].context, index, levelIndex, level.context)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback for finding distance for element\r\n   *\r\n   * @callback onTreeLevelDistanceCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns distance for the element\r\n   */\n\n  /**\r\n   * Searches element at level using binary search\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {number} levelIndex Level index to search element at\r\n   * @param {onTreeLevelDistanceCallback} onGetDistance A callback function to measure distance for element\r\n   */\n  function binarySearch(thisArg, levelIndex, onGetDistance) {\n    var result = null,\n      level;\n    if (onGetDistance != null) {\n      level = _levels[levelIndex];\n      if (level != null) {\n        result = commonBinarySearch(level.items, function (itemid) {\n          return onGetDistance.call(thisArg, itemid, _items[itemid].context);\n        });\n      }\n    }\n    return result.item;\n  }\n\n  /**\r\n   * Callback for finding weight of element\r\n   *\r\n   * @callback onTreeLevelItemWeightCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns distance for the element\r\n   */\n\n  /**\r\n   * Callback for iterating items\r\n   *\r\n   * @callback onTreeLevelMergedItemCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns true to break iteration process.\r\n   */\n\n  /**\r\n   * Loops merged elements of tree level structure by weight\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelItemWeightCallback} getItemWeight Callback to measure weight of the element\r\n   * @param {onTreeLevelMergedItemCallback} onItem Callback to iterate merged elements\r\n   */\n  function loopMerged(thisArg, getItemWeight, onItem) {\n    var index,\n      len,\n      level,\n      itemid,\n      levelsItems = [],\n      sortedItems;\n    for (index = 0, len = _levels.length; index < len; index += 1) {\n      level = _levels[index];\n      if (level != null) {\n        levelsItems.push(level.items);\n      }\n    }\n    sortedItems = commonMergeSort(levelsItems, getItemWeight, true);\n    if (onItem != null) {\n      for (index = 0, len = sortedItems.length; index < len; index += 1) {\n        itemid = sortedItems[index];\n        if (onItem.call(thisArg, itemid, _items[itemid].context)) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Loops level elements starting with the given item\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid Start element id\r\n   * @param {boolean} isLeft If true then method loops leftward\r\n   * @param {onTreeLevelMergedItemCallback} onItem Callback function to call for every item\r\n   * @param {number} level Level index\r\n   */\n  function loopFromItem(thisArg, itemid, isLeft, onItem, level) {\n    var context, index, len, items, nextItemId, itemLevel, position;\n    if (_items.hasOwnProperty(itemid)) {\n      context = _items[itemid];\n      itemLevel = level || context.startLevel;\n      items = _levels[itemLevel].items;\n      position = context.positions[itemLevel];\n      if (onItem != null) {\n        if (isLeft) {\n          for (index = position - 1; index >= 0; index -= 1) {\n            nextItemId = items[index];\n            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {\n              break;\n            }\n          }\n        } else {\n          for (index = position + 1, len = items.length; index < len; index += 1) {\n            nextItemId = items[index];\n            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Loops levels starting with the given element end level. Element may occupy multiple levels, \r\n   * so this method starts level iteration from next level after or before item levels.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid Element id\r\n   * @param {boolean} isBelow If true then method loops levels backward\r\n   * @param {onTreeLevelCallback} onItem Callback function to call for every level\r\n   */\n  function loopLevelsFromItem(thisArg, itemid, isBelow, onItem) {\n    // function(levelIndex, level)\n    var context, index, len, items, item, nextItemId, nextLevels, level;\n    if (_items.hasOwnProperty(itemid)) {\n      context = _items[itemid];\n      if (onItem != null) {\n        if (isBelow) {\n          for (index = context.endLevel + 1; index <= _maximum; index += 1) {\n            level = _levels[index];\n            if (onItem.call(thisArg, index, level != null ? level.context : null)) {\n              break;\n            }\n          }\n        } else {\n          for (index = context.startLevel - 1; index >= _minimum; index -= 1) {\n            level = _levels[index];\n            if (onItem.call(thisArg, index, level != null ? level.context : null)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Clones tree levels structure.\r\n   * \r\n   * @returns {TreeLevels} Returns cloned copy of the structure\r\n   */\n  function clone() {\n    return TreeLevels({\n      levels: _levels,\n      items: _items,\n      minimum: _minimum,\n      maximum: _maximum\n    });\n  }\n  return {\n    addlevel: addLevel,\n    hasLevel: hasLevel,\n    hasItem: hasItem,\n    addItem: addItem,\n    getItemContext: getItemContext,\n    getLevelIndex: getStartLevelIndex,\n    getEndLevelIndex: getEndLevelIndex,\n    getItemPosition: getItemPosition,\n    getItemAtPosition: getItemAtPosition,\n    loopLevels: loopLevels,\n    loopLevelsReversed: loopLevelsReversed,\n    loopLevelItems: loopLevelItems,\n    getLevelLength: getLevelLength,\n    loopItems: loopItems,\n    binarySearch: binarySearch,\n    loopMerged: loopMerged,\n    loopFromItem: loopFromItem,\n    loopLevelsFromItem: loopLevelsFromItem,\n    getPrevItem: getPrevItem,\n    getNextItem: getNextItem,\n    length: length,\n    isEmpty: isEmpty,\n    clone: clone\n  };\n}\n;","map":{"version":3,"names":["isObject","cloneObject","commonBinarySearch","commonMergeSort","TreeLevels","source","_levels","_items","_minimum","_maximum","_init","levels","items","minimum","maximum","LevelContext","context","ItemContext","position","level","positions","startLevel","endLevel","isEmpty","length","addLevel","treeLevel","createLevel","getStartLevelIndex","itemid","hasOwnProperty","getEndLevelIndex","getItemPosition","getItemAtPosition","levelIndex","getPrevItem","itemLevel","result","item","getNextItem","hasItem","hasLevel","getItemContext","index","Math","min","max","addItem","itemContext","push","loopLevels","thisArg","onItem","call","loopLevelsReversed","getLevelLength","loopLevelItems","len","loopItems","processed","binarySearch","onGetDistance","loopMerged","getItemWeight","levelsItems","sortedItems","loopFromItem","isLeft","nextItemId","loopLevelsFromItem","isBelow","nextLevels","clone","addlevel","getLevelIndex"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/TreeLevels.js"],"sourcesContent":["import { isObject, cloneObject } from '../common';\r\nimport commonBinarySearch from './binarySearch';\r\nimport commonMergeSort from './mergeSort';\r\n/**\r\n * Creates Tree Levels structure. It is diagraming specific auxiliary structure\r\n * that keeps tree nodes order level by level.\r\n * @class TreeLevels\r\n * \r\n * @param {TreeLevels} [source=undefined] Optional source object to clone content from into the new instance of the structure.\r\n * @returns {TreeLevels} Returns tree levels structure.\r\n */\r\nexport default function TreeLevels(source) {\r\n  var _levels = [],\r\n    _items = {},\r\n    _minimum = null,\r\n    _maximum = null;\r\n\r\n  _init(source);\r\n\r\n  function _init(source) {\r\n    if (isObject(source)) {\r\n      _levels = cloneObject(source.levels, true);\r\n      _items = cloneObject(source.items, true);\r\n      _minimum = cloneObject(source.minimum, true);\r\n      _maximum = cloneObject(source.maximum, true);\r\n    }\r\n  }\r\n\r\n  function LevelContext(context) {\r\n    this.context = context;\r\n    this.items = [];\r\n  }\r\n\r\n  function ItemContext(context, position, level) {\r\n    this.context = context;\r\n    this.positions = {};\r\n    this.positions[level] = position;\r\n    this.startLevel = level;\r\n    this.endLevel = level;\r\n  }\r\n\r\n  /**\r\n   * Checks if structure has elements.\r\n   * \r\n   * @returns {boolean} Returns true if structure has elements.\r\n   */\r\n  function isEmpty() {\r\n    return !_levels.length;\r\n  }\r\n\r\n  /**\r\n   * Number of levels\r\n   * \r\n   * @returns {number} Returns number of levels in structure.\r\n   */\r\n  function length() {\r\n    return _levels.length;\r\n  }\r\n\r\n  /**\r\n   * Adds new level. Structure keeps levels sorted by their indexes. The level index can be positive and negative as well.\r\n   * Structure auto expands collection of levels in both directions and keeps them ordered.\r\n   * @param {number} level New level index\r\n   * @param {object} context Context object\r\n   */\r\n  function addLevel(level, context) {\r\n    var treeLevel = createLevel(level);\r\n    treeLevel.context = context;\r\n  }\r\n\r\n  /**\r\n   * Returns element's start level index in the structure. Element may occupy multiple levels of the tree levels structure.\r\n   * \r\n   * @param {string} itemid The element id\r\n   * @returns {number} Returns start level index\r\n   */\r\n  function getStartLevelIndex(itemid) {\r\n    return _items.hasOwnProperty(itemid) ? _items[itemid].startLevel : null;\r\n  }\r\n\r\n  /**\r\n   * Returns element's end level index in the structure. Element may occupy multiple levels of the tree levels structure.\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @returns {number} Returns end level index\r\n   */\r\n  function getEndLevelIndex(itemid) {\r\n    return _items.hasOwnProperty(itemid) ? _items[itemid].endLevel : null;\r\n  }\r\n\r\n  /**\r\n   * Gets element position at level\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} level Level index\r\n   * @returns {number} Returns position of the element \r\n   */\r\n  function getItemPosition(itemid, level) {\r\n    var context = _items[itemid];\r\n    if (context != null) {\r\n      if (level != null) {\r\n        return context.positions[level];\r\n      } else {\r\n        return context.positions[context.startLevel];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Gets element at position\r\n   * \r\n   * @param {number} levelIndex Level index\r\n   * @param {number} position Item position\r\n   * @returns {number} Returns element id\r\n   */\r\n  function getItemAtPosition(levelIndex, position) {\r\n    var level = _levels[levelIndex],\r\n      itemid = null;\r\n    if (level != null) {\r\n      itemid = level.items[position];\r\n    }\r\n    return itemid;\r\n  }\r\n\r\n  /**\r\n   * Gets previous element\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} itemLevel Level index\r\n   * @returns {number} Returns previous element id\r\n   */\r\n  function getPrevItem(itemid, itemLevel) {\r\n    var result = null;\r\n    if (_items.hasOwnProperty(itemid)) {\r\n      var item = _items[itemid];\r\n      itemLevel = itemLevel || item.startLevel;\r\n      var level = _levels[itemLevel];\r\n      result = level.items[item.positions[itemLevel] - 1];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets next element\r\n   * \r\n   * @param {string} itemid Element id\r\n   * @param {number} itemLevel Level index\r\n   * @returns {number} Returns next element id\r\n   */\r\n  function getNextItem(itemid, itemLevel) {\r\n    var result = null;\r\n    if (_items.hasOwnProperty(itemid)) {\r\n      var item = _items[itemid];\r\n      itemLevel = itemLevel || item.startLevel;\r\n      var level = _levels[itemLevel];\r\n      result = level.items[item.positions[itemLevel] + 1];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Checks if structure contains element\r\n   * @param {string} itemid Element id\r\n   * @returns {boolean} Returns true if structure contains given element id\r\n   */\r\n  function hasItem(itemid) {\r\n    return _items.hasOwnProperty(itemid);\r\n  }\r\n\r\n  /**\r\n   * Checks if structure contains level\r\n   * @param {number} levelIndex Level index\r\n   * @returns {boolean} Returns true if structure contains given level index\r\n   */\r\n  function hasLevel(levelIndex) {\r\n    return _levels[levelIndex] != null;\r\n  }\r\n\r\n  /**\r\n   * Gets element context object\r\n   * @param {string} itemid Element id\r\n   * @returns {object} Returns context object of the element\r\n   */\r\n  function getItemContext(itemid) {\r\n    var result = null;\r\n    if (_items.hasOwnProperty(itemid)) {\r\n      result = _items[itemid].context;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates new level\r\n   * @param {index} index New level index\r\n   * @returns {object} Returns new level empty context object\r\n   */\r\n  function createLevel(index) {\r\n    if (_levels[index] == null) {\r\n      _levels[index] = new LevelContext(null);\r\n\r\n      _minimum = _minimum === null ? index : Math.min(_minimum, index);\r\n      _maximum = _maximum === null ? index : Math.max(_maximum, index);\r\n    }\r\n    return _levels[index];\r\n  }\r\n\r\n  /**\r\n   * Adds element\r\n   * @param {number} levelIndex Level index\r\n   * @param {string} itemid New element id\r\n   * @param {object} context Context object\r\n   */\r\n  function addItem(levelIndex, itemid, context) {\r\n    var level, itemContext;\r\n    if (!_items.hasOwnProperty(itemid)) {\r\n      level = createLevel(levelIndex);\r\n      level.items.push(itemid);\r\n      _items[itemid] = new ItemContext(context, level.items.length - 1, levelIndex);\r\n    } else {\r\n      level = createLevel(levelIndex);\r\n      level.items.push(itemid);\r\n      itemContext = _items[itemid];\r\n      itemContext.positions[levelIndex] = level.items.length - 1;\r\n      itemContext.startLevel = Math.min(itemContext.startLevel, levelIndex);\r\n      itemContext.endLevel = Math.max(itemContext.endLevel, levelIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function for iteration of levels\r\n   * \r\n   * @callback onTreeLevelCallback\r\n   * @param {number} levelIndex Level index\r\n   * @param {object} level Context object\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops levels\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelCallback} onItem A callback function to call for every level\r\n   */\r\n  function loopLevels(thisArg, onItem) {\r\n    var index,\r\n      level;\r\n    if (onItem != null) {\r\n      for (index = _minimum; index <= _maximum; index += 1) {\r\n        level = _levels[index];\r\n        if (level != null) {\r\n          if (onItem.call(thisArg, index, level.context)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops levels in reversed order\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelCallback} onItem A callback function to call for every level\r\n   */\r\n  function loopLevelsReversed(thisArg, onItem) {\r\n    var index,\r\n      level;\r\n    if (onItem != null) {\r\n      for (index = _maximum; index >= _minimum; index -= 1) {\r\n        level = _levels[index];\r\n        if (level != null) {\r\n          if (onItem.call(thisArg, index, level.context)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets number of elements at level\r\n   * \r\n   * @param {number} levelIndex Level index\r\n   * @returns {number} Returns number of elements at the level\r\n   */\r\n  function getLevelLength(levelIndex) {\r\n    var result = 0,\r\n      level = _levels[levelIndex];\r\n    if (level != null) {\r\n      result = level.items.length;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Callback function for iteration of level elements\r\n   * \r\n   * @callback onTreeLevelItemCallback\r\n   * @param {string} itemid Element id\r\n   * @param {object} item Context object of the element\r\n   * @param {number} position Position of the element at level\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops level elements\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {number} levelIndex Level index\r\n   * @param {onTreeLevelItemCallback} onItem A callback function to call for every item\r\n   */\r\n  function loopLevelItems(thisArg, levelIndex, onItem) {\r\n    var index, len,\r\n      level,\r\n      itemid;\r\n    if (onItem != null) {\r\n      level = _levels[levelIndex];\r\n      if (level != null) {\r\n        for (index = 0, len = level.items.length; index < len; index += 1) {\r\n          itemid = level.items[index];\r\n          if (onItem.call(thisArg, itemid, _items[itemid].context, index)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function for iteration of elements level by level\r\n   * \r\n   * @callback onTreeLevelsItemCallback\r\n   * @param {string} itemid Element id\r\n   * @param {object} item Element context object\r\n   * @param {number} position Position of the element at level\r\n   * @param {number} levelIndex Level index\r\n   * @param {object} level Level context object\r\n   * @returns {boolean} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops elements level by level\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelsItemCallback} onItem A callback function to call for every item\r\n   */\r\n  function loopItems(thisArg, onItem) { // function onItem(itemid, item, position, levelIndex, level)\r\n    var index, len,\r\n      level, levelIndex,\r\n      items,\r\n      itemid,\r\n      processed = {};\r\n    if (onItem != null) {\r\n      for (levelIndex = _minimum; levelIndex <= _maximum; levelIndex += 1) {\r\n        level = _levels[levelIndex];\r\n        if (level != null) {\r\n          items = level.items;\r\n          for (index = 0, len = items.length; index < len; index += 1) {\r\n            itemid = items[index];\r\n            if (!processed.hasOwnProperty(itemid)) {\r\n              processed[itemid] = true;\r\n              if (onItem.call(thisArg, itemid, _items[itemid].context, index, levelIndex, level.context)) {\r\n                return;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for finding distance for element\r\n   *\r\n   * @callback onTreeLevelDistanceCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns distance for the element\r\n   */\r\n\r\n  /**\r\n   * Searches element at level using binary search\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {number} levelIndex Level index to search element at\r\n   * @param {onTreeLevelDistanceCallback} onGetDistance A callback function to measure distance for element\r\n   */\r\n  function binarySearch(thisArg, levelIndex, onGetDistance) {\r\n    var result = null,\r\n      level;\r\n    if (onGetDistance != null) {\r\n      level = _levels[levelIndex];\r\n      if (level != null) {\r\n        result = commonBinarySearch(level.items, function (itemid) {\r\n          return onGetDistance.call(thisArg, itemid, _items[itemid].context);\r\n        });\r\n      }\r\n    }\r\n    return result.item;\r\n  }\r\n\r\n  /**\r\n   * Callback for finding weight of element\r\n   *\r\n   * @callback onTreeLevelItemWeightCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns distance for the element\r\n   */\r\n\r\n  /**\r\n   * Callback for iterating items\r\n   *\r\n   * @callback onTreeLevelMergedItemCallback\r\n   * @param {number} itemid Element id\r\n   * @param {object} item Context object\r\n   * @returns {number} Returns true to break iteration process.\r\n   */\r\n\r\n  /**\r\n   * Loops merged elements of tree level structure by weight\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {onTreeLevelItemWeightCallback} getItemWeight Callback to measure weight of the element\r\n   * @param {onTreeLevelMergedItemCallback} onItem Callback to iterate merged elements\r\n   */\r\n  function loopMerged(thisArg, getItemWeight, onItem) {\r\n    var index, len,\r\n      level,\r\n      itemid,\r\n      levelsItems = [],\r\n      sortedItems;\r\n\r\n    for (index = 0, len = _levels.length; index < len; index += 1) {\r\n      level = _levels[index];\r\n      if (level != null) {\r\n        levelsItems.push(level.items);\r\n      }\r\n    }\r\n\r\n    sortedItems = commonMergeSort(levelsItems, getItemWeight, true);\r\n\r\n    if (onItem != null) {\r\n      for (index = 0, len = sortedItems.length; index < len; index += 1) {\r\n        itemid = sortedItems[index];\r\n        if (onItem.call(thisArg, itemid, _items[itemid].context)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops level elements starting with the given item\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid Start element id\r\n   * @param {boolean} isLeft If true then method loops leftward\r\n   * @param {onTreeLevelMergedItemCallback} onItem Callback function to call for every item\r\n   * @param {number} level Level index\r\n   */\r\n  function loopFromItem(thisArg, itemid, isLeft, onItem, level) {\r\n    var context,\r\n      index, len,\r\n      items, nextItemId,\r\n      itemLevel, position;\r\n    if (_items.hasOwnProperty(itemid)) {\r\n      context = _items[itemid];\r\n      itemLevel = level || context.startLevel;\r\n      items = _levels[itemLevel].items;\r\n      position = context.positions[itemLevel];\r\n      if (onItem != null) {\r\n        if (isLeft) {\r\n          for (index = position - 1; index >= 0; index -= 1) {\r\n            nextItemId = items[index];\r\n            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {\r\n              break;\r\n            }\r\n          }\r\n        } else {\r\n          for (index = position + 1, len = items.length; index < len; index += 1) {\r\n            nextItemId = items[index];\r\n            if (onItem.call(thisArg, nextItemId, _items[nextItemId].context)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops levels starting with the given element end level. Element may occupy multiple levels, \r\n   * so this method starts level iteration from next level after or before item levels.\r\n   * \r\n   * @param {Object} thisArg The callback function invocation context\r\n   * @param {string} itemid Element id\r\n   * @param {boolean} isBelow If true then method loops levels backward\r\n   * @param {onTreeLevelCallback} onItem Callback function to call for every level\r\n   */\r\n  function loopLevelsFromItem(thisArg, itemid, isBelow, onItem) { // function(levelIndex, level)\r\n    var context,\r\n      index, len,\r\n      items, item, nextItemId,\r\n      nextLevels, level;\r\n    if (_items.hasOwnProperty(itemid)) {\r\n      context = _items[itemid];\r\n      if (onItem != null) {\r\n        if (isBelow) {\r\n          for (index = context.endLevel + 1; index <= _maximum; index += 1) {\r\n            level = _levels[index];\r\n            if (onItem.call(thisArg, index, level != null ? level.context : null)) {\r\n              break;\r\n            }\r\n          }\r\n        } else {\r\n          for (index = context.startLevel - 1; index >= _minimum; index -= 1) {\r\n            level = _levels[index];\r\n            if (onItem.call(thisArg, index, level != null ? level.context : null)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clones tree levels structure.\r\n   * \r\n   * @returns {TreeLevels} Returns cloned copy of the structure\r\n   */\r\n  function clone() {\r\n    return TreeLevels({\r\n      levels: _levels,\r\n      items: _items,\r\n      minimum: _minimum,\r\n      maximum: _maximum\r\n    });\r\n  }\r\n\r\n  return {\r\n    addlevel: addLevel,\r\n    hasLevel: hasLevel,\r\n    hasItem: hasItem,\r\n    addItem: addItem,\r\n    getItemContext: getItemContext,\r\n    getLevelIndex: getStartLevelIndex,\r\n    getEndLevelIndex: getEndLevelIndex,\r\n    getItemPosition: getItemPosition,\r\n    getItemAtPosition: getItemAtPosition,\r\n    loopLevels: loopLevels,\r\n    loopLevelsReversed: loopLevelsReversed,\r\n    loopLevelItems: loopLevelItems,\r\n    getLevelLength: getLevelLength,\r\n    loopItems: loopItems,\r\n    binarySearch: binarySearch,\r\n    loopMerged: loopMerged,\r\n    loopFromItem: loopFromItem,\r\n    loopLevelsFromItem: loopLevelsFromItem,\r\n    getPrevItem: getPrevItem,\r\n    getNextItem: getNextItem,\r\n    length: length,\r\n    isEmpty: isEmpty,\r\n\r\n    clone: clone\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}