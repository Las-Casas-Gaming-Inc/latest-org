{"ast":null,"code":"import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport { LineType, Enabled } from '../enums';\n\n/**\r\n * @class TemplateConfig\r\n * @classdesc Template configuration object defines DOM elements for node content, cursor and highlight visual representation.\r\n * They are grouped into one configuration object because if we decide to customize cursor or highlight templates most likely\r\n * we are going to make them item template specific. At the same time control does not require all 3 of them to be defined.\r\n * If cursor or highlight templates properties are not set in template configuration object then control uses internal\r\n * default template for all of them. Generally all 3 templates can be set to null, so default templates are going to be used\r\n * by control.\r\n */\nexport default function TemplateConfig() {\n  /**\r\n   * Name. Every template configuration object has name property, it is being used to reference templates from items.\r\n   * This name is used to as an argument of call back rendering function as well. If item has not template name set \r\n   * it uses default template for rendering.\r\n   * \r\n   * @type {string}\r\n   */\n  this.name = null;\n\n  /**\r\n   * If true it makes templated items inactive in diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when use auto fit mode, selection of neighboring node to inactive item makes all nodes of inactive item shown in full\r\n   * size as well. Inactive items play a role of in layout annotations having no user interaction and templated with HTML.\r\n   * For example they can be used to add titles into family diagram layout or terminator items indicating that upon reaching\r\n   * them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\n  this.isActive = true;\n\n  /**\r\n   * Size. Control deals with fixed size layout, it makes no guesses about content and size of nodes.\r\n   * So we don't support in any form nodes auto sizing. In order to support such feature control should measure content\r\n   * of every node before rendering cycle. Taking into account that nodes visibility depends on available space it is going\r\n   * to be infinite loop of diagram layout and nodes measure iterations. The more space we provide to nodes the less number \r\n   * of diagram nodes is going to be visible. So control expect that node size is hard valued in template configuration.\r\n   * \r\n   * @type {Size}\r\n   */\n  this.itemSize = new Size(120, 100);\n\n  /**\r\n   * Border width. We use archaic method to layout cursor and highlight frames around nodes, so we need to know border\r\n   * width in order measure gaps between them properly.\r\n   * \r\n   * @type {number}\r\n   */\n  this.itemBorderWidth = 1;\n\n  /**\r\n   * Item template. Supported template formats: Control provide two distinct ways to define item templates.\r\n   * The original one is based on setting HTML elements content via innerHTML DOM element property, see following reference \r\n   * at https://developer.mozilla.org web site for more details. The modern way is to use JSON ML library that is our recommended\r\n   * solution for templates definition, see following web site for more details http://www.jsonml.org/. This is only 3d party\r\n   * MIT licensed code included into our code base, everything else is 100% authentic. We adopted it with minor modifications,\r\n   * it generally works according to its original design.\r\n   * \r\n   * The control calls `onItemRender` callback function when specific node cursor needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\n  this.itemTemplate = null;\n\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of the diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for nodes templated with this template.\r\n   * \r\n   * @type {ShapeType}\r\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\r\n   * Marker size.\r\n   * \r\n   * @type {Size}\r\n   */\n  this.minimizedItemSize = new Size(4, 4);\n\n  /**\r\n   * Marker corder radius for simple squares. By default it is null and dots displayed as cycles. If corner radius set to 0 then\r\n   * they are displayed as regular squares.\r\n   * \r\n   * @type {number}\r\n   */\n  this.minimizedItemCornerRadius = null;\n\n  /**\r\n   * Marker border line width\r\n   * \r\n   * @type {number}\r\n   */\n  this.minimizedItemLineWidth = 1;\n\n  /**\r\n   * Marker border line color. By default it is the same as `itemTitleColor` of rendered node.\r\n   * \r\n   * @type {string}\r\n   */\n  this.minimizedItemBorderColor = null;\n\n  /*\r\n    Marker border line pattern\r\n    \r\n    @type {LineType}\r\n  */\n  this.minimizedItemLineType = LineType.Solid;\n\n  /**\r\n   * Marker fill color. By default it is the same as `itemTitleColor` of rendered node.\r\n   * \r\n   * @type {string}\r\n   */\n  this.minimizedItemFillColor = null;\n\n  /**\r\n   * Marker fill color opacity.\r\n   * \r\n   * @type {number}\r\n   */\n  this.minimizedItemOpacity = 1;\n\n  /**\r\n   * Highlight frame offset from node.\r\n   * \r\n   * @type {Thickness}\r\n   */\n  this.highlightPadding = new Thickness(2, 2, 2, 2);\n\n  /**\r\n   * Highlight frame border width.\r\n   * \r\n   * @type {number}\r\n   */\n  this.highlightBorderWidth = 1;\n\n  /**\r\n   * Highlight Template.\r\n   * \r\n   * The control calls `onHighlightRender` callback function when specific node highlight needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\n  this.highlightTemplate = null;\n\n  /**\r\n   * Cursor frame offset from node.\r\n   * \r\n   * @type {Thickness}\r\n   */\n  this.cursorPadding = new Thickness(3, 3, 3, 3);\n\n  /**\r\n   * Cursor frame border width.\r\n   * \r\n   * @type {number}\r\n   */\n  this.cursorBorderWidth = 2;\n\n  /**\r\n   * Cursor Template.\r\n   * \r\n   * The control calls `onCursorRender` callback function when specific node cursor needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\n  this.cursorTemplate = null;\n\n  /**\r\n   * Sets buttons panel visibility.\r\n   * \r\n   * `Auto` - depends on master config `hasButtons` property setting.\r\n   * `True` - visible\r\n   * `False` - hidden\r\n   * \r\n   * @group Templates\r\n   * @type {boolean}\r\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\r\n   * On buttons panel render event. This callback function is called to render context of buttons panel.\r\n   * It is used to replace `buttons` collection property in the control. So we preserve context buttons panel as a functional \r\n   * concept, but eliminate buttons customization API.\r\n   *\r\n   * @callback\r\n   * @param {EventArgs} data Context information\r\n   */\n  this.onButtonsRender = null;\n}\n;","map":{"version":3,"names":["Thickness","Size","LineType","Enabled","TemplateConfig","name","isActive","itemSize","itemBorderWidth","itemTemplate","minimizedItemShapeType","minimizedItemSize","minimizedItemCornerRadius","minimizedItemLineWidth","minimizedItemBorderColor","minimizedItemLineType","Solid","minimizedItemFillColor","minimizedItemOpacity","highlightPadding","highlightBorderWidth","highlightTemplate","cursorPadding","cursorBorderWidth","cursorTemplate","hasButtons","Auto","onButtonsRender"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/configs/TemplateConfig.js"],"sourcesContent":["import Thickness from '../graphics/structs/Thickness';\r\nimport Size from '../graphics/structs/Size';\r\nimport { LineType, Enabled } from '../enums';\r\n\r\n/**\r\n * @class TemplateConfig\r\n * @classdesc Template configuration object defines DOM elements for node content, cursor and highlight visual representation.\r\n * They are grouped into one configuration object because if we decide to customize cursor or highlight templates most likely\r\n * we are going to make them item template specific. At the same time control does not require all 3 of them to be defined.\r\n * If cursor or highlight templates properties are not set in template configuration object then control uses internal\r\n * default template for all of them. Generally all 3 templates can be set to null, so default templates are going to be used\r\n * by control.\r\n */\r\nexport default function TemplateConfig() {\r\n  /**\r\n   * Name. Every template configuration object has name property, it is being used to reference templates from items.\r\n   * This name is used to as an argument of call back rendering function as well. If item has not template name set \r\n   * it uses default template for rendering.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.name = null;\r\n\r\n  /**\r\n   * If true it makes templated items inactive in diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when use auto fit mode, selection of neighboring node to inactive item makes all nodes of inactive item shown in full\r\n   * size as well. Inactive items play a role of in layout annotations having no user interaction and templated with HTML.\r\n   * For example they can be used to add titles into family diagram layout or terminator items indicating that upon reaching\r\n   * them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\r\n  this.isActive = true;\r\n\r\n  /**\r\n   * Size. Control deals with fixed size layout, it makes no guesses about content and size of nodes.\r\n   * So we don't support in any form nodes auto sizing. In order to support such feature control should measure content\r\n   * of every node before rendering cycle. Taking into account that nodes visibility depends on available space it is going\r\n   * to be infinite loop of diagram layout and nodes measure iterations. The more space we provide to nodes the less number \r\n   * of diagram nodes is going to be visible. So control expect that node size is hard valued in template configuration.\r\n   * \r\n   * @type {Size}\r\n   */\r\n  this.itemSize = new Size(120, 100);\r\n\r\n  /**\r\n   * Border width. We use archaic method to layout cursor and highlight frames around nodes, so we need to know border\r\n   * width in order measure gaps between them properly.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.itemBorderWidth = 1;\r\n\r\n  /**\r\n   * Item template. Supported template formats: Control provide two distinct ways to define item templates.\r\n   * The original one is based on setting HTML elements content via innerHTML DOM element property, see following reference \r\n   * at https://developer.mozilla.org web site for more details. The modern way is to use JSON ML library that is our recommended\r\n   * solution for templates definition, see following web site for more details http://www.jsonml.org/. This is only 3d party\r\n   * MIT licensed code included into our code base, everything else is 100% authentic. We adopted it with minor modifications,\r\n   * it generally works according to its original design.\r\n   * \r\n   * The control calls `onItemRender` callback function when specific node cursor needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\r\n  this.itemTemplate = null;\r\n\r\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of the diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for nodes templated with this template.\r\n   * \r\n   * @type {ShapeType}\r\n   */\r\n  this.minimizedItemShapeType = null;\r\n\r\n  /**\r\n   * Marker size.\r\n   * \r\n   * @type {Size}\r\n   */\r\n  this.minimizedItemSize = new Size(4, 4);\r\n\r\n  /**\r\n   * Marker corder radius for simple squares. By default it is null and dots displayed as cycles. If corner radius set to 0 then\r\n   * they are displayed as regular squares.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.minimizedItemCornerRadius = null;\r\n\r\n  /**\r\n   * Marker border line width\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.minimizedItemLineWidth = 1;\r\n\r\n  /**\r\n   * Marker border line color. By default it is the same as `itemTitleColor` of rendered node.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.minimizedItemBorderColor = null;\r\n\r\n  /*\r\n    Marker border line pattern\r\n    \r\n    @type {LineType}\r\n  */\r\n  this.minimizedItemLineType = LineType.Solid;\r\n\r\n  /**\r\n   * Marker fill color. By default it is the same as `itemTitleColor` of rendered node.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.minimizedItemFillColor = null;\r\n\r\n  /**\r\n   * Marker fill color opacity.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.minimizedItemOpacity = 1;\r\n\r\n  /**\r\n   * Highlight frame offset from node.\r\n   * \r\n   * @type {Thickness}\r\n   */\r\n  this.highlightPadding = new Thickness(2, 2, 2, 2);\r\n\r\n  /**\r\n   * Highlight frame border width.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.highlightBorderWidth = 1;\r\n\r\n  /**\r\n   * Highlight Template.\r\n   * \r\n   * The control calls `onHighlightRender` callback function when specific node highlight needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\r\n  this.highlightTemplate = null;\r\n\r\n  /**\r\n   * Cursor frame offset from node.\r\n   * \r\n   * @type {Thickness}\r\n   */\r\n  this.cursorPadding = new Thickness(3, 3, 3, 3);\r\n\r\n  /**\r\n   * Cursor frame border width.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.cursorBorderWidth = 2;\r\n\r\n  /**\r\n   * Cursor Template.\r\n   * \r\n   * The control calls `onCursorRender` callback function when specific node cursor needs to be rendered with this template.\r\n   * \r\n   * @type {string|object}\r\n   */\r\n  this.cursorTemplate = null;\r\n\r\n  /**\r\n   * Sets buttons panel visibility.\r\n   * \r\n   * `Auto` - depends on master config `hasButtons` property setting.\r\n   * `True` - visible\r\n   * `False` - hidden\r\n   * \r\n   * @group Templates\r\n   * @type {boolean}\r\n   */\r\n  this.hasButtons = Enabled.Auto;\r\n\r\n  /**\r\n   * On buttons panel render event. This callback function is called to render context of buttons panel.\r\n   * It is used to replace `buttons` collection property in the control. So we preserve context buttons panel as a functional \r\n   * concept, but eliminate buttons customization API.\r\n   *\r\n   * @callback\r\n   * @param {EventArgs} data Context information\r\n   */\r\n  this.onButtonsRender = null;\r\n};\r\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,+BAA+B;AACrD,OAAOC,IAAI,MAAM,0BAA0B;AAC3C,SAASC,QAAQ,EAAEC,OAAO,QAAQ,UAAU;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,cAAcA,CAAA,EAAG;EACvC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAG,IAAI;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAIN,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC;;EAElC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACO,eAAe,GAAG,CAAC;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,IAAI;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAG,IAAI;;EAElC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,iBAAiB,GAAG,IAAIV,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;;EAEvC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACW,yBAAyB,GAAG,IAAI;;EAErC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAG,CAAC;;EAE/B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,wBAAwB,GAAG,IAAI;;EAEpC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,qBAAqB,GAAGb,QAAQ,CAACc,KAAK;;EAE3C;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAG,IAAI;;EAElC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAG,CAAC;;EAE7B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,IAAInB,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;EAEjD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACoB,oBAAoB,GAAG,CAAC;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,iBAAiB,GAAG,IAAI;;EAE7B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,aAAa,GAAG,IAAItB,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;EAE9C;AACF;AACA;AACA;AACA;EACE,IAAI,CAACuB,iBAAiB,GAAG,CAAC;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAG,IAAI;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGtB,OAAO,CAACuB,IAAI;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,IAAI;AAC7B;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}