{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport PaletteItem from '../structs/PaletteItem';\nimport PolylinesBuffer from '../structs/PolylinesBuffer';\nimport { PlacementType, Colors, LineType } from '../../enums';\nexport default function Callout(graphics) {\n  this.m_graphics = graphics;\n  this.pointerPlacement = PlacementType.Auto;\n  this.cornerRadius = \"10%\";\n  this.offset = 0;\n  this.opacity = 1;\n  this.lineWidth = 1;\n  this.pointerWidth = \"10%\";\n  this.borderColor = Colors.Black;\n  this.lineType = LineType.Solid;\n  this.fillColor = Colors.LightGray;\n  this.m_map = [[PlacementType.TopLeft, PlacementType.Left, PlacementType.BottomLeft], [PlacementType.Top, null, PlacementType.Bottom], [PlacementType.TopRight, PlacementType.Right, PlacementType.BottomRight]];\n}\n;\nCallout.prototype = new BaseShape();\nCallout.prototype.draw = function (snapPoint, position) {\n  position = new Rect(position).offset(this.offset);\n  var pointA = new Point(position.x, position.y),\n    pointB = new Point(position.right(), position.y),\n    pointC = new Point(position.right(), position.bottom()),\n    pointD = new Point(position.left(), position.bottom()),\n    snapPoints = [null, null, null, null, null, null, null, null],\n    points = [pointA, pointB, pointC, pointD],\n    radius = this.m_graphics.getPxSize(this.cornerRadius, Math.min(pointA.distanceTo(pointB), pointB.distanceTo(pointC))),\n    placementType,\n    point,\n    index,\n    attr,\n    linePaletteItem,\n    buffer,\n    polyline;\n  attr = {};\n  if (this.fillColor !== null) {\n    attr.fillColor = this.fillColor;\n    attr.opacity = this.opacity;\n  }\n  if (this.lineColor !== null) {\n    attr.lineColor = this.borderColor;\n  }\n  attr.lineWidth = this.lineWidth;\n  attr.lineType = this.lineType;\n  linePaletteItem = new PaletteItem(attr);\n  buffer = new PolylinesBuffer();\n  polyline = buffer.getPolyline(linePaletteItem);\n  if (snapPoint !== null) {\n    placementType = this.pointerPlacement === PlacementType.Auto ? this._getPlacement(snapPoint, pointA, pointC) : this.pointerPlacement;\n    if (placementType !== null) {\n      snapPoints[placementType] = snapPoint;\n    }\n  }\n  for (index = 0; index < points.length; index += 1) {\n    this._drawSegment(polyline, points[0], points[1], points[2], this.pointerWidth, radius, snapPoints[1], snapPoints[2]);\n    point = points.shift();\n    points.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n  }\n  this.m_graphics.polylinesBuffer(buffer);\n};\nCallout.prototype._getPlacement = function (point, point1, point2) {\n  var row = null,\n    column = null;\n  if (point.x < point1.x) {\n    row = 0;\n  } else if (point.x > point2.x) {\n    row = 2;\n  } else {\n    row = 1;\n  }\n  if (point.y < point1.y) {\n    column = 0;\n  } else if (point.y > point2.y) {\n    column = 2;\n  } else {\n    column = 1;\n  }\n  return this.m_map[row][column];\n};\nCallout.prototype._drawSegment = function (polyline, pointA, pointB, pointC, base, radius, sideSnapPoint, cornerSnapPoint) {\n  var pointA1 = this._offsetPoint(pointA, pointB, radius),\n    pointB1 = this._offsetPoint(pointB, pointA, radius),\n    pointB2 = this._offsetPoint(pointB, pointC, radius),\n    pointS,\n    pointS1,\n    pointS2;\n  base = this.m_graphics.getPxSize(base, pointA.distanceTo(pointB) / 2.0);\n  if (polyline.length() === 0) {\n    polyline.addSegment(new MoveSegment(pointA1));\n  }\n  if (sideSnapPoint !== null) {\n    pointS = this._betweenPoint(pointA, pointB);\n    pointS1 = this._offsetPoint(pointS, pointA, base);\n    pointS2 = this._offsetPoint(pointS, pointB, base);\n    polyline.addSegment(new LineSegment(pointS1));\n    polyline.addSegment(new LineSegment(sideSnapPoint));\n    polyline.addSegment(new LineSegment(pointS2));\n  }\n  polyline.addSegment(new LineSegment(pointB1));\n  if (cornerSnapPoint !== null) {\n    polyline.addSegment(new LineSegment(cornerSnapPoint));\n    polyline.addSegment(new LineSegment(pointB2));\n  } else {\n    polyline.addSegment(new QuadraticArcSegment(pointB, pointB2));\n  }\n};","map":{"version":3,"names":["BaseShape","Point","Rect","MoveSegment","LineSegment","QuadraticArcSegment","PaletteItem","PolylinesBuffer","PlacementType","Colors","LineType","Callout","graphics","m_graphics","pointerPlacement","Auto","cornerRadius","offset","opacity","lineWidth","pointerWidth","borderColor","Black","lineType","Solid","fillColor","LightGray","m_map","TopLeft","Left","BottomLeft","Top","Bottom","TopRight","Right","BottomRight","prototype","draw","snapPoint","position","pointA","x","y","pointB","right","pointC","bottom","pointD","left","snapPoints","points","radius","getPxSize","Math","min","distanceTo","placementType","point","index","attr","linePaletteItem","buffer","polyline","lineColor","getPolyline","_getPlacement","length","_drawSegment","shift","push","polylinesBuffer","point1","point2","row","column","base","sideSnapPoint","cornerSnapPoint","pointA1","_offsetPoint","pointB1","pointB2","pointS","pointS1","pointS2","addSegment","_betweenPoint"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/graphics/shapes/Callout.js"],"sourcesContent":["import BaseShape from './BaseShape';\r\nimport Point from '../structs/Point';\r\nimport Rect from '../structs/Rect';\r\nimport MoveSegment from '../structs/MoveSegment';\r\nimport LineSegment from '../structs/LineSegment';\r\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\r\nimport PaletteItem from '../structs/PaletteItem';\r\nimport PolylinesBuffer from '../structs/PolylinesBuffer';\r\nimport { PlacementType, Colors, LineType } from '../../enums';\r\n\r\n\r\nexport default function Callout(graphics) {\r\n  this.m_graphics = graphics;\r\n\r\n  this.pointerPlacement = PlacementType.Auto;\r\n  this.cornerRadius = \"10%\";\r\n  this.offset = 0;\r\n  this.opacity = 1;\r\n  this.lineWidth = 1;\r\n  this.pointerWidth = \"10%\";\r\n  this.borderColor = Colors.Black;\r\n  this.lineType = LineType.Solid;\r\n  this.fillColor = Colors.LightGray;\r\n\r\n  this.m_map = [[PlacementType.TopLeft, PlacementType.Left, PlacementType.BottomLeft],\r\n  [PlacementType.Top, null, PlacementType.Bottom],\r\n  [PlacementType.TopRight, PlacementType.Right, PlacementType.BottomRight]\r\n  ];\r\n};\r\n\r\nCallout.prototype = new BaseShape();\r\n\r\nCallout.prototype.draw = function (snapPoint, position) {\r\n  position = new Rect(position).offset(this.offset);\r\n\r\n  var pointA = new Point(position.x, position.y),\r\n    pointB = new Point(position.right(), position.y),\r\n    pointC = new Point(position.right(), position.bottom()),\r\n    pointD = new Point(position.left(), position.bottom()),\r\n    snapPoints = [null, null, null, null, null, null, null, null],\r\n    points = [pointA, pointB, pointC, pointD],\r\n    radius = this.m_graphics.getPxSize(this.cornerRadius, Math.min(pointA.distanceTo(pointB), pointB.distanceTo(pointC))),\r\n    placementType,\r\n    point,\r\n    index,\r\n    attr,\r\n    linePaletteItem,\r\n    buffer,\r\n    polyline;\r\n\r\n  attr = {};\r\n  if (this.fillColor !== null) {\r\n    attr.fillColor = this.fillColor;\r\n    attr.opacity = this.opacity;\r\n  }\r\n  if (this.lineColor !== null) {\r\n    attr.lineColor = this.borderColor;\r\n  }\r\n  attr.lineWidth = this.lineWidth;\r\n  attr.lineType = this.lineType;\r\n\r\n  linePaletteItem = new PaletteItem(attr);\r\n  buffer = new PolylinesBuffer();\r\n  polyline = buffer.getPolyline(linePaletteItem);\r\n\r\n  if (snapPoint !== null) {\r\n    placementType = (this.pointerPlacement === PlacementType.Auto) ? this._getPlacement(snapPoint, pointA, pointC) : this.pointerPlacement;\r\n    if (placementType !== null) {\r\n      snapPoints[placementType] = snapPoint;\r\n    }\r\n  }\r\n\r\n  for (index = 0; index < points.length; index += 1) {\r\n    this._drawSegment(polyline, points[0], points[1], points[2], this.pointerWidth, radius, snapPoints[1], snapPoints[2]);\r\n    point = points.shift();\r\n    points.push(point);\r\n    point = snapPoints.shift();\r\n    snapPoints.push(point);\r\n    point = snapPoints.shift();\r\n    snapPoints.push(point);\r\n  }\r\n\r\n  this.m_graphics.polylinesBuffer(buffer);\r\n};\r\n\r\nCallout.prototype._getPlacement = function (point, point1, point2) {\r\n  var row = null,\r\n    column = null;\r\n  if (point.x < point1.x) {\r\n    row = 0;\r\n  }\r\n  else if (point.x > point2.x) {\r\n    row = 2;\r\n  }\r\n  else {\r\n    row = 1;\r\n  }\r\n  if (point.y < point1.y) {\r\n    column = 0;\r\n  }\r\n  else if (point.y > point2.y) {\r\n    column = 2;\r\n  }\r\n  else {\r\n    column = 1;\r\n  }\r\n  return this.m_map[row][column];\r\n};\r\n\r\nCallout.prototype._drawSegment = function (polyline, pointA, pointB, pointC, base, radius, sideSnapPoint, cornerSnapPoint) {\r\n  var pointA1 = this._offsetPoint(pointA, pointB, radius),\r\n    pointB1 = this._offsetPoint(pointB, pointA, radius),\r\n    pointB2 = this._offsetPoint(pointB, pointC, radius),\r\n    pointS,\r\n    pointS1,\r\n    pointS2;\r\n\r\n  base = this.m_graphics.getPxSize(base, pointA.distanceTo(pointB) / 2.0);\r\n\r\n  if (polyline.length() === 0) {\r\n    polyline.addSegment(new MoveSegment(pointA1));\r\n  }\r\n  if (sideSnapPoint !== null) {\r\n    pointS = this._betweenPoint(pointA, pointB);\r\n    pointS1 = this._offsetPoint(pointS, pointA, base);\r\n    pointS2 = this._offsetPoint(pointS, pointB, base);\r\n    polyline.addSegment(new LineSegment(pointS1));\r\n    polyline.addSegment(new LineSegment(sideSnapPoint));\r\n    polyline.addSegment(new LineSegment(pointS2));\r\n  }\r\n\r\n  polyline.addSegment(new LineSegment(pointB1));\r\n  if (cornerSnapPoint !== null) {\r\n    polyline.addSegment(new LineSegment(cornerSnapPoint));\r\n    polyline.addSegment(new LineSegment(pointB2));\r\n  }\r\n  else {\r\n    polyline.addSegment(new QuadraticArcSegment(pointB, pointB2));\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}