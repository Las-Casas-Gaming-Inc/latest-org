{"ast":null,"code":"import Tree from './Tree';\nimport FibonacciHeap from './FibonacciHeap';\n/**\r\n * Creates graph structure\r\n * @class Graph\r\n * \r\n * @returns {Graph} Returns graph object\r\n */\nexport default function Graph() {\n  var _edges = {},\n    MAXIMUMTOTALWEIGHT = 1,\n    MINIMUMWEIGHT = 2;\n\n  /**\r\n   * Adds edge to the graph\r\n   * @param {string} from The id of the start node \r\n   * @param {string} to The id of the end node\r\n   * @param {object} edge The edge contextual object\r\n   */\n  function addEdge(from, to, edge) {\n    if ((_edges[from] == null || _edges[from][to] == null) && edge != null) {\n      if (_edges[from] == null) {\n        _edges[from] = {};\n      }\n      _edges[from][to] = edge;\n      if (_edges[to] == null) {\n        _edges[to] = {};\n      }\n      _edges[to][from] = edge;\n    }\n  }\n\n  /**\r\n   * Returns edge context object\r\n   * \r\n   * @param {string} from The edge's from node id\r\n   * @param {string} to The edge's to node id\r\n   * @returns {object} The edge's context object\r\n   */\n  function edge(from, to) {\n    var result = null;\n    if (_edges[from] != null && _edges[from][to]) {\n      result = _edges[from][to];\n    }\n    return result;\n  }\n\n  /**\r\n   * Returns true if node exists in the graph\r\n   * \r\n   * @param {string} from The node id\r\n   * @returns {boolean} Returns true if node exists\r\n   */\n  function hasNode(from) {\n    return _edges.hasOwnProperty(from);\n  }\n\n  /**\r\n   * Callback for iterating edges of the graph's node\r\n   * \r\n   * @callback onEdgeCallback\r\n   * @param {string} to The neighboring node id\r\n   * @param {Object} edge The edge's context object\r\n   */\n\n  /**\r\n   * Loop edges of the node\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} itemid The node id\r\n   * @param {onEdgeCallback} onEdge A callback function to call for every edge of the node\r\n   */\n  function loopNodeEdges(thisArg, itemid, onEdge) {\n    var neighbours, neighbourKey;\n    if (onEdge != null) {\n      neighbours = _edges[itemid];\n      if (neighbours != null) {\n        for (neighbourKey in neighbours) {\n          if (neighbours.hasOwnProperty(neighbourKey)) {\n            onEdge.call(thisArg, neighbourKey, neighbours[neighbourKey]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback function for iterating graphs nodes\r\n   * \r\n   * @callback onNodeCallback\r\n   * @param {string} to The next neighboring node id\r\n   * @returns {boolean} Returns true to break loop\r\n   */\n\n  /**\r\n   * Loop nodes of the graph\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} [itemid=undefined] The optional start node id. If start node is undefined, \r\n   * function loops graphs node starting from first available node\r\n   * @param {onNodeCallback} onItem A callback function to be called for every neighboring node\r\n   */\n  function loopNodes(thisArg, startNode, onItem) {\n    var processed = {};\n    if (startNode == null) {\n      for (startNode in _edges) {\n        if (_edges.hasOwnProperty(startNode)) {\n          if (!processed.hasOwnProperty[startNode]) {\n            _loopNodes(thisArg, startNode, processed, onItem);\n          }\n        }\n      }\n    } else {\n      _loopNodes(thisArg, startNode, processed, onItem);\n    }\n  }\n  function _loopNodes(thisArg, startNode, processed, onItem) {\n    var margin = [],\n      marginKey,\n      newMargin,\n      index,\n      len,\n      neighbours,\n      neighbourKey;\n    margin.push(startNode);\n    processed[startNode] = true;\n    if (onItem != null) {\n      while (margin.length > 0) {\n        newMargin = [];\n\n        /* iterate neighbours of every node on margin */\n        for (index = 0, len = margin.length; index < len; index += 1) {\n          marginKey = margin[index];\n          if (onItem.call(thisArg, marginKey)) {\n            return;\n          }\n          neighbours = _edges[marginKey];\n          for (neighbourKey in neighbours) {\n            if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n              processed[neighbourKey] = true;\n              newMargin.push(neighbourKey);\n            }\n          }\n        }\n        margin = newMargin;\n      }\n    }\n  }\n\n  /**\r\n   * Callback for finding edge weight\r\n   * \r\n   * @callback getGraphEdgeWeightCallback\r\n   * @param {object} edge The edge context object\r\n   * @param {string} fromItem The edge's start node id\r\n   * @param {string} toItem The edge's end node id\r\n   * @returns {number} Returns weight of the edge\r\n   */\n\n  /**\r\n   * Get maximum spanning tree. Graph may have disconnected sub graphs, so start node is necessary.\r\n   * \r\n   * @param {string} startNode The node to start searching for maximum spanning tree. Graph is not necessary connected\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge.\r\n   * @returns {tree} Returns tree structure containing maximum spanning tree of the graph\r\n   */\n  function getSpanningTree(startNode, getWeightFunc) {\n    var result = Tree(),\n      margin = FibonacciHeap(true),\n      marginNode,\n      parents = {},\n      /* if parent for item is set then it was laready visited */\n      neighbours,\n      neighbourKey,\n      neighbourWeight,\n      currentWeight;\n\n    /* add start node to margin */\n    margin.add(startNode, 0, null /*parent of root node is null*/);\n    parents[startNode] = null;\n\n    /* search graph */\n    while ((marginNode = margin.extractRoot()) != null) {\n      /* iterate neighbours of every node on margin */\n      neighbours = _edges[marginNode.key];\n      for (neighbourKey in neighbours) {\n        if (neighbours.hasOwnProperty(neighbourKey) && !result.node(neighbourKey)) {\n          neighbourWeight = getWeightFunc != null ? getWeightFunc(neighbours[neighbourKey]) : neighbours[neighbourKey];\n          currentWeight = margin.getPriority(neighbourKey);\n          if (currentWeight == null) {\n            margin.add(neighbourKey, neighbourWeight, null);\n            parents[neighbourKey] = marginNode.key.toString();\n          } else {\n            if (currentWeight <= neighbourWeight) {\n              /* improve node distance */\n              margin.setPriority(neighbourKey, neighbourWeight);\n              parents[neighbourKey] = marginNode.key.toString();\n            }\n          }\n        }\n      }\n\n      /* add next margin item to resul tree */\n      result.add(parents[marginNode.key], marginNode.key.toString(), {});\n    }\n    return result;\n  }\n  function _findStartNode(thisArg, onEdgeWeight) {\n    var result = null,\n      fromItem,\n      toItems,\n      toItem,\n      weight = 0,\n      maxWeight = null;\n    for (fromItem in _edges) {\n      if (_edges.hasOwnProperty(fromItem)) {\n        toItems = _edges[fromItem];\n        weight = 0;\n        for (toItem in toItems) {\n          if (toItems.hasOwnProperty(toItem)) {\n            weight += onEdgeWeight.call(thisArg, toItems[toItem], fromItem, toItem);\n          }\n        }\n        if (weight > maxWeight || maxWeight == null) {\n          result = fromItem;\n          maxWeight = weight;\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * Get graph growth sequence. The sequence of graph traversing order.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \r\n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence \r\n   */\n  function getTotalWeightGrowthSequence(thisArg, onEdgeWeight, onItem) {\n    var startNode = _findStartNode(thisArg, onEdgeWeight);\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MAXIMUMTOTALWEIGHT);\n  }\n\n  /**\r\n   * Get minimum weight graph growth sequence. The sequence of the traversing order of the graph nodes.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} [startNode=undefined] The optional start node id \r\n   * @param {getGraphEdgeWeightCallback} onEdgeWeight Callback function to get weight of an edge. \r\n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence\r\n   */\n  function getMinimumWeightGrowthSequence(thisArg, startNode, onEdgeWeight, onItem) {\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MINIMUMWEIGHT);\n  }\n  function _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, growsMode) {\n    var margin = {},\n      marginKey,\n      itemsToRemove = [],\n      /* if margin item has no neighbours to expand we remove it from margin*/\n      hasNeighbours,\n      processed = {},\n      /* if item is set then it was already visited */\n      marginLength = 0,\n      /* curent margin length */\n      nextMarginKey,\n      nextMarginWeight,\n      bestWeight,\n      neighbours,\n      neighbourKey,\n      neighbourWeight,\n      index,\n      len;\n    if (onEdgeWeight != null && onItem != null) {\n      if (startNode == null) {\n        startNode = _findStartNode(thisArg, onEdgeWeight);\n      }\n      if (startNode != null) {\n        onItem.call(thisArg, startNode);\n\n        /* add start node to margin */\n        margin[startNode] = true;\n        marginLength += 1;\n\n        /* add startNode to result tree */\n        processed[startNode] = null;\n\n        /* search graph */\n        while (marginLength > 0) {\n          itemsToRemove = [];\n          nextMarginKey = null;\n          nextMarginWeight = null;\n          bestWeight = {};\n          /* iterate neighbours of every node on margin */\n          for (marginKey in margin) {\n            if (margin.hasOwnProperty(marginKey)) {\n              neighbours = _edges[marginKey];\n              hasNeighbours = false;\n              for (neighbourKey in neighbours) {\n                if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n                  neighbourWeight = onEdgeWeight.call(thisArg, neighbours[neighbourKey], marginKey, neighbourKey);\n                  hasNeighbours = true;\n                  switch (growsMode) {\n                    case MAXIMUMTOTALWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = 0;\n                      }\n                      bestWeight[neighbourKey] += neighbourWeight;\n                      if (!nextMarginWeight || bestWeight[neighbourKey] > nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n                      break;\n                    case MINIMUMWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = neighbourWeight;\n                      } else {\n                        bestWeight[neighbourKey] = Math.min(bestWeight[neighbourKey], neighbourWeight);\n                      }\n                      if (!nextMarginWeight || bestWeight[neighbourKey] < nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n                      break;\n                  }\n                }\n              }\n              if (!hasNeighbours) {\n                itemsToRemove.push(marginKey);\n              }\n            }\n          }\n          if (nextMarginKey == null) {\n            /* no items to expand to exit*/\n            break;\n          } else {\n            margin[nextMarginKey] = true;\n            marginLength += 1;\n            processed[nextMarginKey] = true;\n\n            /* add next margin item to result sequence */\n            onItem.call(thisArg, nextMarginKey);\n          }\n          for (index = 0, len = itemsToRemove.length; index < len; index += 1) {\n            /* delete visited node from margin */\n            delete margin[itemsToRemove[index]];\n            marginLength -= 1;\n          }\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback for returning optimal connection path for every end node.\r\n   * \r\n   * @callback onPathFoundCallback\r\n   * @param {string[]} path An array of connection path node ids.\r\n   * @param {string} to The end node id, the connection path is found for.\r\n   */\n\n  /**\r\n   * Get shortest path between two nodes in graph. The start and the end nodes are supposed to have connection path.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {string[]} endNodes The array of end node ids.\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \r\n   * @param {onPathFoundCallback} onPathFound A callback function to be called for every end node \r\n   * with the optimal connection path\r\n   */\n  function getShortestPath(thisArg, startNode, endNodes, getWeightFunc, onPathFound) {\n    var margin = FibonacciHeap(false),\n      distance = {},\n      breadcramps = {},\n      bestNodeOnMargin,\n      key,\n      children,\n      newDistance,\n      weight,\n      path,\n      currentNode,\n      endNodesHash = {},\n      index,\n      len,\n      endsCount = 0,\n      endsFound = 0;\n\n    /* create hash table of end nodes to find */\n    for (index = 0, len = endNodes.length; index < len; index += 1) {\n      key = endNodes[index];\n      if (!endNodesHash.hasOwnProperty(key)) {\n        endsCount += 1;\n        endNodesHash[key] = true;\n      }\n    }\n\n    /* add start node to margin */\n    margin.add(startNode, 0, null);\n    breadcramps[startNode] = null;\n\n    /* search graph */\n    while ((bestNodeOnMargin = margin.extractRoot()) != null) {\n      /* iterate neighbours of selected node on margin */\n      children = _edges[bestNodeOnMargin.key];\n      for (key in children) {\n        if (children.hasOwnProperty(key)) {\n          weight = 1;\n          if (getWeightFunc != null) {\n            weight = getWeightFunc.call(thisArg, children[key], bestNodeOnMargin, key);\n            newDistance = bestNodeOnMargin.priority + weight;\n          } else {\n            newDistance = bestNodeOnMargin.priority + 1;\n          }\n          if (weight >= 0) {\n            distance = margin.getPriority(key);\n            if (distance != null) {\n              if (distance > newDistance) {\n                margin.setPriority(key, newDistance);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            } else {\n              if (!breadcramps.hasOwnProperty(key)) {\n                margin.add(key, newDistance, null);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            }\n          }\n        }\n      }\n      if (endNodesHash.hasOwnProperty(bestNodeOnMargin.key)) {\n        /* trace path */\n        path = [];\n        currentNode = bestNodeOnMargin.key;\n        while (currentNode != null) {\n          path.push(currentNode);\n          currentNode = breadcramps[currentNode];\n        }\n        onPathFound.call(thisArg, path, bestNodeOnMargin.key);\n        endsFound += 1;\n        if (endsFound >= endsCount) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Callback for iterating path edges\r\n   * \r\n   * @callback onPathEdgeCallback\r\n   * @param {string} from The from node id\r\n   * @param {string} to The to node id\r\n   * @param {Object} edge The edge's context object\r\n   * @returns {boolean} Returns true if edge is usable\r\n   */\n\n  /**\r\n   * Search any path from node to node using depth first search\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {string} endNode The end node id.\r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the node\r\n   */\n  function dfsPath(thisArg, startNode, endNode, onEdge) {\n    var margin = [],\n      backtrace = {};\n    margin.push(startNode);\n    backtrace[startNode] = null;\n    if (startNode != endNode) {\n      /* search graph */\n      while (margin.length > 0 && !backtrace.hasOwnProperty(endNode)) {\n        // Remove last node out of margin\n        var currentNode = margin[margin.length - 1];\n        margin.length -= 1;\n\n        // search its neighbours and add them to margin\n        var neighbours = _edges[currentNode];\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!backtrace.hasOwnProperty(neighbour)) {\n              // node is not passed yet, check edge capacity and add new neighbour to the margin\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                margin.push(neighbour);\n                backtrace[neighbour] = currentNode;\n                if (neighbour == endNode) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    currentNode = endNode;\n    var path = [];\n    while (backtrace.hasOwnProperty(currentNode)) {\n      path.push(currentNode);\n      currentNode = backtrace[currentNode];\n    }\n    var result = [];\n    if (path.length > 0) {\n      for (var index = path.length - 1; index >= 0; index -= 1) {\n        result.push(path[index]);\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * Get Level Graph starting with `startNode`\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\r\n   */\n  function getLevelGraph(thisArg, startNode, onEdge) {\n    var level = {},\n      margin = [],\n      currentNode,\n      currentLevel,\n      neighbours;\n    margin.push(startNode);\n    level[startNode] = 1;\n\n    /* search graph level by level */\n    while (margin.length > 0) {\n      var newMargin = [];\n      for (var index = 0, len = margin.length; index < len; index += 1) {\n        currentNode = margin[index];\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!level.hasOwnProperty(neighbour)) {\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                newMargin.push(neighbour);\n                level[neighbour] = currentLevel + 1;\n              }\n            }\n          }\n        }\n      }\n      margin = newMargin;\n    }\n\n    // Create level graph, copy existing edges to the new graph\n    var levelGraph = Graph();\n    for (currentNode in _edges) {\n      if (level.hasOwnProperty(currentNode)) {\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n        for (neighbour in neighbours) {\n          if (level.hasOwnProperty(neighbour)) {\n            var neighbourLevel = level[neighbour];\n            if (currentLevel + 1 == neighbourLevel) {\n              levelGraph.addEdge(currentNode, neighbour, neighbours[neighbour]);\n            }\n          }\n        }\n      }\n    }\n    return levelGraph;\n  }\n\n  /**\r\n   * Depth first search loop\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\r\n   * @param {onNodeCallback} onNode A callback function to be called for every neighboring node\r\n   */\n  function dfsLoop(thisArg, startNode, onEdge, onNode) {\n    var margin = [],\n      visited = {},\n      currentNode;\n    margin.push(startNode);\n    visited[startNode] = true;\n\n    /* search graph */\n    while (margin.length > 0) {\n      // Remove last node out of margin\n      currentNode = margin[margin.length - 1];\n      margin.length -= 1;\n\n      // search its neighbours and add them to margin\n      var neighbours = _edges[currentNode];\n      for (var neighbour in neighbours) {\n        if (neighbours.hasOwnProperty(neighbour)) {\n          if (!visited.hasOwnProperty(neighbour)) {\n            // node is not passed yet, check edge capacity and add new neighbour to the margin\n            if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n              margin.push(neighbour);\n              visited[neighbour] = true;\n              if (onNode.call(thisArg, neighbour)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return {\n    addEdge: addEdge,\n    edge: edge,\n    hasNode: hasNode,\n    loopNodes: loopNodes,\n    loopNodeEdges: loopNodeEdges,\n    getSpanningTree: getSpanningTree,\n    getTotalWeightGrowthSequence: getTotalWeightGrowthSequence,\n    getMinimumWeightGrowthSequence: getMinimumWeightGrowthSequence,\n    getShortestPath: getShortestPath,\n    dfsPath: dfsPath,\n    getLevelGraph: getLevelGraph,\n    dfsLoop: dfsLoop\n  };\n}\n;","map":{"version":3,"names":["Tree","FibonacciHeap","Graph","_edges","MAXIMUMTOTALWEIGHT","MINIMUMWEIGHT","addEdge","from","to","edge","result","hasNode","hasOwnProperty","loopNodeEdges","thisArg","itemid","onEdge","neighbours","neighbourKey","call","loopNodes","startNode","onItem","processed","_loopNodes","margin","marginKey","newMargin","index","len","push","length","getSpanningTree","getWeightFunc","marginNode","parents","neighbourWeight","currentWeight","add","extractRoot","key","node","getPriority","toString","setPriority","_findStartNode","onEdgeWeight","fromItem","toItems","toItem","weight","maxWeight","getTotalWeightGrowthSequence","_getGrowthSequence","getMinimumWeightGrowthSequence","growsMode","itemsToRemove","hasNeighbours","marginLength","nextMarginKey","nextMarginWeight","bestWeight","Math","min","getShortestPath","endNodes","onPathFound","distance","breadcramps","bestNodeOnMargin","children","newDistance","path","currentNode","endNodesHash","endsCount","endsFound","priority","dfsPath","endNode","backtrace","neighbour","getLevelGraph","level","currentLevel","levelGraph","neighbourLevel","dfsLoop","onNode","visited"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/Graph.js"],"sourcesContent":["import Tree from './Tree';\r\nimport FibonacciHeap from './FibonacciHeap';\r\n/**\r\n * Creates graph structure\r\n * @class Graph\r\n * \r\n * @returns {Graph} Returns graph object\r\n */\r\nexport default function Graph() {\r\n  var _edges = {},\r\n    MAXIMUMTOTALWEIGHT = 1,\r\n    MINIMUMWEIGHT = 2;\r\n\r\n  /**\r\n   * Adds edge to the graph\r\n   * @param {string} from The id of the start node \r\n   * @param {string} to The id of the end node\r\n   * @param {object} edge The edge contextual object\r\n   */\r\n  function addEdge(from, to, edge) {\r\n    if ((_edges[from] == null || _edges[from][to] == null) && edge != null) {\r\n\r\n      if (_edges[from] == null) {\r\n        _edges[from] = {};\r\n      }\r\n      _edges[from][to] = edge;\r\n\r\n      if (_edges[to] == null) {\r\n        _edges[to] = {};\r\n      }\r\n      _edges[to][from] = edge;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns edge context object\r\n   * \r\n   * @param {string} from The edge's from node id\r\n   * @param {string} to The edge's to node id\r\n   * @returns {object} The edge's context object\r\n   */\r\n  function edge(from, to) {\r\n    var result = null;\r\n    if (_edges[from] != null && _edges[from][to]) {\r\n      result = _edges[from][to];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns true if node exists in the graph\r\n   * \r\n   * @param {string} from The node id\r\n   * @returns {boolean} Returns true if node exists\r\n   */\r\n  function hasNode(from) {\r\n    return _edges.hasOwnProperty(from);\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating edges of the graph's node\r\n   * \r\n   * @callback onEdgeCallback\r\n   * @param {string} to The neighboring node id\r\n   * @param {Object} edge The edge's context object\r\n   */\r\n\r\n  /**\r\n   * Loop edges of the node\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} itemid The node id\r\n   * @param {onEdgeCallback} onEdge A callback function to call for every edge of the node\r\n   */\r\n  function loopNodeEdges(thisArg, itemid, onEdge) {\r\n    var neighbours, neighbourKey;\r\n    if (onEdge != null) {\r\n      neighbours = _edges[itemid];\r\n      if (neighbours != null) {\r\n        for (neighbourKey in neighbours) {\r\n          if (neighbours.hasOwnProperty(neighbourKey)) {\r\n            onEdge.call(thisArg, neighbourKey, neighbours[neighbourKey]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback function for iterating graphs nodes\r\n   * \r\n   * @callback onNodeCallback\r\n   * @param {string} to The next neighboring node id\r\n   * @returns {boolean} Returns true to break loop\r\n   */\r\n\r\n  /**\r\n   * Loop nodes of the graph\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} [itemid=undefined] The optional start node id. If start node is undefined, \r\n   * function loops graphs node starting from first available node\r\n   * @param {onNodeCallback} onItem A callback function to be called for every neighboring node\r\n   */\r\n  function loopNodes(thisArg, startNode, onItem) {\r\n    var processed = {};\r\n    if (startNode == null) {\r\n      for (startNode in _edges) {\r\n        if (_edges.hasOwnProperty(startNode)) {\r\n          if (!processed.hasOwnProperty[startNode]) {\r\n            _loopNodes(thisArg, startNode, processed, onItem);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      _loopNodes(thisArg, startNode, processed, onItem);\r\n    }\r\n  }\r\n\r\n  function _loopNodes(thisArg, startNode, processed, onItem) {\r\n    var margin = [],\r\n      marginKey,\r\n      newMargin,\r\n      index, len,\r\n      neighbours, neighbourKey;\r\n\r\n    margin.push(startNode);\r\n    processed[startNode] = true;\r\n    if (onItem != null) {\r\n      while (margin.length > 0) {\r\n        newMargin = [];\r\n\r\n        /* iterate neighbours of every node on margin */\r\n        for (index = 0, len = margin.length; index < len; index += 1) {\r\n          marginKey = margin[index];\r\n\r\n          if (onItem.call(thisArg, marginKey)) {\r\n            return;\r\n          }\r\n\r\n          neighbours = _edges[marginKey];\r\n          for (neighbourKey in neighbours) {\r\n            if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\r\n              processed[neighbourKey] = true;\r\n              newMargin.push(neighbourKey);\r\n            }\r\n          }\r\n        }\r\n        margin = newMargin;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for finding edge weight\r\n   * \r\n   * @callback getGraphEdgeWeightCallback\r\n   * @param {object} edge The edge context object\r\n   * @param {string} fromItem The edge's start node id\r\n   * @param {string} toItem The edge's end node id\r\n   * @returns {number} Returns weight of the edge\r\n   */\r\n\r\n  /**\r\n   * Get maximum spanning tree. Graph may have disconnected sub graphs, so start node is necessary.\r\n   * \r\n   * @param {string} startNode The node to start searching for maximum spanning tree. Graph is not necessary connected\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge.\r\n   * @returns {tree} Returns tree structure containing maximum spanning tree of the graph\r\n   */\r\n  function getSpanningTree(startNode, getWeightFunc) {\r\n    var result = Tree(),\r\n      margin = FibonacciHeap(true),\r\n      marginNode,\r\n      parents = {}, /* if parent for item is set then it was laready visited */\r\n      neighbours, neighbourKey, neighbourWeight, currentWeight;\r\n\r\n    /* add start node to margin */\r\n    margin.add(startNode, 0, null /*parent of root node is null*/);\r\n    parents[startNode] = null;\r\n\r\n    /* search graph */\r\n    while ((marginNode = margin.extractRoot()) != null) {\r\n\r\n      /* iterate neighbours of every node on margin */\r\n      neighbours = _edges[marginNode.key];\r\n\r\n      for (neighbourKey in neighbours) {\r\n        if (neighbours.hasOwnProperty(neighbourKey) && !result.node(neighbourKey)) {\r\n          neighbourWeight = getWeightFunc != null ? getWeightFunc(neighbours[neighbourKey]) : neighbours[neighbourKey];\r\n\r\n          currentWeight = margin.getPriority(neighbourKey);\r\n          if (currentWeight == null) {\r\n            margin.add(neighbourKey, neighbourWeight, null);\r\n            parents[neighbourKey] = marginNode.key.toString();\r\n          } else {\r\n            if (currentWeight <= neighbourWeight) {\r\n              /* improve node distance */\r\n              margin.setPriority(neighbourKey, neighbourWeight);\r\n              parents[neighbourKey] = marginNode.key.toString();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /* add next margin item to resul tree */\r\n      result.add(parents[marginNode.key], marginNode.key.toString(), {});\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function _findStartNode(thisArg, onEdgeWeight) {\r\n    var result = null,\r\n      fromItem, toItems, toItem,\r\n      weight = 0,\r\n      maxWeight = null;\r\n\r\n    for (fromItem in _edges) {\r\n      if (_edges.hasOwnProperty(fromItem)) {\r\n        toItems = _edges[fromItem];\r\n\r\n        weight = 0;\r\n        for (toItem in toItems) {\r\n          if (toItems.hasOwnProperty(toItem)) {\r\n            weight += onEdgeWeight.call(thisArg, toItems[toItem], fromItem, toItem);\r\n          }\r\n        }\r\n        if (weight > maxWeight || maxWeight == null) {\r\n          result = fromItem;\r\n          maxWeight = weight;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get graph growth sequence. The sequence of graph traversing order.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \r\n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence \r\n   */\r\n  function getTotalWeightGrowthSequence(thisArg, onEdgeWeight, onItem) {\r\n    var startNode = _findStartNode(thisArg, onEdgeWeight);\r\n\r\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MAXIMUMTOTALWEIGHT);\r\n  }\r\n\r\n  /**\r\n   * Get minimum weight graph growth sequence. The sequence of the traversing order of the graph nodes.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} [startNode=undefined] The optional start node id \r\n   * @param {getGraphEdgeWeightCallback} onEdgeWeight Callback function to get weight of an edge. \r\n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence\r\n   */\r\n  function getMinimumWeightGrowthSequence(thisArg, startNode, onEdgeWeight, onItem) {\r\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MINIMUMWEIGHT);\r\n  }\r\n\r\n  function _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, growsMode) {\r\n    var margin = {}, marginKey,\r\n      itemsToRemove = [], /* if margin item has no neighbours to expand we remove it from margin*/\r\n      hasNeighbours,\r\n      processed = {}, /* if item is set then it was already visited */\r\n      marginLength = 0, /* curent margin length */\r\n      nextMarginKey,\r\n      nextMarginWeight,\r\n      bestWeight,\r\n      neighbours, neighbourKey, neighbourWeight,\r\n      index, len;\r\n\r\n    if (onEdgeWeight != null && onItem != null) {\r\n      if (startNode == null) {\r\n        startNode = _findStartNode(thisArg, onEdgeWeight);\r\n      }\r\n\r\n      if (startNode != null) {\r\n\r\n        onItem.call(thisArg, startNode);\r\n\r\n        /* add start node to margin */\r\n        margin[startNode] = true;\r\n        marginLength += 1;\r\n\r\n        /* add startNode to result tree */\r\n        processed[startNode] = null;\r\n\r\n        /* search graph */\r\n        while (marginLength > 0) {\r\n          itemsToRemove = [];\r\n          nextMarginKey = null;\r\n          nextMarginWeight = null;\r\n          bestWeight = {};\r\n          /* iterate neighbours of every node on margin */\r\n          for (marginKey in margin) {\r\n            if (margin.hasOwnProperty(marginKey)) {\r\n              neighbours = _edges[marginKey];\r\n              hasNeighbours = false;\r\n\r\n              for (neighbourKey in neighbours) {\r\n                if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\r\n                  neighbourWeight = onEdgeWeight.call(thisArg, neighbours[neighbourKey], marginKey, neighbourKey);\r\n                  hasNeighbours = true;\r\n\r\n                  switch (growsMode) {\r\n                    case MAXIMUMTOTALWEIGHT:\r\n                      if (bestWeight[neighbourKey] == null) {\r\n                        bestWeight[neighbourKey] = 0;\r\n                      }\r\n                      bestWeight[neighbourKey] += neighbourWeight;\r\n\r\n                      if (!nextMarginWeight || bestWeight[neighbourKey] > nextMarginWeight) {\r\n                        nextMarginKey = neighbourKey;\r\n                        nextMarginWeight = bestWeight[neighbourKey];\r\n                      }\r\n                      break;\r\n                    case MINIMUMWEIGHT:\r\n                      if (bestWeight[neighbourKey] == null) {\r\n                        bestWeight[neighbourKey] = neighbourWeight;\r\n                      } else {\r\n                        bestWeight[neighbourKey] = Math.min(bestWeight[neighbourKey], neighbourWeight);\r\n                      }\r\n\r\n                      if (!nextMarginWeight || bestWeight[neighbourKey] < nextMarginWeight) {\r\n                        nextMarginKey = neighbourKey;\r\n                        nextMarginWeight = bestWeight[neighbourKey];\r\n                      }\r\n                      break;\r\n                  }\r\n                }\r\n              }\r\n\r\n              if (!hasNeighbours) {\r\n                itemsToRemove.push(marginKey);\r\n              }\r\n            }\r\n          }\r\n\r\n          if (nextMarginKey == null) {\r\n            /* no items to expand to exit*/\r\n            break;\r\n          } else {\r\n            margin[nextMarginKey] = true;\r\n            marginLength += 1;\r\n            processed[nextMarginKey] = true;\r\n\r\n            /* add next margin item to result sequence */\r\n            onItem.call(thisArg, nextMarginKey);\r\n          }\r\n\r\n          for (index = 0, len = itemsToRemove.length; index < len; index += 1) {\r\n            /* delete visited node from margin */\r\n            delete margin[itemsToRemove[index]];\r\n            marginLength -= 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for returning optimal connection path for every end node.\r\n   * \r\n   * @callback onPathFoundCallback\r\n   * @param {string[]} path An array of connection path node ids.\r\n   * @param {string} to The end node id, the connection path is found for.\r\n   */\r\n\r\n  /**\r\n   * Get shortest path between two nodes in graph. The start and the end nodes are supposed to have connection path.\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {string[]} endNodes The array of end node ids.\r\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \r\n   * @param {onPathFoundCallback} onPathFound A callback function to be called for every end node \r\n   * with the optimal connection path\r\n   */\r\n  function getShortestPath(thisArg, startNode, endNodes, getWeightFunc, onPathFound) {\r\n    var margin = FibonacciHeap(false),\r\n      distance = {},\r\n      breadcramps = {},\r\n      bestNodeOnMargin,\r\n      key,\r\n      children,\r\n      newDistance,\r\n      weight,\r\n      path,\r\n      currentNode,\r\n      endNodesHash = {},\r\n      index, len,\r\n      endsCount = 0, endsFound = 0;\r\n\r\n    /* create hash table of end nodes to find */\r\n    for (index = 0, len = endNodes.length; index < len; index += 1) {\r\n      key = endNodes[index];\r\n\r\n      if (!endNodesHash.hasOwnProperty(key)) {\r\n        endsCount += 1;\r\n        endNodesHash[key] = true;\r\n      }\r\n    }\r\n\r\n    /* add start node to margin */\r\n    margin.add(startNode, 0, null);\r\n    breadcramps[startNode] = null;\r\n\r\n    /* search graph */\r\n    while ((bestNodeOnMargin = margin.extractRoot()) != null) {\r\n      /* iterate neighbours of selected node on margin */\r\n      children = _edges[bestNodeOnMargin.key];\r\n      for (key in children) {\r\n        if (children.hasOwnProperty(key)) {\r\n          weight = 1;\r\n          if (getWeightFunc != null) {\r\n            weight = getWeightFunc.call(thisArg, children[key], bestNodeOnMargin, key);\r\n            newDistance = bestNodeOnMargin.priority + weight;\r\n          } else {\r\n            newDistance = bestNodeOnMargin.priority + 1;\r\n          }\r\n          if (weight >= 0) {\r\n            distance = margin.getPriority(key);\r\n            if (distance != null) {\r\n              if (distance > newDistance) {\r\n                margin.setPriority(key, newDistance);\r\n                breadcramps[key] = bestNodeOnMargin.key;\r\n              }\r\n            } else {\r\n              if (!breadcramps.hasOwnProperty(key)) {\r\n                margin.add(key, newDistance, null);\r\n                breadcramps[key] = bestNodeOnMargin.key;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (endNodesHash.hasOwnProperty(bestNodeOnMargin.key)) {\r\n        /* trace path */\r\n        path = [];\r\n        currentNode = bestNodeOnMargin.key;\r\n        while (currentNode != null) {\r\n          path.push(currentNode);\r\n          currentNode = breadcramps[currentNode];\r\n        }\r\n        onPathFound.call(thisArg, path, bestNodeOnMargin.key);\r\n\r\n        endsFound += 1;\r\n        if (endsFound >= endsCount) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for iterating path edges\r\n   * \r\n   * @callback onPathEdgeCallback\r\n   * @param {string} from The from node id\r\n   * @param {string} to The to node id\r\n   * @param {Object} edge The edge's context object\r\n   * @returns {boolean} Returns true if edge is usable\r\n   */\r\n\r\n  /**\r\n   * Search any path from node to node using depth first search\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {string} endNode The end node id.\r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the node\r\n   */\r\n  function dfsPath(thisArg, startNode, endNode, onEdge) {\r\n    var margin = [],\r\n      backtrace = {};\r\n\r\n    margin.push(startNode);\r\n    backtrace[startNode] = null;\r\n\r\n    if (startNode != endNode) {\r\n      /* search graph */\r\n      while (margin.length > 0 && !backtrace.hasOwnProperty(endNode)) {\r\n        // Remove last node out of margin\r\n        var currentNode = margin[margin.length - 1];\r\n        margin.length -= 1;\r\n\r\n        // search its neighbours and add them to margin\r\n        var neighbours = _edges[currentNode];\r\n        for (var neighbour in neighbours) {\r\n          if (neighbours.hasOwnProperty(neighbour)) {\r\n            if (!backtrace.hasOwnProperty(neighbour)) {\r\n              // node is not passed yet, check edge capacity and add new neighbour to the margin\r\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\r\n                margin.push(neighbour);\r\n                backtrace[neighbour] = currentNode;\r\n                if (neighbour == endNode) {\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    currentNode = endNode;\r\n    var path = [];\r\n    while (backtrace.hasOwnProperty(currentNode)) {\r\n      path.push(currentNode);\r\n      currentNode = backtrace[currentNode];\r\n    }\r\n    var result = [];\r\n    if (path.length > 0) {\r\n      for (var index = path.length - 1; index >= 0; index -= 1) {\r\n        result.push(path[index]);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get Level Graph starting with `startNode`\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\r\n   */\r\n  function getLevelGraph(thisArg, startNode, onEdge) {\r\n    var level = {},\r\n      margin = [],\r\n      currentNode,\r\n      currentLevel,\r\n      neighbours;\r\n\r\n    margin.push(startNode);\r\n    level[startNode] = 1;\r\n\r\n    /* search graph level by level */\r\n    while (margin.length > 0) {\r\n      var newMargin = [];\r\n      for (var index = 0, len = margin.length; index < len; index += 1) {\r\n        currentNode = margin[index];\r\n        currentLevel = level[currentNode];\r\n        neighbours = _edges[currentNode];\r\n        for (var neighbour in neighbours) {\r\n          if (neighbours.hasOwnProperty(neighbour)) {\r\n            if (!level.hasOwnProperty(neighbour)) {\r\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\r\n                newMargin.push(neighbour);\r\n                level[neighbour] = currentLevel + 1;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      margin = newMargin;\r\n    }\r\n\r\n    // Create level graph, copy existing edges to the new graph\r\n  var levelGraph = Graph();\r\n    for (currentNode in _edges) {\r\n      if (level.hasOwnProperty(currentNode)) {\r\n        currentLevel = level[currentNode];\r\n        neighbours = _edges[currentNode];\r\n        for (neighbour in neighbours) {\r\n          if (level.hasOwnProperty(neighbour)) {\r\n            var neighbourLevel = level[neighbour];\r\n            if (currentLevel + 1 == neighbourLevel) {\r\n              levelGraph.addEdge(currentNode, neighbour, neighbours[neighbour]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return levelGraph;\r\n  }\r\n\r\n  /**\r\n   * Depth first search loop\r\n   * \r\n   * @param {object} thisArg The callback function invocation context\r\n   * @param {string} startNode The start node id \r\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\r\n   * @param {onNodeCallback} onNode A callback function to be called for every neighboring node\r\n   */\r\n  function dfsLoop(thisArg, startNode, onEdge, onNode) {\r\n    var margin = [],\r\n      visited = {},\r\n      currentNode;\r\n\r\n    margin.push(startNode);\r\n    visited[startNode] = true;\r\n\r\n    /* search graph */\r\n    while (margin.length > 0) {\r\n      // Remove last node out of margin\r\n      currentNode = margin[margin.length - 1];\r\n      margin.length -= 1;\r\n\r\n      // search its neighbours and add them to margin\r\n      var neighbours = _edges[currentNode];\r\n      for (var neighbour in neighbours) {\r\n        if (neighbours.hasOwnProperty(neighbour)) {\r\n          if (!visited.hasOwnProperty(neighbour)) {\r\n            // node is not passed yet, check edge capacity and add new neighbour to the margin\r\n            if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\r\n              margin.push(neighbour);\r\n              visited[neighbour] = true;\r\n              if (onNode.call(thisArg, neighbour)) {\r\n                return;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    addEdge: addEdge,\r\n    edge: edge,\r\n    hasNode: hasNode,\r\n    loopNodes: loopNodes,\r\n    loopNodeEdges: loopNodeEdges,\r\n    getSpanningTree: getSpanningTree,\r\n    getTotalWeightGrowthSequence: getTotalWeightGrowthSequence,\r\n    getMinimumWeightGrowthSequence: getMinimumWeightGrowthSequence,\r\n    getShortestPath: getShortestPath,\r\n    dfsPath: dfsPath,\r\n    getLevelGraph: getLevelGraph,\r\n    dfsLoop: dfsLoop\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}