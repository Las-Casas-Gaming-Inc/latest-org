{"ast":null,"code":"import { ElbowType, Visibility, ConnectorType } from '../enums';\nimport Rect from '../graphics/structs/Rect';\nimport Point from '../graphics/structs/Point';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nimport CubicArcSegment from '../graphics/structs/CubicArcSegment';\nimport QuadraticArcSegment from '../graphics/structs/QuadraticArcSegment';\nexport default function BaseConnectorBundle() {\n  this.NORMAL_ITEM_WEIGHT = 10010;\n  this.LINE_ITEM_WEIGHT = 10000;\n}\n;\nBaseConnectorBundle.prototype.trace = function (data, params, options) {\n  //var data = {\n  //  graph: null, //Graph\n  //  nodeid: 0\n  //};\n\n  //var params = {\n  //  treeItemsPositions: [],\n  //  transform: null\n  //};\n\n  //var options = {\n  //  connectorType: ConnectorType.Squared,\n  //  showExtraArrows: true,\n  //  bevelSize: 4,\n  //  elbowType: ElbowType.None\n  //};\n};\nBaseConnectorBundle.prototype.getId = function (data) {\n  var result = \"_\" + data.nodeid;\n  data.nodeid += 1;\n  return result;\n};\nBaseConnectorBundle.prototype.ConnectorEdge = function (from, to, polyline, parentsArrowId, childrenArrowId, dotId, weight, fromOffset, hasMiddle, middleParent, hasArrow) {\n  this.polyline = polyline;\n  this.from = from;\n  this.to = to;\n  this.weight = weight || 0;\n  this.fromOffset = fromOffset || 0;\n  this.hasArrow = hasArrow || false;\n  this.parentsArrowId = parentsArrowId;\n  this.childrenArrowId = childrenArrowId;\n  this.dotId = dotId;\n\n  /* draw extra arrows along long segments, the hasMiddle should be true and middleParent is parent point id */\n  this.hasMiddle = hasMiddle;\n  this.middleParent = middleParent;\n  this.isOppositeFlow = false;\n};\nBaseConnectorBundle.prototype.ConnectorDestination = function (options) {\n  this.id = null;\n  this.x = null;\n  this.y = null;\n  this.bundleid = null;\n  this.hasElbow = false;\n  this.elbowPoint1 = null;\n  this.elbowPoint2 = null;\n  this.visibility = null;\n  this.isSquared = true;\n  for (var key in options) {\n    if (options.hasOwnProperty(key)) {\n      this[key] = options[key];\n    }\n  }\n};\nBaseConnectorBundle.prototype.traceFork = function (data, params, options, parentPoint, points, hasSquared, isParents, fromOffset, showHorizontalArrows) {\n  var startIndex,\n    endIndex,\n    len,\n    connectorPoint,\n    curvedPoints = [],\n    bundlePoint,\n    connectorDestination,\n    index,\n    polyline,\n    bevelSize,\n    fromPoint,\n    fromPointId,\n    toPoint,\n    toPointId;\n  if (hasSquared) {\n    /* draw curved or angular lines on left side of pack */\n    curvedPoints = [];\n    for (startIndex = 0, len = points.length; startIndex < len; startIndex += 1) {\n      connectorPoint = points[startIndex];\n      if (connectorPoint.x < parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n    len = curvedPoints.length;\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n\n    /* draw curved or angular lines on right side of pack */\n    curvedPoints = [];\n    for (endIndex = points.length - 1; endIndex >= startIndex; endIndex -= 1) {\n      connectorPoint = points[endIndex];\n      if (connectorPoint.x > parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n    len = curvedPoints.length;\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n\n    /* calculate elbows of vertical connectors */\n    for (index = startIndex; index <= endIndex; index += 1) {\n      connectorPoint = points[index];\n      bevelSize = options.bevelSize;\n      if (bevelSize < 2) {\n        bevelSize = 0;\n      }\n      switch (options.elbowType) {\n        case ElbowType.Bevel:\n        case ElbowType.Round:\n          if (bevelSize > 0 && Math.abs(parentPoint.x - connectorPoint.x) > bevelSize && Math.abs(parentPoint.y - connectorPoint.y) > bevelSize) {\n            connectorPoint.hasElbow = true;\n            connectorPoint.elbowPoint1 = new Point(connectorPoint.x, parentPoint.y + (parentPoint.y > connectorPoint.y ? -bevelSize : bevelSize));\n            connectorPoint.elbowPoint2 = new Point(connectorPoint.x + (parentPoint.x > connectorPoint.x ? bevelSize : -bevelSize), parentPoint.y);\n          }\n          break;\n        default:\n          break;\n      }\n\n      /* draw vertical segment */\n      polyline = new Polyline();\n      if (connectorPoint.hasElbow) {\n        params.transform.transform3Points(connectorPoint.elbowPoint2.x, connectorPoint.elbowPoint2.y, connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint2.y, connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, true, this, function (fromX, fromY, toX, toY, toX2, toY2) {\n          switch (options.elbowType) {\n            case ElbowType.Bevel:\n              polyline.addSegment(new MoveSegment(fromX, fromY));\n              polyline.addSegment(new LineSegment(toX2, toY2));\n              break;\n            case ElbowType.Round:\n              polyline.addSegment(new MoveSegment(fromX, fromY));\n              polyline.addSegment(new CubicArcSegment(fromX, fromY, toX, toY, toX2, toY2));\n              break;\n          }\n        }); //ignore jslint\n\n        params.transform.transformPoints(connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      } else {\n        params.transform.transformPoints(connectorPoint.x, parentPoint.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      }\n      var bundleid = connectorPoint.x == parentPoint.x ? parentPoint.id : connectorPoint.bundleid;\n      var isVisible = connectorPoint.visibility !== Visibility.Invisible;\n      data.graph.addEdge(bundleid, connectorPoint.id, new this.ConnectorEdge(bundleid, connectorPoint.id, polyline, isParents ? connectorPoint.id : null, !isParents ? connectorPoint.id : null, null, isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT /* weight*/, fromOffset, null, null, isVisible));\n    }\n\n    /* draw segments on the right of parent point */\n    startIndex = Math.max(startIndex - 1, 0);\n    endIndex = Math.min(endIndex + 1, points.length - 1);\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n    for (index = startIndex; index <= endIndex; index += 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n      if (toPoint.x > fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */, fromOffset, /* draw middle arrows */\n        showHorizontalArrows, isParents ? toPointId : fromPointId));\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n\n    /* draw segments on the left of parent point */\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n    for (index = endIndex; index >= startIndex; index -= 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n      if (toPoint.x < fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */, fromOffset, /* draw middle arrows */\n        showHorizontalArrows, isParents ? toPointId : fromPointId));\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n  } else {\n    /* all lines are angular or curved */\n    this.traceAngularSegments(data, params, options, parentPoint, points, true);\n  }\n};\nBaseConnectorBundle.prototype.traceAngularSegments = function (data, params, options, bundlePoint, points, drawToBundle) {\n  var index, len, rect, point, polyline;\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n    polyline = new Polyline();\n    params.transform.transformPoint(bundlePoint.x, bundlePoint.y, true, this, function (x, y) {\n      polyline.addSegment(new MoveSegment(x, y));\n    }); //ignore jslint\n\n    switch (options.connectorType) {\n      case ConnectorType.Angular:\n        params.transform.transformPoint(point.x, point.y, true, this, function (x, y) {\n          polyline.addSegment(new LineSegment(x, y));\n        }); //ignore jslint\n        break;\n      case ConnectorType.Curved:\n        rect = new Rect(bundlePoint, point);\n        if (drawToBundle) {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transform3Points(rect.right(), rect.verticalCenter(), rect.x, rect.verticalCenter(), rect.x, rect.bottom(), true, this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n              polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n            }); //ignore jslint\n          } else {\n            params.transform.transform3Points(rect.x, rect.verticalCenter(), rect.right(), rect.verticalCenter(), rect.right(), rect.bottom(), true, this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n              polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n            }); //ignore jslint\n          }\n        } else {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transformPoints(rect.x, rect.y, rect.x, rect.bottom(), true, this, function (cpX, cpY, x, y) {\n              polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n            }); //ignore jslint\n          } else {\n            params.transform.transformPoints(rect.right(), rect.y, rect.right(), rect.bottom(), true, this, function (cpX, cpY, x, y) {\n              polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n            }); //ignore jslint\n          }\n        }\n        break;\n    }\n    var isVisible = point.visibility !== Visibility.Invisible;\n    data.graph.addEdge(bundlePoint.id, point.id, new this.ConnectorEdge(bundlePoint.id, point.id, polyline, null, isVisible ? point.id : null, isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT, null, null, null, true));\n  }\n};","map":{"version":3,"names":["ElbowType","Visibility","ConnectorType","Rect","Point","Polyline","MoveSegment","LineSegment","CubicArcSegment","QuadraticArcSegment","BaseConnectorBundle","NORMAL_ITEM_WEIGHT","LINE_ITEM_WEIGHT","prototype","trace","data","params","options","getId","result","nodeid","ConnectorEdge","from","to","polyline","parentsArrowId","childrenArrowId","dotId","weight","fromOffset","hasMiddle","middleParent","hasArrow","isOppositeFlow","ConnectorDestination","id","x","y","bundleid","hasElbow","elbowPoint1","elbowPoint2","visibility","isSquared","key","hasOwnProperty","traceFork","parentPoint","points","hasSquared","isParents","showHorizontalArrows","startIndex","endIndex","len","connectorPoint","curvedPoints","bundlePoint","connectorDestination","index","bevelSize","fromPoint","fromPointId","toPoint","toPointId","length","push","traceAngularSegments","elbowType","Bevel","Round","Math","abs","transform","transform3Points","fromX","fromY","toX","toY","toX2","toY2","addSegment","transformPoints","isVisible","Invisible","graph","addEdge","max","min","startX","startY","endX","endY","drawToBundle","rect","point","transformPoint","connectorType","Angular","Curved","right","verticalCenter","bottom","cpX1","cpY1","cpX2","cpY2","cpX","cpY"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/connectors/BaseConnectorBundle.js"],"sourcesContent":["import { ElbowType, Visibility, ConnectorType } from '../enums';\r\nimport Rect from '../graphics/structs/Rect';\r\nimport Point from '../graphics/structs/Point';\r\nimport Polyline from '../graphics/structs/Polyline';\r\nimport MoveSegment from '../graphics/structs/MoveSegment';\r\nimport LineSegment from '../graphics/structs/LineSegment';\r\nimport CubicArcSegment from '../graphics/structs/CubicArcSegment';\r\nimport QuadraticArcSegment from '../graphics/structs/QuadraticArcSegment';\r\n\r\nexport default function BaseConnectorBundle() {\r\n  this.NORMAL_ITEM_WEIGHT = 10010;\r\n  this.LINE_ITEM_WEIGHT = 10000;\r\n};\r\n\r\n\r\nBaseConnectorBundle.prototype.trace = function (data, params, options) {\r\n  //var data = {\r\n  //  graph: null, //Graph\r\n  //  nodeid: 0\r\n  //};\r\n\r\n  //var params = {\r\n  //  treeItemsPositions: [],\r\n  //  transform: null\r\n  //};\r\n\r\n  //var options = {\r\n  //  connectorType: ConnectorType.Squared,\r\n  //  showExtraArrows: true,\r\n  //  bevelSize: 4,\r\n  //  elbowType: ElbowType.None\r\n  //};\r\n};\r\n\r\nBaseConnectorBundle.prototype.getId = function (data) {\r\n  var result = \"_\" + data.nodeid;\r\n  data.nodeid += 1;\r\n  return result;\r\n};\r\n\r\nBaseConnectorBundle.prototype.ConnectorEdge = function (from, to, polyline, parentsArrowId, childrenArrowId, dotId, weight, fromOffset, hasMiddle, middleParent, hasArrow) {\r\n  this.polyline = polyline;\r\n  this.from = from;\r\n  this.to = to;\r\n\r\n  this.weight = weight || 0;\r\n  this.fromOffset = fromOffset || 0;\r\n\r\n  this.hasArrow = hasArrow || false;\r\n  this.parentsArrowId = parentsArrowId;\r\n  this.childrenArrowId = childrenArrowId;\r\n  this.dotId = dotId;\r\n\r\n  /* draw extra arrows along long segments, the hasMiddle should be true and middleParent is parent point id */\r\n  this.hasMiddle = hasMiddle;\r\n  this.middleParent = middleParent;\r\n  this.isOppositeFlow = false;\r\n};\r\n\r\nBaseConnectorBundle.prototype.ConnectorDestination = function (options) {\r\n  this.id = null;\r\n  this.x = null;\r\n  this.y = null;\r\n  this.bundleid = null;\r\n  this.hasElbow = false;\r\n  this.elbowPoint1 = null;\r\n  this.elbowPoint2 = null;\r\n  this.visibility = null;\r\n  this.isSquared = true;\r\n\r\n  for (var key in options) {\r\n    if (options.hasOwnProperty(key)) {\r\n      this[key] = options[key];\r\n    }\r\n  }\r\n};\r\n\r\nBaseConnectorBundle.prototype.traceFork = function (data, params, options, parentPoint, points, hasSquared, isParents, fromOffset, showHorizontalArrows) {\r\n  var startIndex, endIndex, len,\r\n    connectorPoint, curvedPoints = [], bundlePoint, connectorDestination,\r\n    index,\r\n    polyline,\r\n    bevelSize,\r\n    fromPoint, fromPointId, toPoint, toPointId;\r\n\r\n  if (hasSquared) {\r\n    /* draw curved or angular lines on left side of pack */\r\n    curvedPoints = [];\r\n    for (startIndex = 0, len = points.length; startIndex < len; startIndex += 1) {\r\n      connectorPoint = points[startIndex];\r\n      if (connectorPoint.x < parentPoint.x && !connectorPoint.isSquared) {\r\n        curvedPoints.push(connectorPoint);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    len = curvedPoints.length;\r\n    if (len > 0) {\r\n      connectorDestination = curvedPoints[len - 1];\r\n      bundlePoint = (connectorDestination.x == parentPoint.x) ? parentPoint : new this.ConnectorDestination({\r\n        id: connectorDestination.bundleid,\r\n        x: connectorDestination.x,\r\n        y: parentPoint.y\r\n      });\r\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\r\n    }\r\n\r\n    /* draw curved or angular lines on right side of pack */\r\n    curvedPoints = [];\r\n    for (endIndex = points.length - 1; endIndex >= startIndex; endIndex -= 1) {\r\n      connectorPoint = points[endIndex];\r\n\r\n      if (connectorPoint.x > parentPoint.x && !connectorPoint.isSquared) {\r\n        curvedPoints.push(connectorPoint);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    len = curvedPoints.length;\r\n    if (len > 0) {\r\n      connectorDestination = curvedPoints[len - 1];\r\n      bundlePoint = (connectorDestination.x == parentPoint.x) ? parentPoint : new this.ConnectorDestination({\r\n        id: connectorDestination.bundleid,\r\n        x: connectorDestination.x,\r\n        y: parentPoint.y\r\n      });\r\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\r\n    }\r\n\r\n    /* calculate elbows of vertical connectors */\r\n    for (index = startIndex; index <= endIndex; index += 1) {\r\n      connectorPoint = points[index];\r\n\r\n      bevelSize = options.bevelSize;\r\n      if (bevelSize < 2) {\r\n        bevelSize = 0;\r\n      }\r\n\r\n      switch (options.elbowType) {\r\n        case ElbowType.Bevel:\r\n        case ElbowType.Round:\r\n          if (bevelSize > 0 && Math.abs(parentPoint.x - connectorPoint.x) > bevelSize && Math.abs(parentPoint.y - connectorPoint.y) > bevelSize) {\r\n            connectorPoint.hasElbow = true;\r\n            connectorPoint.elbowPoint1 = new Point(connectorPoint.x, parentPoint.y + (parentPoint.y > connectorPoint.y ? -bevelSize : bevelSize));\r\n            connectorPoint.elbowPoint2 = new Point(connectorPoint.x + (parentPoint.x > connectorPoint.x ? bevelSize : -bevelSize), parentPoint.y);\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      /* draw vertical segment */\r\n      polyline = new Polyline();\r\n      if (connectorPoint.hasElbow) {\r\n        params.transform.transform3Points(connectorPoint.elbowPoint2.x, connectorPoint.elbowPoint2.y,\r\n          connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint2.y,\r\n          connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, true, this,\r\n          function (fromX, fromY, toX, toY, toX2, toY2) {\r\n            switch (options.elbowType) {\r\n              case ElbowType.Bevel:\r\n                polyline.addSegment(new MoveSegment(fromX, fromY));\r\n                polyline.addSegment(new LineSegment(toX2, toY2));\r\n                break;\r\n              case ElbowType.Round:\r\n                polyline.addSegment(new MoveSegment(fromX, fromY));\r\n                polyline.addSegment(new CubicArcSegment(fromX, fromY, toX, toY, toX2, toY2));\r\n                break;\r\n            }\r\n          });//ignore jslint\r\n\r\n        params.transform.transformPoints(connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\r\n          polyline.addSegment(new LineSegment(toX, toY));\r\n        }); //ignore jslint\r\n      } else {\r\n        params.transform.transformPoints(connectorPoint.x, parentPoint.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\r\n          polyline.addSegment(new MoveSegment(fromX, fromY));\r\n          polyline.addSegment(new LineSegment(toX, toY));\r\n        }); //ignore jslint\r\n      }\r\n\r\n      var bundleid = (connectorPoint.x == parentPoint.x) ? parentPoint.id : connectorPoint.bundleid;\r\n      var isVisible = (connectorPoint.visibility !== Visibility.Invisible);\r\n      data.graph.addEdge(bundleid, connectorPoint.id, new this.ConnectorEdge(bundleid, connectorPoint.id, polyline,\r\n        isParents ? connectorPoint.id : null,\r\n        !isParents ? connectorPoint.id : null,\r\n        null,\r\n        isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT /* weight*/, fromOffset, null, null,\r\n        isVisible));\r\n    }\r\n\r\n    /* draw segments on the right of parent point */\r\n    startIndex = Math.max(startIndex - 1, 0);\r\n    endIndex = Math.min(endIndex + 1, points.length - 1);\r\n\r\n    fromPoint = parentPoint;\r\n    fromPointId = parentPoint.id;\r\n    for (index = startIndex; index <= endIndex; index += 1) {\r\n      toPoint = points[index];\r\n      toPointId = toPoint.bundleid;\r\n      if (toPoint.x > fromPoint.x) {\r\n        polyline = new Polyline();\r\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\r\n          polyline.addSegment(new MoveSegment(startX, startY));\r\n          polyline.addSegment(new LineSegment(endX, endY));\r\n        }); //ignore jslint\r\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline,\r\n          null,\r\n          null,\r\n          fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */,\r\n          fromOffset,\r\n          /* draw middle arrows */\r\n          showHorizontalArrows, isParents ? toPointId : fromPointId)\r\n        );\r\n\r\n        fromPoint = toPoint.elbowPoint2 || toPoint;\r\n        fromPointId = toPointId;\r\n      }\r\n    }\r\n\r\n    /* draw segments on the left of parent point */\r\n    fromPoint = parentPoint;\r\n    fromPointId = parentPoint.id;\r\n    for (index = endIndex; index >= startIndex; index -= 1) {\r\n      toPoint = points[index];\r\n      toPointId = toPoint.bundleid;\r\n      if (toPoint.x < fromPoint.x) {\r\n        polyline = new Polyline();\r\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\r\n          polyline.addSegment(new MoveSegment(startX, startY));\r\n          polyline.addSegment(new LineSegment(endX, endY));\r\n        }); //ignore jslint\r\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId,\r\n          Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */, fromOffset,\r\n          /* draw middle arrows */\r\n          showHorizontalArrows, isParents ? toPointId : fromPointId)\r\n        );\r\n\r\n        fromPoint = toPoint.elbowPoint2 || toPoint;\r\n        fromPointId = toPointId;\r\n      }\r\n    }\r\n  } else {\r\n    /* all lines are angular or curved */\r\n    this.traceAngularSegments(data, params, options, parentPoint, points, true);\r\n  }\r\n};\r\n\r\nBaseConnectorBundle.prototype.traceAngularSegments = function (data, params, options, bundlePoint, points, drawToBundle) {\r\n  var index, len,\r\n    rect,\r\n    point,\r\n    polyline;\r\n\r\n  for (index = 0, len = points.length; index < len; index += 1) {\r\n    point = points[index];\r\n\r\n    polyline = new Polyline();\r\n\r\n    params.transform.transformPoint(bundlePoint.x, bundlePoint.y, true, this, function (x, y) {\r\n      polyline.addSegment(new MoveSegment(x, y));\r\n    });//ignore jslint\r\n\r\n    switch (options.connectorType) {\r\n      case ConnectorType.Angular:\r\n        params.transform.transformPoint(point.x, point.y, true, this, function (x, y) {\r\n          polyline.addSegment(new LineSegment(x, y));\r\n        });//ignore jslint\r\n        break;\r\n      case ConnectorType.Curved:\r\n        rect = new Rect(bundlePoint, point);\r\n\r\n        if (drawToBundle) {\r\n          if (bundlePoint.x > rect.x) {\r\n            params.transform.transform3Points(rect.right(), rect.verticalCenter(), rect.x, rect.verticalCenter(), rect.x, rect.bottom(), true,\r\n              this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\r\n                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\r\n              });//ignore jslint\r\n          }\r\n          else {\r\n            params.transform.transform3Points(rect.x, rect.verticalCenter(), rect.right(), rect.verticalCenter(), rect.right(), rect.bottom(), true,\r\n              this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\r\n                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\r\n              });//ignore jslint\r\n          }\r\n        } else {\r\n          if (bundlePoint.x > rect.x) {\r\n            params.transform.transformPoints(rect.x, rect.y, rect.x, rect.bottom(), true,\r\n              this, function (cpX, cpY, x, y) {\r\n                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\r\n              });//ignore jslint\r\n          } else {\r\n            params.transform.transformPoints(rect.right(), rect.y, rect.right(), rect.bottom(), true,\r\n              this, function (cpX, cpY, x, y) {\r\n                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\r\n              });//ignore jslint\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    var isVisible = (point.visibility !== Visibility.Invisible);\r\n    data.graph.addEdge(bundlePoint.id, point.id, new this.ConnectorEdge(bundlePoint.id, point.id, polyline,\r\n      null,\r\n      isVisible ? point.id : null,\r\n      isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT, null, null, null,\r\n      true));\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}