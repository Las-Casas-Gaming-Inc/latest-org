{"ast":null,"code":"import PaletteItem from './PaletteItem';\nimport MoveSegment from './MoveSegment';\nimport LineSegment from './LineSegment';\nimport QuadraticArcSegment from './QuadraticArcSegment';\nimport Point from './Point';\nimport Vector from './Vector';\nimport { SegmentType, VectorRelationType } from '../../enums';\nimport { isNullOrEmpty } from '../../common';\nexport default function Polyline(newPaletteItem) {\n  var paletteItem = new PaletteItem(),\n    segments = [],\n    self,\n    arrowPaletteItem;\n  switch (arguments.length) {\n    case 1:\n      paletteItem = newPaletteItem;\n      break;\n  }\n  arrowPaletteItem = new PaletteItem({\n    lineColor: paletteItem.lineColor,\n    lineWidth: 0,\n    fillColor: paletteItem.lineColor,\n    opacity: paletteItem.opacity || 1\n  });\n  function getStartPoint() {\n    var result = null;\n    if (segments.length > 0) {\n      result = segments[0].getEndPoint();\n    }\n    return result;\n  }\n  function getEndPoint() {\n    var result = null;\n    if (segments.length > 0) {\n      result = segments[segments.length - 1].getEndPoint();\n    }\n    return result;\n  }\n  function addSegment(segment) {\n    segments.push(segment);\n  }\n  function addSegments(newSegments) {\n    var index, len;\n    for (index = 0, len = newSegments.length; index < len; index += 1) {\n      segments.push(newSegments[index]);\n    }\n  }\n  function mergeTo(polyline) {\n    polyline.addSegments(segments);\n  }\n  function clone() {\n    var index,\n      len,\n      result = new Polyline(paletteItem),\n      cloneSegments = [],\n      segment;\n    for (index = 0, len = segments.length; index < len; index += 1) {\n      segment = segments[index];\n      cloneSegments.push(segment.clone());\n    }\n    result.addSegments(cloneSegments);\n    return result;\n  }\n  function length() {\n    return segments.length;\n  }\n  function loop(thisArg, onItem) {\n    var index, len, segment;\n    if (onItem != null) {\n      for (index = 0, len = segments.length; index < len; index += 1) {\n        segment = segments[index];\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  function loopReversed(thisArg, onItem) {\n    var index, segment;\n    if (onItem != null) {\n      for (index = segments.length - 1; index >= 0; index -= 1) {\n        segment = segments[index];\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  function transform(transformArg, forward) {\n    loop(this, function (segment) {\n      if (segment.transform != null) {\n        segment.transform(transformArg, forward);\n      }\n    });\n  }\n  function isInvertable() {\n    return isNullOrEmpty(paletteItem.fillColor);\n  }\n  function addInverted(polyline) {\n    var hasMoved = false,\n      stack = [];\n    if (isInvertable()) {\n      polyline.loopReversed(this, function (segment, index) {\n        if (segment.segmentType != SegmentType.Dot) {\n          if (!hasMoved) {\n            segments.push(new MoveSegment(segment.getEndPoint()));\n            hasMoved = true;\n          }\n          stack.unshift(segment);\n          if (stack.length > 1) {\n            stack[1].invert(stack[0].getEndPoint());\n            segments.push(stack[1]);\n            stack.length = 1;\n          }\n        }\n      });\n    } else {\n      polyline.mergeTo(self);\n    }\n  }\n  function _getArrow(fromX, fromY, toX, toY, length, width) {\n    var result = new Polyline(arrowPaletteItem),\n      index,\n      len,\n      point,\n      x,\n      y,\n      perimeter = [new Point(length, -width / 2), new Point(0, 0), new Point(length, width / 2), new Point(length / 4 * 3, 0)],\n      angle = Math.atan2(fromY - toY, fromX - toX);\n\n    /* rotate and translate points */\n    for (index = 0, len = perimeter.length; index < len; index += 1) {\n      point = perimeter[index];\n      x = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n      y = point.x * Math.sin(angle) + point.y * Math.cos(angle);\n      point.x = x + toX;\n      point.y = y + toY;\n    }\n\n    /* create arrow shape*/\n    result.addSegment(new MoveSegment(perimeter[0].x, perimeter[0].y));\n    result.addSegment(new LineSegment(perimeter[1].x, perimeter[1].y));\n    result.addSegment(new LineSegment(perimeter[2].x, perimeter[2].y));\n    result.addSegment(new QuadraticArcSegment(perimeter[3].x, perimeter[3].y, perimeter[0].x, perimeter[0].y));\n    return result;\n  }\n  function addOffsetArrow(forward, lineWidth, offsetPercent, minimumDistance, onAddArrowSegments) {\n    var prevEndPoint,\n      currentEndPoint,\n      currentSegment,\n      newEndPoint,\n      newPrevEndPoint,\n      polyline,\n      len = segments.length,\n      arrowTipLength = lineWidth * 3,\n      arrowTipWidth = lineWidth * 2,\n      offset,\n      distance;\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n      if (currentSegment.offsetPoint != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n        distance = prevEndPoint.distanceTo(currentEndPoint);\n        if (distance > minimumDistance) {\n          offset = distance * offsetPercent;\n          if (forward) {\n            newEndPoint = currentSegment.offsetPoint(prevEndPoint, currentEndPoint, offset);\n            polyline = _getArrow(prevEndPoint.x, prevEndPoint.y, newEndPoint.x, newEndPoint.y, arrowTipLength, arrowTipWidth);\n          } else {\n            newPrevEndPoint = currentSegment.offsetPoint(currentEndPoint, prevEndPoint, offset);\n            polyline = _getArrow(currentEndPoint.x, currentEndPoint.y, newPrevEndPoint.x, newPrevEndPoint.y, arrowTipLength, arrowTipWidth);\n          }\n          onAddArrowSegments(polyline);\n        }\n      }\n    }\n  }\n  function addArrow(lineWidth, onAddArrowSegments) {\n    var prevEndPoint,\n      currentEndPoint,\n      currentSegment,\n      newEndPoint,\n      polyline,\n      len = segments.length,\n      arrowTipLength = lineWidth * 3,\n      arrowTipWidth = lineWidth * 2;\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n      if (currentSegment.trim != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n        if (currentEndPoint.distanceTo(prevEndPoint) >= arrowTipLength) {\n          newEndPoint = currentSegment.trim(prevEndPoint, arrowTipLength);\n          polyline = _getArrow(newEndPoint.x, newEndPoint.y, currentEndPoint.x, currentEndPoint.y, arrowTipLength, arrowTipWidth);\n          onAddArrowSegments(polyline, newEndPoint);\n        }\n      }\n    }\n  }\n  function optimizeMoveSegments() {\n    var index,\n      len,\n      cursorIndex,\n      key,\n      optimizedSegments,\n      segment,\n      nextSegment,\n      links = {},\n      jumps = [],\n      processed = [];\n    for (index = 0, len = segments.length; index < len - 1; index += 1) {\n      segment = segments[index];\n      nextSegment = segments[index + 1];\n      switch (segment.segmentType) {\n        case SegmentType.Line:\n        case SegmentType.QuadraticArc:\n        case SegmentType.CubicArc:\n          switch (nextSegment.segmentType) {\n            case SegmentType.Move:\n            case SegmentType.Dot:\n              key = segment.x + \"&\" + segment.y;\n              if (!links.hasOwnProperty(key)) {\n                links[key] = index;\n              }\n              break;\n            default:\n              break;\n          }\n          break;\n        case SegmentType.Move:\n          key = segment.x + \"&\" + segment.y;\n          if (links.hasOwnProperty(key) && !jumps[links[key]]) {\n            jumps[links[key]] = index + 1;\n            processed[index] = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    optimizedSegments = [];\n    for (index = 0; index < len; index += 1) {\n      if (!processed[index]) {\n        segment = segments[index];\n        optimizedSegments.push(segment);\n        processed[index] = true;\n        if (jumps[index] > 0) {\n          cursorIndex = jumps[index];\n          while (cursorIndex < len && !processed[cursorIndex]) {\n            segment = segments[cursorIndex];\n            optimizedSegments.push(segment);\n            processed[cursorIndex] = true;\n            if (jumps[cursorIndex] > 0) {\n              cursorIndex = jumps[cursorIndex];\n            } else {\n              cursorIndex += 1;\n            }\n          }\n        }\n      }\n    }\n    segments = optimizedSegments;\n  }\n  function toString() {\n    return paletteItem.toString();\n  }\n\n  /* private classes */\n  function Vertex(segment, pointIndex) {\n    this.segment = segment;\n    this.pointIndex = pointIndex;\n  }\n  Vertex.prototype.pushToSegment = function (point) {\n    this.segment.setPoint(point, this.pointIndex);\n  };\n  function _joinVectors(prev, current, offset, polyline, isLoop) {\n    var relationType = prev.relateTo(current),\n      offset2 = isLoop ? 0 : offset,\n      joinSegment,\n      joinVector,\n      newToPoint;\n    if (relationType == VectorRelationType.Collinear) {\n      /* Vectors are collinear vectors so we don't search for intersection */\n      current.offset(offset2);\n    } else {\n      if (relationType == VectorRelationType.Opposite && current.from.context.pointIndex === 0) {\n        /* Vectors are opposite vectors which belong to 2 different segments\r\n          so we add an extra line segment in between of them\r\n        */\n        joinSegment = new LineSegment(current.from);\n        polyline.addSegment(joinSegment);\n        current.offset(offset2);\n        newToPoint = current.from.clone();\n        newToPoint.context = new Vertex(joinSegment, 0);\n        joinVector = new Vector(prev.to.clone(), newToPoint);\n        if (!isLoop) {\n          current.from = newToPoint.clone();\n        }\n        joinVector.offset(offset);\n        joinVector.intersect(prev);\n        joinVector.from.context.pushToSegment(joinVector.from);\n        current.intersect(joinVector);\n        if (isLoop) {\n          joinVector.to.context.pushToSegment(joinVector.to);\n        }\n      } else {\n        current.offset(offset2);\n        current.intersect(prev);\n      }\n    }\n    current.from.context.pushToSegment(current.from);\n  }\n  function _closeVector(vectorStack, startVectors, offset, polyline) {\n    var startVector,\n      prevVector = vectorStack[0],\n      closurePoint = prevVector.to.context.segment.getEndPoint().toString();\n    if (startVectors.hasOwnProperty(closurePoint)) {\n      startVector = startVectors[closurePoint];\n      _joinVectors(prevVector, startVector, offset, polyline, true);\n      delete startVectors[closurePoint];\n    }\n    prevVector.to.context.pushToSegment(prevVector.to);\n    vectorStack.length = 0;\n  }\n  function getOffsetPolyine(offset) {\n    var result = new Polyline(paletteItem),\n      startVectors = {},\n      pointStack = [],\n      vectorStack = [];\n    loop(this, function (segment) {\n      var newSegment = segment.clone(),\n        newPoint;\n      switch (newSegment.segmentType) {\n        case SegmentType.Dot:\n        case SegmentType.Move:\n          if (vectorStack.length > 0) {\n            _closeVector(vectorStack, startVectors, offset, result);\n          }\n          pointStack.length = 0;\n          if (newSegment.segmentType == SegmentType.Move) {\n            newPoint = new Point(newSegment);\n            newPoint.context = new Vertex(newSegment, 0);\n            pointStack.push(newPoint);\n          }\n          break;\n        default:\n          newSegment.loop(this, function (x, y, index) {\n            var newPoint = new Point(x, y),\n              current,\n              prev,\n              closurePoint;\n            newPoint.context = new Vertex(newSegment, index);\n            pointStack.unshift(newPoint);\n            if (pointStack.length > 1) {\n              vectorStack.unshift(new Vector(pointStack[1].clone(), pointStack[0].clone()));\n              pointStack.length = 1;\n            }\n            switch (vectorStack.length) {\n              case 1:\n                /* first Vector in stack we add to start Vectors collection for possible join into perimeter*/\n                current = vectorStack[0];\n                closurePoint = current.from.toString();\n                startVectors[closurePoint] = current;\n                current.offset(offset);\n                current.from.context.pushToSegment(current.from);\n                break;\n              case 2:\n                prev = vectorStack[1];\n                current = vectorStack[0];\n                _joinVectors(prev, current, offset, result, false);\n                vectorStack.length = 1;\n                break;\n              default:\n                break;\n            }\n          });\n          break;\n      }\n      result.addSegment(newSegment);\n    });\n    if (vectorStack.length > 0) {\n      _closeVector(vectorStack, startVectors, offset, result);\n    }\n    return result;\n  }\n  self = {\n    paletteItem: paletteItem,\n    arrowPaletteItem: arrowPaletteItem,\n    addSegment: addSegment,\n    addSegments: addSegments,\n    mergeTo: mergeTo,\n    length: length,\n    loop: loop,\n    loopReversed: loopReversed,\n    transform: transform,\n    isInvertable: isInvertable,\n    addInverted: addInverted,\n    addArrow: addArrow,\n    addOffsetArrow: addOffsetArrow,\n    optimizeMoveSegments: optimizeMoveSegments,\n    getOffsetPolyine: getOffsetPolyine,\n    toString: toString,\n    getStartPoint: getStartPoint,\n    getEndPoint: getEndPoint,\n    clone: clone\n  };\n  return self;\n}\n;","map":{"version":3,"names":["PaletteItem","MoveSegment","LineSegment","QuadraticArcSegment","Point","Vector","SegmentType","VectorRelationType","isNullOrEmpty","Polyline","newPaletteItem","paletteItem","segments","self","arrowPaletteItem","arguments","length","lineColor","lineWidth","fillColor","opacity","getStartPoint","result","getEndPoint","addSegment","segment","push","addSegments","newSegments","index","len","mergeTo","polyline","clone","cloneSegments","loop","thisArg","onItem","call","loopReversed","transform","transformArg","forward","isInvertable","addInverted","hasMoved","stack","segmentType","Dot","unshift","invert","_getArrow","fromX","fromY","toX","toY","width","point","x","y","perimeter","angle","Math","atan2","cos","sin","addOffsetArrow","offsetPercent","minimumDistance","onAddArrowSegments","prevEndPoint","currentEndPoint","currentSegment","newEndPoint","newPrevEndPoint","arrowTipLength","arrowTipWidth","offset","distance","offsetPoint","distanceTo","addArrow","trim","optimizeMoveSegments","cursorIndex","key","optimizedSegments","nextSegment","links","jumps","processed","Line","QuadraticArc","CubicArc","Move","hasOwnProperty","toString","Vertex","pointIndex","prototype","pushToSegment","setPoint","_joinVectors","prev","current","isLoop","relationType","relateTo","offset2","joinSegment","joinVector","newToPoint","Collinear","Opposite","from","context","to","intersect","_closeVector","vectorStack","startVectors","startVector","prevVector","closurePoint","getOffsetPolyine","pointStack","newSegment","newPoint"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/graphics/structs/Polyline.js"],"sourcesContent":["import PaletteItem from './PaletteItem';\r\nimport MoveSegment from './MoveSegment';\r\nimport LineSegment from './LineSegment';\r\nimport QuadraticArcSegment from './QuadraticArcSegment';\r\nimport Point from './Point';\r\nimport Vector from './Vector';\r\nimport { SegmentType, VectorRelationType } from '../../enums';\r\nimport { isNullOrEmpty } from '../../common';\r\n\r\nexport default function Polyline(newPaletteItem) {\r\n  var paletteItem = new PaletteItem(),\r\n    segments = [],\r\n    self,\r\n    arrowPaletteItem;\r\n\r\n  switch (arguments.length) {\r\n    case 1:\r\n      paletteItem = newPaletteItem;\r\n      break;\r\n  }\r\n\r\n  arrowPaletteItem = new PaletteItem({\r\n    lineColor: paletteItem.lineColor,\r\n    lineWidth: 0,\r\n    fillColor: paletteItem.lineColor,\r\n    opacity: paletteItem.opacity || 1\r\n  });\r\n\r\n  function getStartPoint() {\r\n    var result = null;\r\n    if (segments.length > 0) {\r\n      result = segments[0].getEndPoint();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function getEndPoint() {\r\n    var result = null;\r\n    if (segments.length > 0) {\r\n      result = segments[segments.length - 1].getEndPoint();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function addSegment(segment) {\r\n    segments.push(segment);\r\n  }\r\n\r\n  function addSegments(newSegments) {\r\n    var index, len;\r\n    for (index = 0, len = newSegments.length; index < len; index += 1) {\r\n      segments.push(newSegments[index]);\r\n    }\r\n  }\r\n\r\n  function mergeTo(polyline) {\r\n    polyline.addSegments(segments);\r\n  }\r\n\r\n  function clone() {\r\n    var index, len,\r\n      result = new Polyline(paletteItem),\r\n      cloneSegments = [],\r\n      segment;\r\n    for (index = 0, len = segments.length; index < len; index += 1) {\r\n      segment = segments[index];\r\n      cloneSegments.push(segment.clone());\r\n    }\r\n    result.addSegments(cloneSegments);\r\n    return result;\r\n  }\r\n\r\n  function length() {\r\n    return segments.length;\r\n  }\r\n\r\n  function loop(thisArg, onItem) {\r\n    var index, len,\r\n      segment;\r\n    if (onItem != null) {\r\n      for (index = 0, len = segments.length; index < len; index += 1) {\r\n        segment = segments[index];\r\n        if (segment) {\r\n          if (onItem.call(thisArg, segment, index)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function loopReversed(thisArg, onItem) {\r\n    var index,\r\n      segment;\r\n    if (onItem != null) {\r\n      for (index = segments.length - 1; index >= 0; index -= 1) {\r\n        segment = segments[index];\r\n        if (segment) {\r\n          if (onItem.call(thisArg, segment, index)) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function transform(transformArg, forward) {\r\n    loop(this, function (segment) {\r\n      if (segment.transform != null) {\r\n        segment.transform(transformArg, forward);\r\n      }\r\n    });\r\n  }\r\n\r\n  function isInvertable() {\r\n    return isNullOrEmpty(paletteItem.fillColor);\r\n  }\r\n\r\n  function addInverted(polyline) {\r\n    var hasMoved = false,\r\n      stack = [];\r\n\r\n    if (isInvertable()) {\r\n      polyline.loopReversed(this, function (segment, index) {\r\n        if (segment.segmentType != SegmentType.Dot) {\r\n          if (!hasMoved) {\r\n            segments.push(new MoveSegment(segment.getEndPoint()));\r\n            hasMoved = true;\r\n          }\r\n          stack.unshift(segment);\r\n\r\n          if (stack.length > 1) {\r\n            stack[1].invert(stack[0].getEndPoint());\r\n            segments.push(stack[1]);\r\n            stack.length = 1;\r\n          }\r\n\r\n        }\r\n      });\r\n    } else {\r\n      polyline.mergeTo(self);\r\n    }\r\n  }\r\n\r\n  function _getArrow(fromX, fromY, toX, toY, length, width) {\r\n    var result = new Polyline(arrowPaletteItem),\r\n      index, len,\r\n      point, x, y,\r\n      perimeter = [new Point(length, -width / 2),\r\n      new Point(0, 0),\r\n      new Point(length, width / 2),\r\n      new Point(length / 4 * 3, 0)\r\n      ],\r\n      angle = Math.atan2((fromY - toY), (fromX - toX));\r\n\r\n    /* rotate and translate points */\r\n    for (index = 0, len = perimeter.length; index < len; index += 1) {\r\n      point = perimeter[index];\r\n      x = point.x * Math.cos(angle) - point.y * Math.sin(angle);\r\n      y = point.x * Math.sin(angle) + point.y * Math.cos(angle);\r\n      point.x = x + toX;\r\n      point.y = y + toY;\r\n    }\r\n\r\n    /* create arrow shape*/\r\n    result.addSegment(new MoveSegment(perimeter[0].x, perimeter[0].y));\r\n    result.addSegment(new LineSegment(perimeter[1].x, perimeter[1].y));\r\n    result.addSegment(new LineSegment(perimeter[2].x, perimeter[2].y));\r\n    result.addSegment(new QuadraticArcSegment(perimeter[3].x, perimeter[3].y, perimeter[0].x, perimeter[0].y));\r\n\r\n    return result;\r\n  }\r\n\r\n  function addOffsetArrow(forward, lineWidth, offsetPercent, minimumDistance, onAddArrowSegments) {\r\n    var prevEndPoint,\r\n      currentEndPoint,\r\n      currentSegment,\r\n      newEndPoint, newPrevEndPoint,\r\n      polyline,\r\n      len = segments.length,\r\n      arrowTipLength = lineWidth * 3,\r\n      arrowTipWidth = lineWidth * 2,\r\n      offset,\r\n      distance;\r\n\r\n    switch (lineWidth) {\r\n      case 1:\r\n        arrowTipLength = 8;\r\n        arrowTipWidth = 6;\r\n        break;\r\n      case 2:\r\n        arrowTipLength = 12;\r\n        arrowTipWidth = 8;\r\n        break;\r\n      case 3:\r\n        arrowTipLength = 16;\r\n        arrowTipWidth = 10;\r\n        break;\r\n    }\r\n\r\n    if (onAddArrowSegments != null && len > 1) {\r\n      prevEndPoint = segments[len - 2].getEndPoint();\r\n      currentSegment = segments[len - 1];\r\n      if (currentSegment.offsetPoint != null) {\r\n        currentEndPoint = new Point(currentSegment.getEndPoint());\r\n\r\n        distance = prevEndPoint.distanceTo(currentEndPoint);\r\n        if (distance > minimumDistance) {\r\n          offset = distance * offsetPercent;\r\n\r\n          if (forward) {\r\n            newEndPoint = currentSegment.offsetPoint(prevEndPoint, currentEndPoint, offset);\r\n            polyline = _getArrow(prevEndPoint.x, prevEndPoint.y, newEndPoint.x, newEndPoint.y, arrowTipLength, arrowTipWidth);\r\n          } else {\r\n            newPrevEndPoint = currentSegment.offsetPoint(currentEndPoint, prevEndPoint, offset);\r\n            polyline = _getArrow(currentEndPoint.x, currentEndPoint.y, newPrevEndPoint.x, newPrevEndPoint.y, arrowTipLength, arrowTipWidth);\r\n          }\r\n          onAddArrowSegments(polyline);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function addArrow(lineWidth, onAddArrowSegments) {\r\n    var prevEndPoint,\r\n      currentEndPoint,\r\n      currentSegment,\r\n      newEndPoint,\r\n      polyline,\r\n      len = segments.length,\r\n      arrowTipLength = lineWidth * 3,\r\n      arrowTipWidth = lineWidth * 2;\r\n\r\n    switch (lineWidth) {\r\n      case 1:\r\n        arrowTipLength = 8;\r\n        arrowTipWidth = 6;\r\n        break;\r\n      case 2:\r\n        arrowTipLength = 12;\r\n        arrowTipWidth = 8;\r\n        break;\r\n      case 3:\r\n        arrowTipLength = 16;\r\n        arrowTipWidth = 10;\r\n        break;\r\n    }\r\n\r\n    if (onAddArrowSegments != null && len > 1) {\r\n      prevEndPoint = segments[len - 2].getEndPoint();\r\n      currentSegment = segments[len - 1];\r\n      if (currentSegment.trim != null) {\r\n        currentEndPoint = new Point(currentSegment.getEndPoint());\r\n        if (currentEndPoint.distanceTo(prevEndPoint) >= arrowTipLength) {\r\n          newEndPoint = currentSegment.trim(prevEndPoint, arrowTipLength);\r\n\r\n          polyline = _getArrow(newEndPoint.x, newEndPoint.y, currentEndPoint.x, currentEndPoint.y, arrowTipLength, arrowTipWidth);\r\n          onAddArrowSegments(polyline, newEndPoint);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function optimizeMoveSegments() {\r\n    var index, len,\r\n      cursorIndex,\r\n      key,\r\n      optimizedSegments,\r\n      segment, nextSegment,\r\n      links = {},\r\n      jumps = [],\r\n      processed = [];\r\n\r\n    for (index = 0, len = segments.length; index < len - 1; index += 1) {\r\n      segment = segments[index];\r\n      nextSegment = segments[index + 1];\r\n      switch (segment.segmentType) {\r\n        case SegmentType.Line:\r\n        case SegmentType.QuadraticArc:\r\n        case SegmentType.CubicArc:\r\n          switch (nextSegment.segmentType) {\r\n            case SegmentType.Move:\r\n            case SegmentType.Dot:\r\n              key = segment.x + \"&\" + segment.y;\r\n              if (!links.hasOwnProperty(key)) {\r\n                links[key] = index;\r\n              }\r\n              break;\r\n            default:\r\n              break;\r\n          }\r\n          break;\r\n        case SegmentType.Move:\r\n          key = segment.x + \"&\" + segment.y;\r\n          if (links.hasOwnProperty(key) && !jumps[links[key]]) {\r\n            jumps[links[key]] = index + 1;\r\n            processed[index] = true;\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    optimizedSegments = [];\r\n    for (index = 0; index < len; index += 1) {\r\n      if (!processed[index]) {\r\n        segment = segments[index];\r\n        optimizedSegments.push(segment);\r\n        processed[index] = true;\r\n\r\n        if (jumps[index] > 0) {\r\n          cursorIndex = jumps[index];\r\n          while (cursorIndex < len && !processed[cursorIndex]) {\r\n            segment = segments[cursorIndex];\r\n            optimizedSegments.push(segment);\r\n            processed[cursorIndex] = true;\r\n\r\n            if (jumps[cursorIndex] > 0) {\r\n              cursorIndex = jumps[cursorIndex];\r\n            } else {\r\n              cursorIndex += 1;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    segments = optimizedSegments;\r\n  }\r\n\r\n  function toString() {\r\n    return paletteItem.toString();\r\n  }\r\n\r\n  /* private classes */\r\n  function Vertex(segment, pointIndex) {\r\n    this.segment = segment;\r\n    this.pointIndex = pointIndex;\r\n  }\r\n\r\n  Vertex.prototype.pushToSegment = function (point) {\r\n    this.segment.setPoint(point, this.pointIndex);\r\n  };\r\n\r\n  function _joinVectors(prev, current, offset, polyline, isLoop) {\r\n    var relationType = prev.relateTo(current),\r\n      offset2 = isLoop ? 0 : offset,\r\n      joinSegment,\r\n      joinVector,\r\n      newToPoint;\r\n    if (relationType == VectorRelationType.Collinear) {\r\n      /* Vectors are collinear vectors so we don't search for intersection */\r\n      current.offset(offset2);\r\n    } else {\r\n      if (relationType == VectorRelationType.Opposite && current.from.context.pointIndex === 0) {\r\n        /* Vectors are opposite vectors which belong to 2 different segments\r\n          so we add an extra line segment in between of them\r\n        */\r\n        joinSegment = new LineSegment(current.from);\r\n        polyline.addSegment(joinSegment);\r\n\r\n        current.offset(offset2);\r\n\r\n        newToPoint = current.from.clone();\r\n        newToPoint.context = new Vertex(joinSegment, 0);\r\n\r\n        joinVector = new Vector(prev.to.clone(), newToPoint);\r\n        if (!isLoop) {\r\n          current.from = newToPoint.clone();\r\n        }\r\n\r\n        joinVector.offset(offset);\r\n        joinVector.intersect(prev);\r\n        joinVector.from.context.pushToSegment(joinVector.from);\r\n        current.intersect(joinVector);\r\n\r\n        if (isLoop) {\r\n          joinVector.to.context.pushToSegment(joinVector.to);\r\n        }\r\n      } else {\r\n        current.offset(offset2);\r\n        current.intersect(prev);\r\n      }\r\n    }\r\n    current.from.context.pushToSegment(current.from);\r\n  }\r\n\r\n  function _closeVector(vectorStack, startVectors, offset, polyline) {\r\n    var startVector,\r\n      prevVector = vectorStack[0],\r\n      closurePoint = prevVector.to.context.segment.getEndPoint().toString();\r\n    if (startVectors.hasOwnProperty(closurePoint)) {\r\n      startVector = startVectors[closurePoint];\r\n\r\n      _joinVectors(prevVector, startVector, offset, polyline, true);\r\n\r\n      delete startVectors[closurePoint];\r\n    }\r\n    prevVector.to.context.pushToSegment(prevVector.to);\r\n    vectorStack.length = 0;\r\n  }\r\n\r\n  function getOffsetPolyine(offset) {\r\n    var result = new Polyline(paletteItem),\r\n      startVectors = {},\r\n      pointStack = [],\r\n      vectorStack = [];\r\n\r\n    loop(this, function (segment) {\r\n      var newSegment = segment.clone(),\r\n        newPoint;\r\n\r\n      switch (newSegment.segmentType) {\r\n        case SegmentType.Dot:\r\n        case SegmentType.Move:\r\n          if (vectorStack.length > 0) {\r\n            _closeVector(vectorStack, startVectors, offset, result);\r\n          }\r\n          pointStack.length = 0;\r\n          if (newSegment.segmentType == SegmentType.Move) {\r\n            newPoint = new Point(newSegment);\r\n            newPoint.context = new Vertex(newSegment, 0);\r\n            pointStack.push(newPoint);\r\n          }\r\n          break;\r\n        default:\r\n          newSegment.loop(this, function (x, y, index) {\r\n            var newPoint = new Point(x, y),\r\n              current,\r\n              prev,\r\n              closurePoint;\r\n\r\n            newPoint.context = new Vertex(newSegment, index);\r\n            pointStack.unshift(newPoint);\r\n            if (pointStack.length > 1) {\r\n              vectorStack.unshift(new Vector(pointStack[1].clone(), pointStack[0].clone()));\r\n              pointStack.length = 1;\r\n            }\r\n\r\n            switch (vectorStack.length) {\r\n              case 1:\r\n                /* first Vector in stack we add to start Vectors collection for possible join into perimeter*/\r\n                current = vectorStack[0];\r\n                closurePoint = current.from.toString();\r\n                startVectors[closurePoint] = current;\r\n                current.offset(offset);\r\n                current.from.context.pushToSegment(current.from);\r\n                break;\r\n              case 2:\r\n                prev = vectorStack[1];\r\n                current = vectorStack[0];\r\n\r\n                _joinVectors(prev, current, offset, result, false);\r\n\r\n                vectorStack.length = 1;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          });\r\n          break;\r\n      }\r\n      result.addSegment(newSegment);\r\n    });\r\n    if (vectorStack.length > 0) {\r\n      _closeVector(vectorStack, startVectors, offset, result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  self = {\r\n    paletteItem: paletteItem,\r\n    arrowPaletteItem: arrowPaletteItem,\r\n    addSegment: addSegment,\r\n    addSegments: addSegments,\r\n    mergeTo: mergeTo,\r\n    length: length,\r\n    loop: loop,\r\n    loopReversed: loopReversed,\r\n    transform: transform,\r\n    isInvertable: isInvertable,\r\n    addInverted: addInverted,\r\n    addArrow: addArrow,\r\n    addOffsetArrow: addOffsetArrow,\r\n    optimizeMoveSegments: optimizeMoveSegments,\r\n    getOffsetPolyine: getOffsetPolyine,\r\n    toString: toString,\r\n    getStartPoint: getStartPoint,\r\n    getEndPoint: getEndPoint,\r\n    clone: clone\r\n  };\r\n\r\n  return self;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}