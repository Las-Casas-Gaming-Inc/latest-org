{"ast":null,"code":"import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport { AnnotationType, LineType, Colors, ZOrderType, ConnectorShapeType, ConnectorPlacementType, ConnectorLabelPlacementType } from '../enums';\n/**\r\n * @class ConnectorAnnotationConfig\r\n * @classdesc  Connector annotation configuration object. Connector annotations draws lines between two nodes of the diagram.\r\n * They are drawn on top of existing diagram layout and they don't affect nodes placement. So it is users responsibility to\r\n * preserve space between nodes for them. \r\n *\r\n * @param {object} arg0 Object properties.\r\n */\nexport default function ConnectorAnnotationConfig(arg0, arg1) {\n  var property;\n\n  /**\r\n   * Annotation type. All types of annotations objects are added to `annotations` collection property of the control.\r\n   * This property is needed to distinguish them when they are defined as JSON objects.\r\n   * \r\n   * @type {AnnotationType}\r\n   */\n  this.annotationType = AnnotationType.Connector;\n\n  /**\r\n   * Sets annotation Z order placement relative to the diagram items. Diagram visual elements are drawn in layers on top of each other.\r\n   * If you place annotations over diagram nodes then you block mouse events of UI elements in their templates.\r\n   * Browsers don't support mouse events transparency consistently yet. So in order to avoid mouse events blocking of UI elements in item\r\n   * templates you have to place annotation items under them or explicitly define maximum zindex for controls and make them rendered on top\r\n   * of other visual elements. The control takes this into account and renders buttons panel on top of everything,\r\n   * so they are never blocked by annotations drawn in front of diagram nodes.\r\n   * \r\n   * @type {ZOrderType}\r\n   */\n  this.zOrderType = ZOrderType.Foreground;\n\n  /**\r\n   * The start node of connection line\r\n   * \r\n   * @type {string}\r\n   */\n  this.fromItem = null;\n\n  /**\r\n   * The end node of connection line\r\n   * \r\n   * @type {string}\r\n   */\n  this.toItem = null;\n\n  /**\r\n   * Connector shape type defines number of lines and arrows at their ends drawn between nodes of the connector annotation.\r\n   * This feature combined with basic conflict resolution, which places overlapping annotations in parallel when they overlap each other,\r\n   * gives you full flexibility over variations of possible connector lines between two given nodes of diagram.\r\n   * \r\n   * @type {ConnectorShapeType}\r\n   */\n  this.connectorShapeType = ConnectorShapeType.OneWay;\n\n  /**\r\n   * Connector placement type defines style of connector line drawing over diagram layout. It supports two options: \r\n   * the `Straight` is classic direct line connecting two nodes, this is the most expected style of connector annotation\r\n   * drawing over diagram, the second style is called `Offbeat` and it is designed to dynamically adopt to nodes mutual \r\n   * location and gap between them. It uses free hand line style drawing going from start to the end node. Since every diagram \r\n   * is packed with various connection lines, this annotation placement style is deliberately made not straight, so it can be \r\n   * noticeable on top of other lines of the diagram.\r\n   * \r\n   * @type {ConnectorPlacementType}\r\n   */\n  this.connectorPlacementType = ConnectorPlacementType.Offbeat;\n\n  /**\r\n   * Label placement relative to connector annotation. Connector annotation is bound and drawn between two nodes\r\n   * defined by two properties: `fromItem` and `toItem`. Label can be placed close to \"start\", \"end\" nodes or in between of them\r\n   * along the connector line. \r\n   * \r\n   * @type {ConnectorLabelPlacementType}\r\n   */\n  this.labelPlacementType = ConnectorLabelPlacementType.Between;\n\n  /**\r\n   * Connector line end points offset. By default connection lines start from the margin of the node's rectangle.\r\n   * If offset is positive then start point goes from outside of the rectangle, if it is negative then it starts from inside of the nodes rectangle.\r\n   * \r\n   * @type {Thickness}\r\n   */\n  this.offset = new Thickness(0, 0, 0, 0);\n\n  /**\r\n   * Border line width.\r\n   * \r\n   * @type {number}\r\n   */\n  this.lineWidth = 2;\n\n  /**\r\n   * Color\r\n   * \r\n   * @type {string}\r\n   */\n  this.color = Colors.Black;\n\n  /**\r\n   * Line pattern\r\n   * \r\n   * @type {LineType}\r\n   */\n  this.lineType = LineType.Solid;\n\n  /**\r\n   * If true then annotated nodes are shown full size regardless of controls auto fit mode and available screen space.\r\n   * @type {boolean}\r\n   */\n  this.selectItems = true;\n\n  /**\r\n   * Label. Label styled with css class name \"bp-connector-label\".\r\n   * @type {string}\r\n   */\n  this.label = null;\n\n  /**\r\n   * Label size\r\n   * @type {Size}\r\n   */\n  this.labelSize = new Size(60, 30);\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n      break;\n    case 2:\n      this.fromItem = arg0;\n      this.toItem = arg1;\n      break;\n  }\n}\n;","map":{"version":3,"names":["Thickness","Size","AnnotationType","LineType","Colors","ZOrderType","ConnectorShapeType","ConnectorPlacementType","ConnectorLabelPlacementType","ConnectorAnnotationConfig","arg0","arg1","property","annotationType","Connector","zOrderType","Foreground","fromItem","toItem","connectorShapeType","OneWay","connectorPlacementType","Offbeat","labelPlacementType","Between","offset","lineWidth","color","Black","lineType","Solid","selectItems","label","labelSize","arguments","length","hasOwnProperty"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/configs/ConnectorAnnotationConfig.js"],"sourcesContent":["import Thickness from '../graphics/structs/Thickness';\r\nimport Size from '../graphics/structs/Size';\r\nimport {AnnotationType, LineType, Colors, ZOrderType, ConnectorShapeType,\r\n  ConnectorPlacementType, ConnectorLabelPlacementType } from '../enums';\r\n/**\r\n * @class ConnectorAnnotationConfig\r\n * @classdesc  Connector annotation configuration object. Connector annotations draws lines between two nodes of the diagram.\r\n * They are drawn on top of existing diagram layout and they don't affect nodes placement. So it is users responsibility to\r\n * preserve space between nodes for them. \r\n *\r\n * @param {object} arg0 Object properties.\r\n */\r\nexport default function ConnectorAnnotationConfig(arg0, arg1) {\r\n  var property;\r\n\r\n  /**\r\n   * Annotation type. All types of annotations objects are added to `annotations` collection property of the control.\r\n   * This property is needed to distinguish them when they are defined as JSON objects.\r\n   * \r\n   * @type {AnnotationType}\r\n   */\r\n  this.annotationType = AnnotationType.Connector;\r\n\r\n  /**\r\n   * Sets annotation Z order placement relative to the diagram items. Diagram visual elements are drawn in layers on top of each other.\r\n   * If you place annotations over diagram nodes then you block mouse events of UI elements in their templates.\r\n   * Browsers don't support mouse events transparency consistently yet. So in order to avoid mouse events blocking of UI elements in item\r\n   * templates you have to place annotation items under them or explicitly define maximum zindex for controls and make them rendered on top\r\n   * of other visual elements. The control takes this into account and renders buttons panel on top of everything,\r\n   * so they are never blocked by annotations drawn in front of diagram nodes.\r\n   * \r\n   * @type {ZOrderType}\r\n   */\r\n  this.zOrderType = ZOrderType.Foreground;\r\n\r\n  /**\r\n   * The start node of connection line\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.fromItem = null;\r\n\r\n  /**\r\n   * The end node of connection line\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.toItem = null;\r\n\r\n  /**\r\n   * Connector shape type defines number of lines and arrows at their ends drawn between nodes of the connector annotation.\r\n   * This feature combined with basic conflict resolution, which places overlapping annotations in parallel when they overlap each other,\r\n   * gives you full flexibility over variations of possible connector lines between two given nodes of diagram.\r\n   * \r\n   * @type {ConnectorShapeType}\r\n   */\r\n  this.connectorShapeType = ConnectorShapeType.OneWay;\r\n\r\n  /**\r\n   * Connector placement type defines style of connector line drawing over diagram layout. It supports two options: \r\n   * the `Straight` is classic direct line connecting two nodes, this is the most expected style of connector annotation\r\n   * drawing over diagram, the second style is called `Offbeat` and it is designed to dynamically adopt to nodes mutual \r\n   * location and gap between them. It uses free hand line style drawing going from start to the end node. Since every diagram \r\n   * is packed with various connection lines, this annotation placement style is deliberately made not straight, so it can be \r\n   * noticeable on top of other lines of the diagram.\r\n   * \r\n   * @type {ConnectorPlacementType}\r\n   */\r\n  this.connectorPlacementType = ConnectorPlacementType.Offbeat;\r\n\r\n  /**\r\n   * Label placement relative to connector annotation. Connector annotation is bound and drawn between two nodes\r\n   * defined by two properties: `fromItem` and `toItem`. Label can be placed close to \"start\", \"end\" nodes or in between of them\r\n   * along the connector line. \r\n   * \r\n   * @type {ConnectorLabelPlacementType}\r\n   */\r\n  this.labelPlacementType = ConnectorLabelPlacementType.Between;\r\n\r\n  /**\r\n   * Connector line end points offset. By default connection lines start from the margin of the node's rectangle.\r\n   * If offset is positive then start point goes from outside of the rectangle, if it is negative then it starts from inside of the nodes rectangle.\r\n   * \r\n   * @type {Thickness}\r\n   */\r\n  this.offset = new Thickness(0, 0, 0, 0);\r\n\r\n  /**\r\n   * Border line width.\r\n   * \r\n   * @type {number}\r\n   */\r\n  this.lineWidth = 2;\r\n\r\n  /**\r\n   * Color\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.color = Colors.Black;\r\n\r\n  /**\r\n   * Line pattern\r\n   * \r\n   * @type {LineType}\r\n   */\r\n  this.lineType = LineType.Solid;\r\n\r\n  /**\r\n   * If true then annotated nodes are shown full size regardless of controls auto fit mode and available screen space.\r\n   * @type {boolean}\r\n   */\r\n  this.selectItems = true;\r\n\r\n  /**\r\n   * Label. Label styled with css class name \"bp-connector-label\".\r\n   * @type {string}\r\n   */\r\n  this.label = null;\r\n\r\n  /**\r\n   * Label size\r\n   * @type {Size}\r\n   */\r\n  this.labelSize = new Size(60, 30);\r\n\r\n  switch (arguments.length) {\r\n    case 1:\r\n      for (property in arg0) {\r\n        if (arg0.hasOwnProperty(property)) {\r\n          this[property] = arg0[property];\r\n        }\r\n      }\r\n      break;\r\n    case 2:\r\n      this.fromItem = arg0;\r\n      this.toItem = arg1;\r\n      break;\r\n  }\r\n};\r\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,+BAA+B;AACrD,OAAOC,IAAI,MAAM,0BAA0B;AAC3C,SAAQC,cAAc,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,UAAU,EAAEC,kBAAkB,EACtEC,sBAAsB,EAAEC,2BAA2B,QAAQ,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,yBAAyBA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC5D,IAAIC,QAAQ;;EAEZ;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGX,cAAc,CAACY,SAAS;;EAE9C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGV,UAAU,CAACW,UAAU;;EAEvC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,IAAI;;EAElB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAGb,kBAAkB,CAACc,MAAM;;EAEnD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAGd,sBAAsB,CAACe,OAAO;;EAE5D;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAGf,2BAA2B,CAACgB,OAAO;;EAE7D;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,IAAIzB,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;EAEvC;AACF;AACA;AACA;AACA;EACE,IAAI,CAAC0B,SAAS,GAAG,CAAC;;EAElB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAGvB,MAAM,CAACwB,KAAK;;EAEzB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG1B,QAAQ,CAAC2B,KAAK;;EAE9B;AACF;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI;;EAEvB;AACF;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;EACE,IAAI,CAACC,SAAS,GAAG,IAAIhC,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC;EAEjC,QAAQiC,SAAS,CAACC,MAAM;IACtB,KAAK,CAAC;MACJ,KAAKvB,QAAQ,IAAIF,IAAI,EAAE;QACrB,IAAIA,IAAI,CAAC0B,cAAc,CAACxB,QAAQ,CAAC,EAAE;UACjC,IAAI,CAACA,QAAQ,CAAC,GAAGF,IAAI,CAACE,QAAQ,CAAC;QACjC;MACF;MACA;IACF,KAAK,CAAC;MACJ,IAAI,CAACK,QAAQ,GAAGP,IAAI;MACpB,IAAI,CAACQ,MAAM,GAAGP,IAAI;MAClB;EACJ;AACF;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}