{"ast":null,"code":"import { ItemType } from '../../enums';\nimport getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\nimport { GroupType } from '../transformations/visualTreeBuilder/enums';\nexport default function OrgLogicalLevelsPlacementTask(orgTreeTask, visualTreeTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n  function createPositions() {\n    var intervals = [],\n      orgTree = orgTreeTask.getOrgTree(),\n      itemsPositions = alignDiagramTask.getItemsPositions(),\n      branchAligner = visualTreeTask.getBranchAligner(),\n      visited = {};\n    orgTree.loopLevels(this, function (nodeId, node, levelIndex) {\n      if (node.itemType == ItemType.Regular) {\n        if (node.isVisible) {\n          var itemPosition = itemsPositions[nodeId];\n          if (itemPosition) {\n            var levelOffset = node.levelOffset;\n            if (levelOffset === null) {\n              levelOffset = branchAligner.getGroupSize(node.parent, GroupType.RowChildren);\n            }\n            var interval = new Interval(itemPosition.topConnectorShift, itemPosition.bottomConnectorShift - 1, levelIndex + levelOffset);\n            var key = interval.toString();\n            if (!visited[key]) {\n              visited[key] = true;\n              intervals.push(interval);\n            }\n          }\n        }\n        return;\n      }\n      return orgTree.SKIP;\n    });\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function (interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n\n    /* merge intervals having equal logical levels */\n    mergedIntervals = [];\n    var currentInterval = null;\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      if (!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if (currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n    intervals = mergedIntervals;\n\n    /* extend first level to the top */\n    if (intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n\n    /* fill gaps between levels */\n    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n      prev.to = next.from;\n    }\n\n    /* find minimal level */\n    var minLevelIndex = null;\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n\n    /* group intervals by logical levels */\n    var result = {};\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n      if (!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n    return result;\n  }\n  function getPositions() {\n    if (!_data.positions) {\n      _data.positions = createPositions();\n    }\n    return _data.positions;\n  }\n  return {\n    getPositions: getPositions,\n    process: process\n  };\n}\n;","map":{"version":3,"names":["ItemType","getMergedIntervals","Interval","GroupType","OrgLogicalLevelsPlacementTask","orgTreeTask","visualTreeTask","alignDiagramTask","_data","positions","process","createPositions","intervals","orgTree","getOrgTree","itemsPositions","getItemsPositions","branchAligner","getBranchAligner","visited","loopLevels","nodeId","node","levelIndex","itemType","Regular","isVisible","itemPosition","levelOffset","getGroupSize","parent","RowChildren","interval","topConnectorShift","bottomConnectorShift","key","toString","push","SKIP","mergedIntervals","currentInterval","index","len","length","context","to","from","prev","next","minLevelIndex","Math","min","result","logicalLevelPosition","getPositions"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/tasks/layout/OrgLogicalLevelsPlacementTask.js"],"sourcesContent":["import { ItemType } from '../../enums';\r\nimport getMergedIntervals from '../../algorithms/getMergedIntervals';\r\nimport Interval from '../../graphics/structs/Interval';\r\nimport { GroupType } from '../transformations/visualTreeBuilder/enums';\r\n\r\nexport default function OrgLogicalLevelsPlacementTask(orgTreeTask, visualTreeTask, alignDiagramTask) {\r\n  var _data = {\r\n    positions: []\r\n  };\r\n\r\n  function process() {\r\n    _data.positions = null;\r\n    return true;\r\n  }\r\n\r\n  function createPositions() {\r\n    var intervals = [],\r\n      orgTree = orgTreeTask.getOrgTree(),\r\n      itemsPositions = alignDiagramTask.getItemsPositions(),\r\n      branchAligner = visualTreeTask.getBranchAligner(),\r\n      visited = {};\r\n\r\n    orgTree.loopLevels(this, function(nodeId, node, levelIndex) {\r\n      if(node.itemType == ItemType.Regular) {\r\n        if(node.isVisible) {\r\n          var itemPosition = itemsPositions[nodeId];\r\n          if(itemPosition) {\r\n            var levelOffset = node.levelOffset;\r\n            if(levelOffset === null) {\r\n              levelOffset = branchAligner.getGroupSize(node.parent, GroupType.RowChildren);\r\n            }\r\n            var interval = new Interval(itemPosition.topConnectorShift, itemPosition.bottomConnectorShift - 1, levelIndex + levelOffset)\r\n            var key = interval.toString();\r\n            if(!visited[key]) {\r\n              visited[key] = true;\r\n              intervals.push(interval);\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n      return orgTree.SKIP;\r\n    });\r\n\r\n    var mergedIntervals = [];\r\n    getMergedIntervals(this, intervals, function(interval) {\r\n      mergedIntervals.push(interval);\r\n    });\r\n    intervals = mergedIntervals;\r\n\r\n    /* merge intervals having equal logical levels */\r\n    mergedIntervals = [];\r\n    var currentInterval = null;\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      if(!currentInterval) {\r\n        currentInterval = interval;\r\n        mergedIntervals.push(interval);\r\n      } else {\r\n        if(currentInterval.context === interval.context) {\r\n          currentInterval.to = interval.to;\r\n        } else {\r\n          currentInterval = interval;\r\n          mergedIntervals.push(interval);\r\n        }\r\n      }\r\n    }\r\n    intervals = mergedIntervals;\r\n\r\n    /* extend first level to the top */\r\n    if(intervals.length > 0) {\r\n      intervals[0].from = 0;\r\n    }\r\n\r\n    /* fill gaps between levels */\r\n    for(var index = 0, len = intervals.length - 1; index < len; index+=1) {\r\n      var prev = intervals[index];\r\n      var next = intervals[index + 1];\r\n\r\n      prev.to = next.from;\r\n    }\r\n\r\n    /* find minimal level */\r\n    var minLevelIndex = null;\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      minLevelIndex = (minLevelIndex === null) ? interval.context : Math.min(minLevelIndex, interval.context);\r\n    }\r\n\r\n    /* group intervals by logical levels */ \r\n    var result = {};\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      var levelIndex = interval.context - minLevelIndex;\r\n      var logicalLevelPosition = result[levelIndex];\r\n      if(!logicalLevelPosition) {\r\n        result[levelIndex] = [interval];\r\n      } else {\r\n        logicalLevelPosition.push(interval);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  function getPositions() {\r\n    if(!_data.positions) {\r\n      _data.positions = createPositions();\r\n    }\r\n    return _data.positions;\r\n  }\r\n\r\n  return {\r\n    getPositions:getPositions,\r\n    process: process\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}