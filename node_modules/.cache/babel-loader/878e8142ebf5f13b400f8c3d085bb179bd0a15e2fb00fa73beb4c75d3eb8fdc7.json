{"ast":null,"code":"import getFamilyUnits from './getFamilyUnits';\nimport FamilyMargins from './FamilyMargins';\n/**\r\n * Callback function for getting family node width\r\n * \r\n * @callback onFamilyAlignmentItemSizeCallback\r\n * @param {string} itemid Family node id\r\n * @param {object} item Family node context object\r\n * @returns {number} Family node width\r\n */\n\n/**\r\n * Creates family alignment data structure. This structure aligns horizontally planar family of nodes.\r\n * @class FamilyAlignment\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {family} family Family data structure\r\n * @param {TreeLevels} treeLevels Three levels data structure\r\n * @param {onFamilyAlignmentItemSizeCallback} onItemSize Callback function to measure family node width\r\n * @returns {FamilyAlignment} Returns family alignment structure\r\n */\nexport default function FamilyAlignment(thisArg, family, treeLevels, onItemSize) {\n  var offsets,\n    sizes = {},\n    childrenDistances;\n  if (onItemSize != null) {\n    treeLevels.loopItems(this, function (itemid, item, position, levelIndex, level) {\n      sizes[itemid] = onItemSize.call(thisArg, itemid, item);\n    });\n  }\n  childrenDistances = getDistancesBetweenChildren(family, treeLevels);\n  offsets = getTreeLevelsOffsets(family, treeLevels, childrenDistances);\n  function _getNodeMargins(margins, nodeid) {\n    // create margins for node if it does not exists\n    var nodeMargins = margins[nodeid];\n    if (nodeMargins == null) {\n      nodeMargins = new FamilyMargins();\n      margins[nodeid] = nodeMargins;\n    }\n    return nodeMargins;\n  }\n  function getDistancesBetweenChildren(family, treeLevels) {\n    var distances = {};\n    var margins = {};\n    var levelMargins = null;\n    treeLevels.loopLevelsReversed(this, function (levelIndex, level) {\n      var newMargins = new FamilyMargins();\n      if (levelMargins != null) {\n        levelMargins.add(0, Number.MAX_VALUE);\n        newMargins.merge(levelMargins, 0);\n      }\n      levelMargins = newMargins;\n      var previousParentMargins = levelMargins;\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        var nodeMargins = _getNodeMargins(margins, nodeid);\n\n        // add node size into its margin\n        nodeMargins.add(sizes[nodeid], position);\n        switch (family.countParents(nodeid)) {\n          case 0:\n            if (previousParentMargins != null) {\n              distances[nodeid] = previousParentMargins.attach(nodeMargins);\n            }\n            break;\n          case 1:\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              var parentMargins = _getNodeMargins(margins, parentid);\n              distances[nodeid] = parentMargins.merge(nodeMargins);\n              previousParentMargins = parentMargins;\n              return family.BREAK;\n            });\n            break;\n          default:\n            // loop parents and find total size of them\n            var totalSize = 0;\n            var fromIndex = null;\n            var toIndex = null;\n            var hash = {};\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              if (levelIndex > 0) {\n                return family.BREAK;\n              }\n              totalSize += sizes[parentid];\n              var position = treeLevels.getItemPosition(parentid);\n              fromIndex = fromIndex == null ? position : Math.min(fromIndex, position);\n              toIndex = toIndex == null ? position : Math.max(toIndex, position);\n              hash[position] = parentid;\n            });\n            var offset = -totalSize / 2;\n            for (var index = fromIndex; index <= toIndex; index += 1) {\n              var parentid = hash[index];\n              offset += sizes[parentid] / 2.0;\n              var parentMargins = _getNodeMargins(margins, parentid);\n              parentMargins.attach(nodeMargins, -offset);\n              previousParentMargins = parentMargins;\n              offset += sizes[parentid] / 2.0;\n            }\n            break;\n        }\n      });\n    });\n    return distances;\n  }\n  function getTreeLevelsOffsets(family, treeLevels, childrenDistances) {\n    var offsets = {};\n    var familyUnitsById = getFamilyUnits(family);\n    var processedFamilyUnits = {};\n    treeLevels.loopLevels(this, function (levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        if (!offsets.hasOwnProperty(nodeid)) {\n          var offset = 0;\n          if (position === 0) {\n            if (childrenDistances[nodeid] != null) {\n              offset += childrenDistances[nodeid] + sizes[nodeid] / 2;\n            }\n          } else {\n            var prevNodeId = treeLevels.getItemAtPosition(levelIndex, position - 1);\n            offset += offsets[prevNodeId] + sizes[prevNodeId] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2;\n          }\n          offsets[nodeid] = offset;\n        }\n        var familyUnits = familyUnitsById[nodeid];\n        if (familyUnits != null) {\n          for (var index = 0; index < familyUnits.length; index += 1) {\n            var familyUnit = familyUnits[index];\n            if (!processedFamilyUnits.hasOwnProperty(familyUnit.id)) {\n              processedFamilyUnits[familyUnit.id] = true;\n              setFamilyOffsets(offsets, nodeid, familyUnit, levelIndex, levelIndex + 1, position, treeLevels, childrenDistances);\n            }\n          }\n        }\n      });\n    });\n    return offsets;\n  }\n  function setFamilyOffsets(offsets, itemid, familyUnit, fromLevel, toLevel, itemIndex, treeLevels, childrenDistances) {\n    var fromIndex = itemIndex;\n    var toIndex = itemIndex;\n    familyUnit.loopSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = Math.min(fromIndex, position);\n      toIndex = Math.max(toIndex, position);\n    });\n\n    // Place nodes on the left side of start node\n    for (var index = itemIndex - 1; index >= fromIndex; index -= 1) {\n      var siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n      if (!offsets.hasOwnProperty(siblingid)) {\n        var nodeid = treeLevels.getItemAtPosition(fromLevel, index + 1);\n        offsets[siblingid] = offsets[nodeid] - (sizes[siblingid] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2);\n      }\n    }\n    // Place nodes on the right side of start node\n    for (index = itemIndex + 1; index <= toIndex; index += 1) {\n      siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n      if (!offsets.hasOwnProperty(siblingid)) {\n        nodeid = treeLevels.getItemAtPosition(fromLevel, index - 1);\n        offsets[siblingid] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[siblingid] || 0) + sizes[siblingid] / 2);\n      }\n    }\n    siblingid = treeLevels.getItemAtPosition(fromLevel, fromIndex);\n    var siblingsMedian = offsets[siblingid] - sizes[siblingid] / 2;\n    siblingid = treeLevels.getItemAtPosition(fromLevel, toIndex);\n    siblingsMedian += offsets[siblingid] + sizes[siblingid] / 2;\n    siblingsMedian /= 2;\n    fromIndex = null;\n    toIndex = null;\n    familyUnit.loopNonSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = fromIndex != null ? Math.min(fromIndex, position) : position;\n      toIndex = toIndex != null ? Math.max(toIndex, position) : position;\n    });\n    var nonSiblingsWidth = 0;\n    for (index = fromIndex; index <= toIndex; index += 1) {\n      var relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n      nonSiblingsWidth += sizes[relatedItemId];\n      if (index > fromIndex) {\n        nonSiblingsWidth += childrenDistances[relatedItemId] || 0;\n      }\n    }\n    var offset = siblingsMedian - nonSiblingsWidth / 2;\n    relatedItemId = treeLevels.getItemAtPosition(toLevel, fromIndex);\n    if (!offsets.hasOwnProperty(relatedItemId)) {\n      offsets[relatedItemId] = offset + sizes[relatedItemId] / 2;\n    }\n    for (index = fromIndex + 1; index <= toIndex; index += 1) {\n      relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n      if (!offsets.hasOwnProperty(relatedItemId)) {\n        nodeid = treeLevels.getItemAtPosition(toLevel, index - 1);\n        offsets[relatedItemId] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[relatedItemId] || 0) + sizes[relatedItemId] / 2);\n      }\n    }\n  }\n\n  /**\r\n   * Returns horizontal node offset from left margin of the family diagram\r\n   * \r\n   * @param {string} nodeid Family node id\r\n   * @returns {number} Node offset\r\n   */\n  function getOffset(nodeid) {\n    return offsets[nodeid];\n  }\n  return {\n    getOffset: getOffset\n  };\n}\n;","map":{"version":3,"names":["getFamilyUnits","FamilyMargins","FamilyAlignment","thisArg","family","treeLevels","onItemSize","offsets","sizes","childrenDistances","loopItems","itemid","item","position","levelIndex","level","call","getDistancesBetweenChildren","getTreeLevelsOffsets","_getNodeMargins","margins","nodeid","nodeMargins","distances","levelMargins","loopLevelsReversed","newMargins","add","Number","MAX_VALUE","merge","previousParentMargins","loopLevelItems","node","countParents","attach","loopParents","parentid","parent","parentMargins","BREAK","totalSize","fromIndex","toIndex","hash","getItemPosition","Math","min","max","offset","index","familyUnitsById","processedFamilyUnits","loopLevels","hasOwnProperty","prevNodeId","getItemAtPosition","familyUnits","length","familyUnit","id","setFamilyOffsets","fromLevel","toLevel","itemIndex","loopSiblings","siblingid","siblingsMedian","loopNonSiblings","nonSiblingsWidth","relatedItemId","getOffset"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/FamilyAlignment.js"],"sourcesContent":["import getFamilyUnits from './getFamilyUnits';\r\nimport FamilyMargins from './FamilyMargins';\r\n/**\r\n * Callback function for getting family node width\r\n * \r\n * @callback onFamilyAlignmentItemSizeCallback\r\n * @param {string} itemid Family node id\r\n * @param {object} item Family node context object\r\n * @returns {number} Family node width\r\n */\r\n\r\n/**\r\n * Creates family alignment data structure. This structure aligns horizontally planar family of nodes.\r\n * @class FamilyAlignment\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {family} family Family data structure\r\n * @param {TreeLevels} treeLevels Three levels data structure\r\n * @param {onFamilyAlignmentItemSizeCallback} onItemSize Callback function to measure family node width\r\n * @returns {FamilyAlignment} Returns family alignment structure\r\n */\r\nexport default function FamilyAlignment(thisArg, family, treeLevels, onItemSize) {\r\n  var offsets,\r\n    sizes = {},\r\n    childrenDistances;\r\n\r\n  if (onItemSize != null) {\r\n    treeLevels.loopItems(this, function (itemid, item, position, levelIndex, level) {\r\n      sizes[itemid] = onItemSize.call(thisArg, itemid, item);\r\n    });\r\n  }\r\n\r\n  childrenDistances = getDistancesBetweenChildren(family, treeLevels);\r\n  offsets = getTreeLevelsOffsets(family, treeLevels, childrenDistances);\r\n\r\n  function _getNodeMargins(margins, nodeid) {\r\n    // create margins for node if it does not exists\r\n    var nodeMargins = margins[nodeid];\r\n    if (nodeMargins == null) {\r\n      nodeMargins = new FamilyMargins();\r\n      margins[nodeid] = nodeMargins;\r\n    }\r\n    return nodeMargins;\r\n  }\r\n\r\n  function getDistancesBetweenChildren(family, treeLevels) {\r\n    var distances = {};\r\n    var margins = {};\r\n    var levelMargins = null;\r\n\r\n    treeLevels.loopLevelsReversed(this, function (levelIndex, level) {\r\n      var newMargins = new FamilyMargins();\r\n      if (levelMargins != null) {\r\n        levelMargins.add(0, Number.MAX_VALUE);\r\n        newMargins.merge(levelMargins, 0);\r\n      }\r\n      levelMargins = newMargins;\r\n\r\n      var previousParentMargins = levelMargins;\r\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\r\n        var nodeMargins = _getNodeMargins(margins, nodeid);\r\n\r\n        // add node size into its margin\r\n        nodeMargins.add(sizes[nodeid], position);\r\n\r\n        switch (family.countParents(nodeid)) {\r\n          case 0:\r\n            if (previousParentMargins != null) {\r\n              distances[nodeid] = previousParentMargins.attach(nodeMargins);\r\n            }\r\n            break;\r\n          case 1:\r\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\r\n              var parentMargins = _getNodeMargins(margins, parentid);\r\n              distances[nodeid] = parentMargins.merge(nodeMargins);\r\n\r\n              previousParentMargins = parentMargins;\r\n              return family.BREAK;\r\n            });\r\n            break;\r\n          default:\r\n            // loop parents and find total size of them\r\n            var totalSize = 0;\r\n            var fromIndex = null;\r\n            var toIndex = null;\r\n            var hash = {};\r\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\r\n              if (levelIndex > 0) {\r\n                return family.BREAK;\r\n              }\r\n              totalSize += sizes[parentid];\r\n\r\n              var position = treeLevels.getItemPosition(parentid);\r\n              fromIndex = fromIndex == null ? position : Math.min(fromIndex, position);\r\n              toIndex = toIndex == null ? position : Math.max(toIndex, position);\r\n              hash[position] = parentid;\r\n            });\r\n\r\n            var offset = -totalSize / 2;\r\n            for (var index = fromIndex; index <= toIndex; index += 1) {\r\n              var parentid = hash[index];\r\n\r\n              offset += sizes[parentid] / 2.0;\r\n\r\n              var parentMargins = _getNodeMargins(margins, parentid);\r\n\r\n              parentMargins.attach(nodeMargins, -offset);\r\n\r\n              previousParentMargins = parentMargins;\r\n\r\n              offset += sizes[parentid] / 2.0;\r\n            }\r\n            break;\r\n        }\r\n      });\r\n    });\r\n\r\n    return distances;\r\n  }\r\n\r\n  function getTreeLevelsOffsets(family, treeLevels, childrenDistances) {\r\n    var offsets = {};\r\n\r\n    var familyUnitsById = getFamilyUnits(family);\r\n    var processedFamilyUnits = {};\r\n\r\n    treeLevels.loopLevels(this, function (levelIndex, level) {\r\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\r\n        if (!offsets.hasOwnProperty(nodeid)) {\r\n          var offset = 0;\r\n          if (position === 0) {\r\n            if (childrenDistances[nodeid] != null) {\r\n              offset += childrenDistances[nodeid] + sizes[nodeid] / 2;\r\n            }\r\n          } else {\r\n            var prevNodeId = treeLevels.getItemAtPosition(levelIndex, position - 1);\r\n            offset += offsets[prevNodeId] + sizes[prevNodeId] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2;\r\n          }\r\n          offsets[nodeid] = offset;\r\n        }\r\n        var familyUnits = familyUnitsById[nodeid];\r\n        if (familyUnits != null) {\r\n          for (var index = 0; index < familyUnits.length; index += 1) {\r\n            var familyUnit = familyUnits[index];\r\n            if (!processedFamilyUnits.hasOwnProperty(familyUnit.id)) {\r\n              processedFamilyUnits[familyUnit.id] = true;\r\n\r\n              setFamilyOffsets(offsets, nodeid, familyUnit, levelIndex, levelIndex + 1, position, treeLevels, childrenDistances);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return offsets;\r\n  }\r\n\r\n  function setFamilyOffsets(offsets, itemid, familyUnit, fromLevel, toLevel, itemIndex, treeLevels, childrenDistances) {\r\n    var fromIndex = itemIndex;\r\n    var toIndex = itemIndex;\r\n\r\n    familyUnit.loopSiblings(this, itemid, function (siblingid) {\r\n      var position = treeLevels.getItemPosition(siblingid);\r\n      fromIndex = Math.min(fromIndex, position);\r\n      toIndex = Math.max(toIndex, position);\r\n    });\r\n\r\n    // Place nodes on the left side of start node\r\n    for (var index = itemIndex - 1; index >= fromIndex; index -= 1) {\r\n      var siblingid = treeLevels.getItemAtPosition(fromLevel, index);\r\n\r\n      if (!offsets.hasOwnProperty(siblingid)) {\r\n        var nodeid = treeLevels.getItemAtPosition(fromLevel, index + 1);\r\n        offsets[siblingid] = offsets[nodeid] - (sizes[siblingid] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2);\r\n      }\r\n    }\r\n    // Place nodes on the right side of start node\r\n    for (index = itemIndex + 1; index <= toIndex; index += 1) {\r\n      siblingid = treeLevels.getItemAtPosition(fromLevel, index);\r\n\r\n      if (!offsets.hasOwnProperty(siblingid)) {\r\n        nodeid = treeLevels.getItemAtPosition(fromLevel, index - 1);\r\n        offsets[siblingid] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[siblingid] || 0) + sizes[siblingid] / 2);\r\n      }\r\n    }\r\n    siblingid = treeLevels.getItemAtPosition(fromLevel, fromIndex);\r\n    var siblingsMedian = offsets[siblingid] - sizes[siblingid] / 2;\r\n    siblingid = treeLevels.getItemAtPosition(fromLevel, toIndex);\r\n    siblingsMedian += offsets[siblingid] + sizes[siblingid] / 2;\r\n\r\n    siblingsMedian /= 2;\r\n\r\n    fromIndex = null;\r\n    toIndex = null;\r\n    familyUnit.loopNonSiblings(this, itemid, function (siblingid) {\r\n      var position = treeLevels.getItemPosition(siblingid);\r\n      fromIndex = fromIndex != null ? Math.min(fromIndex, position) : position;\r\n      toIndex = toIndex != null ? Math.max(toIndex, position) : position;\r\n    });\r\n\r\n    var nonSiblingsWidth = 0;\r\n    for (index = fromIndex; index <= toIndex; index += 1) {\r\n      var relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\r\n      nonSiblingsWidth += sizes[relatedItemId];\r\n      if (index > fromIndex) {\r\n        nonSiblingsWidth += (childrenDistances[relatedItemId] || 0);\r\n      }\r\n    }\r\n\r\n    var offset = siblingsMedian - nonSiblingsWidth / 2;\r\n    relatedItemId = treeLevels.getItemAtPosition(toLevel, fromIndex);\r\n    if (!offsets.hasOwnProperty(relatedItemId)) {\r\n      offsets[relatedItemId] = offset + sizes[relatedItemId] / 2;\r\n    }\r\n    for (index = fromIndex + 1; index <= toIndex; index += 1) {\r\n      relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\r\n      if (!offsets.hasOwnProperty(relatedItemId)) {\r\n        nodeid = treeLevels.getItemAtPosition(toLevel, index - 1);\r\n        offsets[relatedItemId] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[relatedItemId] || 0) + sizes[relatedItemId] / 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns horizontal node offset from left margin of the family diagram\r\n   * \r\n   * @param {string} nodeid Family node id\r\n   * @returns {number} Node offset\r\n   */\r\n  function getOffset(nodeid) {\r\n    return offsets[nodeid];\r\n  }\r\n\r\n  return {\r\n    getOffset: getOffset\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}