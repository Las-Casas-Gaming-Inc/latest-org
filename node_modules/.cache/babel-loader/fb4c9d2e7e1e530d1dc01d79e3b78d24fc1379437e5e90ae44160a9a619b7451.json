{"ast":null,"code":"import binarySearch from './binarySearch';\n/**\r\n * Breaks collection of values into 3 intervals, so values stay close to each other within interval.\r\n * \r\n * @param {number[]} values Array of values\r\n * @returns {number[]} Returns array containing 3 indexes. The first 2 break values into 3 intervals, \r\n * the last index is actual index of the last element in the values collection. \r\n */\nexport default function getLiniarBreaks(values) {\n  var _leftTotal = [],\n    _len = values.length;\n\n  // Sum up values from left to right\n  var total = 0;\n  for (var index = 0; index < _len; index += 1) {\n    total += values[index];\n    _leftTotal[index] = total;\n  }\n  function getLinearDeviation(leftIndex, rightIndex) {\n    var result = 0;\n    var avg = (_leftTotal[rightIndex] - _leftTotal[leftIndex] + values[leftIndex]) / (rightIndex - leftIndex + 1);\n    var median = binarySearch(values, function (item) {\n      return avg - item;\n    }, leftIndex, rightIndex);\n    if (median.item <= avg) {\n      result += avg * (median.index + 1 - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] + values[leftIndex]);\n      result += _leftTotal[rightIndex] - _leftTotal[median.index] - avg * (rightIndex - median.index);\n    } else {\n      result += avg * (median.index - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] - values[median.index] + values[leftIndex]);\n      result += _leftTotal[rightIndex] - _leftTotal[median.index] + values[median.index] - avg * (rightIndex - median.index + 1);\n    }\n    return result;\n  }\n  function getScore(leftIndex, rightIndex) {\n    var score = 0;\n    score += getLinearDeviation(0, leftIndex);\n    if (rightIndex > leftIndex + 1) {\n      score += getLinearDeviation(leftIndex + 1, rightIndex - 1);\n    }\n    score += getLinearDeviation(rightIndex, _len - 1);\n    return score;\n  }\n  var leftIndex = 0,\n    rightIndex = _len - 1;\n  var score = getScore(leftIndex, rightIndex);\n  while (leftIndex < rightIndex + 1) {\n    var leftScore = getScore(leftIndex + 1, rightIndex);\n    var rightScore = getScore(leftIndex, rightIndex - 1);\n    if (leftScore < rightScore) {\n      if (leftScore >= score) {\n        break;\n      }\n      leftIndex += 1;\n      score = leftScore;\n    } else {\n      if (rightScore >= score) {\n        break;\n      }\n      rightIndex -= 1;\n      score = rightScore;\n    }\n  }\n  return [leftIndex, rightIndex - 1, _len - 1];\n}\n;","map":{"version":3,"names":["binarySearch","getLiniarBreaks","values","_leftTotal","_len","length","total","index","getLinearDeviation","leftIndex","rightIndex","result","avg","median","item","getScore","score","leftScore","rightScore"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/algorithms/getLiniarBreaks.js"],"sourcesContent":["import binarySearch from './binarySearch';\r\n/**\r\n * Breaks collection of values into 3 intervals, so values stay close to each other within interval.\r\n * \r\n * @param {number[]} values Array of values\r\n * @returns {number[]} Returns array containing 3 indexes. The first 2 break values into 3 intervals, \r\n * the last index is actual index of the last element in the values collection. \r\n */\r\nexport default function getLiniarBreaks(values) {\r\n  var _leftTotal = [],\r\n    _len = values.length;\r\n\r\n  // Sum up values from left to right\r\n  var total = 0;\r\n  for (var index = 0; index < _len; index += 1) {\r\n    total += values[index];\r\n    _leftTotal[index] = total;\r\n  }\r\n\r\n  function getLinearDeviation(leftIndex, rightIndex) {\r\n    var result = 0;\r\n\r\n    var avg = (_leftTotal[rightIndex] - _leftTotal[leftIndex] + values[leftIndex]) / (rightIndex - leftIndex + 1);\r\n\r\n    var median = binarySearch(values, function (item) {\r\n      return avg - item;\r\n    }, leftIndex, rightIndex);\r\n\r\n    if (median.item <= avg) {\r\n      result += (avg * (median.index + 1 - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] + values[leftIndex]));\r\n      result += (_leftTotal[rightIndex] - _leftTotal[median.index] - avg * (rightIndex - median.index));\r\n    } else {\r\n      result += (avg * (median.index - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] - values[median.index] + values[leftIndex]));\r\n      result += (_leftTotal[rightIndex] - _leftTotal[median.index] + values[median.index] - avg * (rightIndex - median.index + 1));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function getScore(leftIndex, rightIndex) {\r\n    var score = 0;\r\n\r\n    score += getLinearDeviation(0, leftIndex);\r\n    if (rightIndex > leftIndex + 1) {\r\n      score += getLinearDeviation(leftIndex + 1, rightIndex - 1);\r\n    }\r\n    score += getLinearDeviation(rightIndex, _len - 1);\r\n\r\n    return score;\r\n  }\r\n\r\n  var leftIndex = 0,\r\n    rightIndex = _len - 1;\r\n\r\n  var score = getScore(leftIndex, rightIndex);\r\n\r\n  while (leftIndex < rightIndex + 1) {\r\n    var leftScore = getScore(leftIndex + 1, rightIndex);\r\n    var rightScore = getScore(leftIndex, rightIndex - 1);\r\n\r\n    if (leftScore < rightScore) {\r\n      if (leftScore >= score) {\r\n        break;\r\n      }\r\n      leftIndex += 1;\r\n      score = leftScore;\r\n    } else {\r\n      if (rightScore >= score) {\r\n        break;\r\n      }\r\n      rightIndex -= 1;\r\n      score = rightScore;\r\n    }\r\n  }\r\n\r\n  return [leftIndex, rightIndex - 1, _len - 1];\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}