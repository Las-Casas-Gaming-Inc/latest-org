{"ast":null,"code":"/**\r\n * Creates linked hash list collection.\r\n * @class LinkedHashItems\r\n * \r\n * @returns {LinkedHashItems} Returns linked hash list structure\r\n */\nexport default function LinkedHashItems() {\n  var segmentsHash = {},\n    nextKeys = {},\n    prevKeys = {},\n    startSegmentKey = null,\n    endSegmentKey = null;\n\n  /**\r\n   * Adds new item to collection\r\n   * @param {string} key The new item key \r\n   * @param {object} item The new item context object value\r\n   */\n  function add(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    segmentsHash[key] = item;\n    nextKeys[key] = null;\n    if (endSegmentKey == null) {\n      startSegmentKey = key;\n      prevKeys[key] = null;\n    } else {\n      nextKeys[endSegmentKey] = key;\n      prevKeys[key] = endSegmentKey;\n    }\n    endSegmentKey = key;\n  }\n\n  /**\r\n   * Checks if collection is empty\r\n   * \r\n   * @returns {boolean} Returns true if collection is empty\r\n   */\n  function isEmpty() {\n    return startSegmentKey == null;\n  }\n\n  /**\r\n   * Item context object\r\n   * \r\n   * @param {string} key The item's key\r\n   * @returns {object} Returns context object\r\n   */\n  function item(key) {\n    return segmentsHash[key];\n  }\n\n  /**\r\n   * Gets next key\r\n   * \r\n   * @param {string} key The item key\r\n   * @returns {string} Returns key of the next collection item\r\n   */\n  function nextKey(key) {\n    return nextKeys[key];\n  }\n\n  /**\r\n   * Gets previous key\r\n   * \r\n   * @param {string} key The item key\r\n   * @returns {string} Returns key of the previous collection item\r\n   */\n  function prevKey(key) {\n    return prevKeys[key];\n  }\n\n  /**\r\n   * First collection item key\r\n   * \r\n   * @returns {string} Returns the key of the first item in the collection\r\n   */\n  function startKey() {\n    return startSegmentKey;\n  }\n\n  /**\r\n   * Last collection item key\r\n   * \r\n   * @returns {string} Returns key of the last item in the collection\r\n   */\n  function endKey() {\n    return endSegmentKey;\n  }\n\n  /**\r\n  * Adds new item to the head of the list\r\n  * \r\n  * @param {string} key The new item key \r\n  * @param {object} item The new item context object value\r\n  * @returns {string} Returns key of the last item in the collection\r\n  */\n  function unshift(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    segmentsHash[key] = item;\n    prevKeys[key] = null;\n    if (startSegmentKey == null) {\n      endSegmentKey = key;\n      nextKeys[key] = null;\n    } else {\n      prevKeys[startSegmentKey] = key;\n      nextKeys[key] = startSegmentKey;\n    }\n    startSegmentKey = key;\n  }\n\n  /**\r\n  * Inserts new item into the list after the given key \r\n  *  \r\n  * @param {string} afterKey The key that the new element is placed after \r\n  * @param {string} key The new item key \r\n  * @param {object} item The new item context object value\r\n  */\n  function insertAfter(afterKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    if (afterKey == null) {\n      unshift(key, item);\n    } else {\n      var nextKey = nextKeys[afterKey];\n      if (nextKey == null) {\n        add(key, item);\n      } else {\n        segmentsHash[key] = item;\n        nextKeys[afterKey] = key;\n        nextKeys[key] = nextKey;\n        prevKeys[nextKey] = key;\n        prevKeys[key] = afterKey;\n      }\n    }\n  }\n\n  /**\r\n   * Inserts new item into the list before the given key  \r\n   * \r\n   * @param {string} beforeKey The key that the new element is placed before \r\n   * @param {string} key The new item key \r\n   * @param {object} item The new item context object value\r\n   */\n  function insertBefore(beforeKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    if (beforeKey == null || !segmentsHash.hasOwnProperty(beforeKey)) {\n      throw \"Before key should be defined!\";\n    }\n    var prevKey = prevKeys[beforeKey];\n    if (prevKey == null) {\n      unshift(key, item);\n    } else {\n      insertAfter(prevKey, key, item);\n    }\n  }\n\n  /**\r\n   * Removes item\r\n   * @param {string} key The key of the item \r\n   */\n  function remove(key) {\n    var prevKey = prevKeys[key],\n      nextKey = nextKeys[key];\n    if (prevKey != null) {\n      nextKeys[prevKey] = nextKey;\n    } else {\n      startSegmentKey = nextKey;\n    }\n    if (nextKey != null) {\n      prevKeys[nextKey] = prevKey;\n    } else {\n      endSegmentKey = prevKey;\n    }\n    delete segmentsHash[key];\n    delete nextKeys[key];\n    delete prevKeys[key];\n  }\n\n  /**\r\n   * Empties collection\r\n   */\n  function empty() {\n    segmentsHash = {};\n    nextKeys = {};\n    prevKeys = {};\n    startSegmentKey = null;\n    endSegmentKey = null;\n  }\n  function _iterate(forward, onItem, startKey, endKey) {\n    var key = startKey,\n      segment;\n    if (key == null) {\n      key = forward ? startSegmentKey : endSegmentKey;\n    }\n    if (onItem != null) {\n      while (key != null) {\n        segment = segmentsHash[key];\n        if (segment != null) {\n          if (onItem(segment, key)) {\n            return;\n          }\n        }\n        if (key == endKey) {\n          key = null;\n        } else {\n          key = forward ? nextKeys[key] : prevKeys[key];\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Appends one list to another\r\n   * \r\n   * @param {LinkedHashItems} list A list to append to the end of the current list  \r\n   */\n  function attach(list) {\n    list.iterate(function (segment, key) {\n      add(key, segment);\n    });\n  }\n\n  /**\r\n   * Callback function for iterating list items\r\n   * \r\n   * @callback onLinkedHashItemsCallback\r\n   * @param {object} item  The item context object\r\n   * @param {string} key The item key\r\n   * @returns {boolean} Returns true to break the iteration process\r\n   */\n\n  /**\r\n   * Loops items of the collection\r\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\r\n   * @param {string} startKey The key to start iteration from \r\n   * @param {string} endKey The key to end iteration at\r\n   */\n  function iterate(onItem, startKey, endKey) {\n    _iterate(true, onItem, startKey, endKey);\n  }\n\n  /**\r\n   * Loops items of the collection backward\r\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\r\n   * @param {string} startKey The key to start iteration from \r\n   * @param {string} endKey The key to end iteration at\r\n   */\n  function iterateBack(onItem, startKey, endKey) {\n    _iterate(false, onItem, startKey, endKey);\n  }\n\n  /**\r\n   * Validates internal data consistency of the structure\r\n   * @returns {boolean} Returns true if it pass validation\r\n   */\n  function validate(info) {\n    var key, prevKey, nextKey;\n    for (key in segmentsHash) {\n      if (segmentsHash.hasOwnProperty(key)) {\n        if (!nextKeys.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n      }\n    }\n    if (!segmentsHash.hasOwnProperty(startSegmentKey) || !segmentsHash.hasOwnProperty(endSegmentKey)) {\n      if (info != null) {\n        info.message = \"Start or end values are missing!\";\n      }\n      return false;\n    }\n    for (key in nextKeys) {\n      if (nextKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n        nextKey = nextKeys[key];\n        if (nextKey && !nextKeys.hasOwnProperty(nextKey)) {\n          if (info != null) {\n            info.message = \"Next key not found!\";\n          }\n          return false;\n        }\n      }\n    }\n    for (key in prevKeys) {\n      if (prevKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !nextKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n        prevKey = prevKeys[key];\n        if (prevKey && !prevKeys.hasOwnProperty(prevKey)) {\n          if (info != null) {\n            info.message = \"Prev key not found!\";\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\r\n   * Returns a regular javascript array of collection items\r\n   * \r\n   * @returns {object[]} Returns array containing items of the collection\r\n   */\n  function toArray() {\n    var result = [];\n    iterate(function (item) {\n      result.push(item);\n    });\n    return result;\n  }\n  return {\n    add: add,\n    item: item,\n    nextKey: nextKey,\n    prevKey: prevKey,\n    startKey: startKey,\n    endKey: endKey,\n    unshift: unshift,\n    insertAfter: insertAfter,\n    insertBefore: insertBefore,\n    remove: remove,\n    isEmpty: isEmpty,\n    attach: attach,\n    iterate: iterate,\n    iterateBack: iterateBack,\n    empty: empty,\n    toArray: toArray,\n    validate: validate\n  };\n}\n;","map":{"version":3,"names":["LinkedHashItems","segmentsHash","nextKeys","prevKeys","startSegmentKey","endSegmentKey","add","key","item","hasOwnProperty","isEmpty","nextKey","prevKey","startKey","endKey","unshift","insertAfter","afterKey","insertBefore","beforeKey","remove","empty","_iterate","forward","onItem","segment","attach","list","iterate","iterateBack","validate","info","message","toArray","result","push"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/LinkedHashItems.js"],"sourcesContent":["/**\r\n * Creates linked hash list collection.\r\n * @class LinkedHashItems\r\n * \r\n * @returns {LinkedHashItems} Returns linked hash list structure\r\n */\r\nexport default function LinkedHashItems() {\r\n  var segmentsHash = {},\r\n    nextKeys = {},\r\n    prevKeys = {},\r\n    startSegmentKey = null,\r\n    endSegmentKey = null;\r\n\r\n  /**\r\n   * Adds new item to collection\r\n   * @param {string} key The new item key \r\n   * @param {object} item The new item context object value\r\n   */\r\n  function add(key, item) {\r\n    if (segmentsHash.hasOwnProperty(key)) {\r\n      throw \"Duplicate segments are not supported!\";\r\n    }\r\n    segmentsHash[key] = item;\r\n    nextKeys[key] = null;\r\n    if (endSegmentKey == null) {\r\n      startSegmentKey = key;\r\n      prevKeys[key] = null;\r\n    } else {\r\n      nextKeys[endSegmentKey] = key;\r\n      prevKeys[key] = endSegmentKey;\r\n    }\r\n    endSegmentKey = key;\r\n  }\r\n\r\n  /**\r\n   * Checks if collection is empty\r\n   * \r\n   * @returns {boolean} Returns true if collection is empty\r\n   */\r\n  function isEmpty() {\r\n    return startSegmentKey == null;\r\n  }\r\n\r\n  /**\r\n   * Item context object\r\n   * \r\n   * @param {string} key The item's key\r\n   * @returns {object} Returns context object\r\n   */\r\n  function item(key) {\r\n    return segmentsHash[key];\r\n  }\r\n\r\n  /**\r\n   * Gets next key\r\n   * \r\n   * @param {string} key The item key\r\n   * @returns {string} Returns key of the next collection item\r\n   */\r\n  function nextKey(key) {\r\n    return nextKeys[key];\r\n  }\r\n\r\n  /**\r\n   * Gets previous key\r\n   * \r\n   * @param {string} key The item key\r\n   * @returns {string} Returns key of the previous collection item\r\n   */\r\n  function prevKey(key) {\r\n    return prevKeys[key];\r\n  }\r\n\r\n  /**\r\n   * First collection item key\r\n   * \r\n   * @returns {string} Returns the key of the first item in the collection\r\n   */\r\n  function startKey() {\r\n    return startSegmentKey;\r\n  }\r\n\r\n  /**\r\n   * Last collection item key\r\n   * \r\n   * @returns {string} Returns key of the last item in the collection\r\n   */\r\n  function endKey() {\r\n    return endSegmentKey;\r\n  }\r\n\r\n  /**\r\n  * Adds new item to the head of the list\r\n  * \r\n  * @param {string} key The new item key \r\n  * @param {object} item The new item context object value\r\n  * @returns {string} Returns key of the last item in the collection\r\n  */\r\n  function unshift(key, item) {\r\n    if (segmentsHash.hasOwnProperty(key)) {\r\n      throw \"Duplicate segments are not supported!\";\r\n    }\r\n    segmentsHash[key] = item;\r\n    prevKeys[key] = null;\r\n    if (startSegmentKey == null) {\r\n      endSegmentKey = key;\r\n      nextKeys[key] = null;\r\n    } else {\r\n      prevKeys[startSegmentKey] = key;\r\n      nextKeys[key] = startSegmentKey;\r\n    }\r\n    startSegmentKey = key;\r\n  }\r\n\r\n  /**\r\n  * Inserts new item into the list after the given key \r\n  *  \r\n  * @param {string} afterKey The key that the new element is placed after \r\n  * @param {string} key The new item key \r\n  * @param {object} item The new item context object value\r\n  */\r\n  function insertAfter(afterKey, key, item) {\r\n    if (segmentsHash.hasOwnProperty(key)) {\r\n      throw \"Duplicate segments are not supported!\";\r\n    }\r\n\r\n    if (afterKey == null) {\r\n      unshift(key, item);\r\n    } else {\r\n      var nextKey = nextKeys[afterKey];\r\n      if (nextKey == null) {\r\n        add(key, item);\r\n      } else {\r\n        segmentsHash[key] = item;\r\n        nextKeys[afterKey] = key;\r\n        nextKeys[key] = nextKey;\r\n        prevKeys[nextKey] = key;\r\n        prevKeys[key] = afterKey;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inserts new item into the list before the given key  \r\n   * \r\n   * @param {string} beforeKey The key that the new element is placed before \r\n   * @param {string} key The new item key \r\n   * @param {object} item The new item context object value\r\n   */\r\n  function insertBefore(beforeKey, key, item) {\r\n    if (segmentsHash.hasOwnProperty(key)) {\r\n      throw \"Duplicate segments are not supported!\";\r\n    }\r\n    if (beforeKey == null || !segmentsHash.hasOwnProperty(beforeKey)) {\r\n      throw \"Before key should be defined!\";\r\n    }\r\n    var prevKey = prevKeys[beforeKey];\r\n    if (prevKey == null) {\r\n      unshift(key, item);\r\n    } else {\r\n      insertAfter(prevKey, key, item)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes item\r\n   * @param {string} key The key of the item \r\n   */\r\n  function remove(key) {\r\n    var prevKey = prevKeys[key],\r\n      nextKey = nextKeys[key];\r\n\r\n    if (prevKey != null) {\r\n      nextKeys[prevKey] = nextKey;\r\n    } else {\r\n      startSegmentKey = nextKey;\r\n    }\r\n\r\n    if (nextKey != null) {\r\n      prevKeys[nextKey] = prevKey;\r\n    } else {\r\n      endSegmentKey = prevKey;\r\n    }\r\n\r\n    delete segmentsHash[key];\r\n    delete nextKeys[key];\r\n    delete prevKeys[key];\r\n  }\r\n\r\n  /**\r\n   * Empties collection\r\n   */\r\n  function empty() {\r\n    segmentsHash = {};\r\n    nextKeys = {};\r\n    prevKeys = {};\r\n    startSegmentKey = null;\r\n    endSegmentKey = null;\r\n  }\r\n\r\n  function _iterate(forward, onItem, startKey, endKey) {\r\n    var key = startKey,\r\n      segment;\r\n\r\n    if (key == null) {\r\n      key = forward ? startSegmentKey : endSegmentKey;\r\n    }\r\n\r\n    if (onItem != null) {\r\n      while (key != null) {\r\n        segment = segmentsHash[key];\r\n        if (segment != null) {\r\n          if (onItem(segment, key)) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        if (key == endKey) {\r\n          key = null;\r\n        } else {\r\n          key = forward ? nextKeys[key] : prevKeys[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Appends one list to another\r\n   * \r\n   * @param {LinkedHashItems} list A list to append to the end of the current list  \r\n   */\r\n  function attach(list) {\r\n    list.iterate(function (segment, key) {\r\n      add(key, segment);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback function for iterating list items\r\n   * \r\n   * @callback onLinkedHashItemsCallback\r\n   * @param {object} item  The item context object\r\n   * @param {string} key The item key\r\n   * @returns {boolean} Returns true to break the iteration process\r\n   */\r\n\r\n  /**\r\n   * Loops items of the collection\r\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\r\n   * @param {string} startKey The key to start iteration from \r\n   * @param {string} endKey The key to end iteration at\r\n   */\r\n  function iterate(onItem, startKey, endKey) {\r\n    _iterate(true, onItem, startKey, endKey);\r\n  }\r\n\r\n  /**\r\n   * Loops items of the collection backward\r\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\r\n   * @param {string} startKey The key to start iteration from \r\n   * @param {string} endKey The key to end iteration at\r\n   */\r\n  function iterateBack(onItem, startKey, endKey) {\r\n    _iterate(false, onItem, startKey, endKey);\r\n  }\r\n\r\n  /**\r\n   * Validates internal data consistency of the structure\r\n   * @returns {boolean} Returns true if it pass validation\r\n   */\r\n  function validate(info) {\r\n    var key, prevKey, nextKey;\r\n    for (key in segmentsHash) {\r\n      if (segmentsHash.hasOwnProperty(key)) {\r\n        if (!nextKeys.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\r\n          if (info != null) {\r\n            info.message = \"Orphant key found!\";\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    if (!segmentsHash.hasOwnProperty(startSegmentKey) || !segmentsHash.hasOwnProperty(endSegmentKey)) {\r\n      if (info != null) {\r\n        info.message = \"Start or end values are missing!\";\r\n      }\r\n      return false;\r\n    }\r\n    for (key in nextKeys) {\r\n      if (nextKeys.hasOwnProperty(key)) {\r\n        if (!segmentsHash.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\r\n          if (info != null) {\r\n            info.message = \"Orphant key found!\";\r\n          }\r\n          return false;\r\n        }\r\n        nextKey = nextKeys[key];\r\n        if (nextKey && !nextKeys.hasOwnProperty(nextKey)) {\r\n          if (info != null) {\r\n            info.message = \"Next key not found!\";\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    for (key in prevKeys) {\r\n      if (prevKeys.hasOwnProperty(key)) {\r\n        if (!segmentsHash.hasOwnProperty(key) || !nextKeys.hasOwnProperty(key)) {\r\n          if (info != null) {\r\n            info.message = \"Orphant key found!\";\r\n          }\r\n          return false;\r\n        }\r\n        prevKey = prevKeys[key];\r\n        if (prevKey && !prevKeys.hasOwnProperty(prevKey)) {\r\n          if (info != null) {\r\n            info.message = \"Prev key not found!\";\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns a regular javascript array of collection items\r\n   * \r\n   * @returns {object[]} Returns array containing items of the collection\r\n   */\r\n  function toArray() {\r\n    var result = [];\r\n\r\n    iterate(function (item) {\r\n      result.push(item);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    add: add,\r\n    item: item,\r\n    nextKey: nextKey,\r\n    prevKey: prevKey,\r\n    startKey: startKey,\r\n    endKey: endKey,\r\n    unshift: unshift,\r\n    insertAfter: insertAfter,\r\n    insertBefore: insertBefore,\r\n    remove: remove,\r\n    isEmpty: isEmpty,\r\n    attach: attach,\r\n\r\n    iterate: iterate,\r\n    iterateBack: iterateBack,\r\n    empty: empty,\r\n    toArray: toArray,\r\n    validate: validate\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}