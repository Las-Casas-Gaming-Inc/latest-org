{"ast":null,"code":"import BaseTransformer from './BaseTransformer';\nimport FamilyItem from '../../../models/FamilyItem';\nimport { GroupByType } from '../../../enums';\nimport MatrixConnectorBundle from '../../../connectors/MatrixConnectorBundle';\nimport HorizontalConnectorBundle from '../../../connectors/HorizontalConnectorBundle';\nimport MatrixLayout from '../../transformations/layouts/MatrixLayout';\nimport HorizontalLayout from '../../transformations/layouts/HorizontalLayout';\nexport default function FamilyMatrixesExtractor(debug) {\n  this.parent = BaseTransformer.prototype;\n  this.parent.constructor.apply(this, arguments);\n}\n;\nFamilyMatrixesExtractor.prototype = new BaseTransformer();\nFamilyMatrixesExtractor.prototype.extract = function (options, getConfig, logicalFamily, maximumId) {\n  var layouts = {},\n    nestedLayoutParentConnectorIds = {},\n    nestedLayoutBottomConnectorIds = {},\n    bundles = [];\n  if (logicalFamily.hasNodes() > 0) {\n    /* find nodes having the same parent and child nodes and replace them with matrix placeholder node */\n    if (options.enableMatrixLayout) {\n      logicalFamily.groupBy(this, Math.max(2, options.minimumMatrixSize), function (parentIds, childIds, groups) {\n        var nodes = [];\n        for (var groupIndex = 0; groupIndex < groups.length; groupIndex += 1) {\n          var group = groups[groupIndex];\n          if (group.length == 1) {\n            nodes.push(group[0].node);\n          } else {\n            maximumId += 1;\n            var id = maximumId;\n            maximumId += 1;\n            var id2 = maximumId;\n            var horizontalNode = new FamilyItem({\n              id: id,\n              isVisible: false,\n              isActive: false,\n              itemConfig: {\n                title: \"dummy #\" + id,\n                description: \"This is item used as aggregator of horizontally grouped nodes.\"\n              },\n              hideParentConnection: true,\n              hideChildrenConnection: true\n            });\n            nestedLayoutParentConnectorIds[id] = group[0].id; /* id is needed for connectors graph */\n            nestedLayoutBottomConnectorIds[id] = group[group.length - 1].id; /* id is needed for connectors graph */\n\n            for (var index = 0; index < group.length - 1; index += 1) {\n              var fromNode = group[index];\n              var toNode = group[index + 1];\n              bundles.push(new HorizontalConnectorBundle(toNode.id, fromNode.id));\n            }\n            for (var index = 0; index < group.length; index += 1) {\n              var node = group[index];\n              logicalFamily.removeNode(node.id);\n            }\n            var ids = nodes.map(node => node.id);\n            if (parentIds.length > 0) {\n              logicalFamily.add(parentIds, id, horizontalNode);\n              horizontalNode.hideParentConnection = false;\n            } else {\n              logicalFamily.add(null, id, horizontalNode);\n            }\n            if (childIds.length > 0) {\n              for (var index = 0; index < childIds.length; index += 1) {\n                logicalFamily.adopt([id], childIds[index]);\n              }\n              horizontalNode.hideChildrenConnection = false;\n            }\n            layouts[id] = new HorizontalLayout(group.map(item => item.node), horizontalNode.hideParentConnection, horizontalNode.hideChildrenConnection);\n            nodes.push(horizontalNode);\n          }\n        }\n        maximumId += 1;\n        var id = maximumId;\n        maximumId += 1;\n        var id2 = maximumId;\n        var matrixNode = new FamilyItem({\n          id: id,\n          isVisible: false,\n          isActive: false,\n          itemConfig: {\n            title: \"dummy #\" + id,\n            description: \"This is item used as aggregator of matrixed nodes.\"\n          },\n          hideParentConnection: true,\n          hideChildrenConnection: true\n        });\n        nestedLayoutBottomConnectorIds[id] = id2; /* id2 is needed for connectors graph */\n\n        for (var index = 0, len = nodes.length; index < len; index += 1) {\n          var node = nodes[index];\n          logicalFamily.removeNode(node.id);\n        }\n        var ids = nodes.map(node => node.id);\n        if (parentIds.length > 0) {\n          logicalFamily.add(parentIds, id, matrixNode);\n          matrixNode.hideParentConnection = false;\n          bundles.push(new MatrixConnectorBundle(true, ids, id, id, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));\n        } else {\n          logicalFamily.add(null, id, matrixNode);\n        }\n        if (childIds.length > 0) {\n          for (var index = 0; index < childIds.length; index += 1) {\n            logicalFamily.adopt([id], childIds[index]);\n          }\n          matrixNode.hideChildrenConnection = false;\n          bundles.push(new MatrixConnectorBundle(false, ids, id, id2, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));\n        }\n        layouts[id] = new MatrixLayout(nodes, matrixNode.hideParentConnection, matrixNode.hideChildrenConnection);\n      }, function (items) {\n        var result = null;\n        var count = 0;\n        for (var index = 0; index < items.length; index += 1) {\n          var item = items[index];\n          var itemConfig = getConfig(item.id);\n          if (itemConfig != null) {\n            if (count > 0) {\n              result = -1;\n              break;\n            }\n            count++;\n            if (itemConfig.addToMatrix) {\n              result = itemConfig.matrixId;\n            } else {\n              result = -1;\n              break;\n            }\n          }\n        }\n        if (count == 0) {\n          result = -1;\n        }\n        return result;\n      });\n    }\n  }\n  return {\n    maximumId,\n    nestedLayoutParentConnectorIds,\n    nestedLayoutBottomConnectorIds,\n    layouts,\n    bundles\n  };\n};\nFamilyMatrixesExtractor.prototype.getMatrixWidth = function (maximumColumnsInMatrix, len) {\n  return Math.min(maximumColumnsInMatrix, Math.ceil(Math.sqrt(len)));\n};","map":{"version":3,"names":["BaseTransformer","FamilyItem","GroupByType","MatrixConnectorBundle","HorizontalConnectorBundle","MatrixLayout","HorizontalLayout","FamilyMatrixesExtractor","debug","parent","prototype","constructor","apply","arguments","extract","options","getConfig","logicalFamily","maximumId","layouts","nestedLayoutParentConnectorIds","nestedLayoutBottomConnectorIds","bundles","hasNodes","enableMatrixLayout","groupBy","Math","max","minimumMatrixSize","parentIds","childIds","groups","nodes","groupIndex","length","group","push","node","id","id2","horizontalNode","isVisible","isActive","itemConfig","title","description","hideParentConnection","hideChildrenConnection","index","fromNode","toNode","removeNode","ids","map","add","adopt","item","matrixNode","len","getMatrixWidth","maximumColumnsInMatrix","items","result","count","addToMatrix","matrixId","min","ceil","sqrt"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyMatrixesExtractor.js"],"sourcesContent":["import BaseTransformer from './BaseTransformer';\r\nimport FamilyItem from '../../../models/FamilyItem';\r\nimport { GroupByType } from '../../../enums';\r\nimport MatrixConnectorBundle from '../../../connectors/MatrixConnectorBundle';\r\nimport HorizontalConnectorBundle from '../../../connectors/HorizontalConnectorBundle';\r\nimport MatrixLayout from '../../transformations/layouts/MatrixLayout';\r\nimport HorizontalLayout from '../../transformations/layouts/HorizontalLayout';\r\n\r\nexport default function FamilyMatrixesExtractor(debug) {\r\n  this.parent = BaseTransformer.prototype;\r\n  this.parent.constructor.apply(this, arguments);\r\n};\r\n\r\nFamilyMatrixesExtractor.prototype = new BaseTransformer();\r\n\r\nFamilyMatrixesExtractor.prototype.extract = function (options, getConfig, logicalFamily, maximumId) {\r\n  var layouts = {},\r\n      nestedLayoutParentConnectorIds = {},\r\n      nestedLayoutBottomConnectorIds = {},\r\n      bundles = [];\r\n\r\n  if (logicalFamily.hasNodes() > 0) {\r\n    /* find nodes having the same parent and child nodes and replace them with matrix placeholder node */\r\n    if (options.enableMatrixLayout) {\r\n      logicalFamily.groupBy(this, Math.max(2, options.minimumMatrixSize), function (parentIds, childIds, groups) {\r\n\r\n        var nodes = [];\r\n        for(var groupIndex = 0; groupIndex < groups.length; groupIndex+=1) {\r\n          var group = groups[groupIndex];\r\n\r\n          if(group.length == 1) {\r\n            nodes.push(group[0].node);\r\n          } else {\r\n            maximumId += 1;\r\n            var id = maximumId;\r\n            maximumId += 1;\r\n            var id2 = maximumId;\r\n\r\n            var horizontalNode = new FamilyItem({\r\n              id: id,\r\n              isVisible: false,\r\n              isActive: false,\r\n              itemConfig: { title: \"dummy #\" + id, description: \"This is item used as aggregator of horizontally grouped nodes.\" },\r\n              hideParentConnection: true,\r\n              hideChildrenConnection: true\r\n            });     \r\n            \r\n            nestedLayoutParentConnectorIds[id] = group[0].id; /* id is needed for connectors graph */\r\n            nestedLayoutBottomConnectorIds[id] = group[group.length - 1].id; /* id is needed for connectors graph */\r\n\r\n            for(var index = 0; index < group.length - 1; index+=1) {\r\n              var fromNode = group[index];\r\n              var toNode = group[index+1];\r\n              bundles.push(new HorizontalConnectorBundle(toNode.id, fromNode.id));\r\n            }\r\n\r\n            for (var index = 0; index < group.length; index += 1) {\r\n              var node = group[index];\r\n              logicalFamily.removeNode(node.id);\r\n            }\r\n\r\n            var ids = nodes.map(node => node.id);\r\n            if (parentIds.length > 0) {\r\n              logicalFamily.add(parentIds, id, horizontalNode);\r\n              horizontalNode.hideParentConnection = false;\r\n            } else {\r\n              logicalFamily.add(null, id, horizontalNode);\r\n            }\r\n    \r\n            if (childIds.length > 0) {\r\n              for(var index = 0; index < childIds.length; index+=1) {\r\n                logicalFamily.adopt([id], childIds[index]);\r\n              }\r\n              horizontalNode.hideChildrenConnection = false;\r\n            }            \r\n\r\n            layouts[id] = new HorizontalLayout(group.map(item => item.node), horizontalNode.hideParentConnection, horizontalNode.hideChildrenConnection);\r\n\r\n            nodes.push(horizontalNode);\r\n          }\r\n        }\r\n\r\n        maximumId += 1;\r\n        var id = maximumId;\r\n        maximumId += 1;\r\n        var id2 = maximumId;\r\n\r\n        var matrixNode = new FamilyItem({\r\n          id: id,\r\n          isVisible: false,\r\n          isActive: false,\r\n          itemConfig: { title: \"dummy #\" + id, description: \"This is item used as aggregator of matrixed nodes.\" },\r\n          hideParentConnection: true,\r\n          hideChildrenConnection: true\r\n        });\r\n\r\n        nestedLayoutBottomConnectorIds[id] = id2; /* id2 is needed for connectors graph */\r\n\r\n        for (var index = 0, len = nodes.length; index < len; index += 1) {\r\n          var node = nodes[index];\r\n          logicalFamily.removeNode(node.id);\r\n        }\r\n\r\n        var ids = nodes.map(node => node.id);\r\n        if (parentIds.length > 0 ) {\r\n          logicalFamily.add(parentIds, id, matrixNode);\r\n          matrixNode.hideParentConnection = false;\r\n          bundles.push(new MatrixConnectorBundle(true, ids, id, id, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));\r\n        } else {\r\n          logicalFamily.add(null, id, matrixNode);\r\n        }\r\n\r\n        if (childIds.length > 0) {\r\n          for(var index = 0; index < childIds.length; index+=1) {\r\n            logicalFamily.adopt([id], childIds[index]);\r\n          }\r\n          matrixNode.hideChildrenConnection = false;\r\n          bundles.push(new MatrixConnectorBundle(false, ids, id, id2, this.getMatrixWidth(options.maximumColumnsInMatrix, ids.length)));\r\n        }\r\n        layouts[id] = new MatrixLayout(nodes, matrixNode.hideParentConnection, matrixNode.hideChildrenConnection);\r\n      }, function(items) {\r\n        var result = null;\r\n        var count = 0;\r\n        for(var index = 0; index < items.length; index+=1) {\r\n          var item = items[index];\r\n          var itemConfig = getConfig(item.id);\r\n          if(itemConfig != null) {\r\n            if(count > 0) {\r\n              result = -1;\r\n              break;                \r\n            }\r\n            count++;\r\n            if(itemConfig.addToMatrix) {\r\n              result = itemConfig.matrixId;\r\n            } else {\r\n              result = -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if(count == 0) {\r\n          result = -1;\r\n        }\r\n        return result;\r\n      }\r\n      );\r\n    }\r\n  }\r\n  return { maximumId, nestedLayoutParentConnectorIds, nestedLayoutBottomConnectorIds, layouts, bundles };\r\n};\r\n\r\nFamilyMatrixesExtractor.prototype.getMatrixWidth = function (maximumColumnsInMatrix, len) {\r\n  return Math.min(maximumColumnsInMatrix, Math.ceil(Math.sqrt(len)));\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}