{"ast":null,"code":"import { Enabled, ShapeType, AdviserPlacementType, TextOrientationType, PlacementType, Colors } from '../enums';\n\n/**\r\n * @class FamItemConfig\r\n * @classdesc Item Configuration Object defines properties of individual node in the family chart hierarchy. See `items` collection property\r\n * of family control configuration object. \r\n * \r\n * @param {FamItemConfig} arg0 Item config properties\r\n * \r\n * @param {string} arg0 Item id\r\n * @param {string[]|undefined} arg1 Parents ids\r\n * @param {string} arg2 Title\r\n * @param {string} arg3 Description \r\n * @param {string} arg4 Image\r\n */\nexport default function FamItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\r\n   * Item id. It should be unique per chart.\r\n   * \r\n   * @type {string}\r\n   */\n  this.id = null;\n\n  /**\r\n   * Parents items ids. If this collection is empty then item considered as a root item.\r\n   * @type {string[]}\r\n   */\n  this.parents = [];\n\n  /**\r\n   * Relative item id. This property is used to control items mutual placement in order to keep consistent ordering within levels. Relative item is used \r\n   * for placing given item in diagram. We can place item on left or right side of relative item via setting placementType type property.\r\n   * In case when multiple items use the same relative item then their order can be customized with position property.\r\n   * \r\n   * If this property set to null, family layout algorithm will try to choose elements order via placing connected \r\n   * nodes as close to each other as possible.\r\n   * \r\n   * @group Order\r\n   * @type {string}\r\n   */\n  this.relativeItem = null;\n\n  /**\r\n   * Relative placement type defines Left ot Right side placement of the node relative to the `relativeItem`.\r\n   * \r\n   * @group Order\r\n   * @type {AdviserPlacementType}\r\n   */\n  this.placementType = AdviserPlacementType.Right;\n\n  /**\r\n   * Relative position defines order of elements placed relative to the same relative item on the same side.\r\n   * \r\n   * @group Order\r\n   * @type {number}\r\n   */\n  this.position = null;\n\n  /**\r\n   * Primary parents id. Set this property to place item close to the selected primary parent in `parents` collection.\r\n   * If property set to null or referenced parent does not exists then this property is ignored.\r\n   * \r\n   * @group Order\r\n   * @type {string}\r\n   */\n  this.primaryParent = null;\n\n  /**\r\n   * Title\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.title = null;\n\n  /**\r\n   * Description\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.description = null;\n\n  /**\r\n   * Image\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.image = null;\n\n  /**\r\n   * Context object\r\n   * \r\n   * @group Template\r\n   * @type {object}\r\n   */\n  this.context = null;\n\n  /**\r\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.itemTitleColor = Colors.RoyalBlue;\n\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for individual node.\r\n   * \r\n   * @group Template\r\n   * @type {ShapeType}\r\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\r\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\r\n   * It gives extra dimension for nodes visual grouping in the diagram.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\n  this.groupTitle = null;\n\n  /**\r\n   * The group title background color.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\n  this.groupTitleColor = Colors.RoyalBlue;\n\n  /**\r\n   * Matrix id defines grouping of multiple nodes into individual matrixes. By default all applicable nodes grouped into a single matrix.\r\n   * Use this property to split nodes into multiple matrixes.\r\n   * \r\n   * @type {string}\r\n   */\n  this.matrixId = null;\n\n  /**\r\n   * Add to matrix property allows node to be grouped with other nodes into matrix. It is true by default.\r\n   * \r\n   * @type {boolean}\r\n   */\n  this.addToMatrix = true;\n\n  /**\r\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\r\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\r\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\r\n   * indicating that upon reaching them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\n  this.isActive = true;\n\n  /**\r\n   * Shows selection check box for the node.\r\n   * If Auto then selection check box visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasSelectorCheckbox` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @type {Enabled}\r\n   */\n  this.hasSelectorCheckbox = Enabled.Auto;\n\n  /**\r\n   * Shows context buttons panel for the node.\r\n   * If Auto then context buttons panel visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasButtons` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @group Template\r\n   * @type {Enabled}\r\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\r\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * This option lets individually assign rendering template per individual node of the diagram.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\n  this.templateName = null;\n\n  /**\r\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\r\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\r\n   * current template of the node it is rendered for.\r\n   * \r\n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\r\n   * to change their template.\r\n   * \r\n   * Auto - depends on `showCallout` property of the control\r\n   * True - shown regardless of node's visibility\r\n   * False - hidden\r\n   * \r\n   * @group Callout\r\n   * @type {Enabled}\r\n   */\n  this.showCallout = Enabled.Auto;\n\n  /**\r\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\r\n   * per individual node of the diagram.\r\n   * \r\n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * \r\n   * @group Callout\r\n   * @type {string}\r\n   */\n  this.calloutTemplateName = null;\n\n  /**\r\n   * Marker label.\r\n   * \r\n   * @group Label\r\n   * @type {string}\r\n   */\n  this.label = null;\n\n  /**\r\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \r\n   * \r\n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\r\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\r\n   * \r\n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\r\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\r\n   * is going to stay visible.\r\n   * \r\n   * Auto - displays label only when it has space to be rendered.\r\n   * True - shows label regardless, even if it overlaps other labels and nodes.\r\n   * False - hidden.\r\n   * \r\n   * @group Label\r\n   * @type {Enabled}\r\n   */\n  this.showLabel = Enabled.Auto;\n\n  /**\r\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\r\n   * If `null` then it is set to `labelSize` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {Size}\r\n   */\n  this.labelSize = null;\n\n  /**\r\n   * Label orientation.\r\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {TextOrientationType}\r\n   */\n  this.labelOrientation = TextOrientationType.Auto;\n\n  /**\r\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\r\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {PlacementType}\r\n   */\n  this.labelPlacement = PlacementType.Auto;\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n      break;\n    case 5:\n      this.id = arg0;\n      this.parents = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n}\n;","map":{"version":3,"names":["Enabled","ShapeType","AdviserPlacementType","TextOrientationType","PlacementType","Colors","FamItemConfig","arg0","arg1","arg2","arg3","arg4","property","id","parents","relativeItem","placementType","Right","position","primaryParent","title","description","image","context","itemTitleColor","RoyalBlue","minimizedItemShapeType","groupTitle","groupTitleColor","matrixId","addToMatrix","isActive","hasSelectorCheckbox","Auto","hasButtons","templateName","showCallout","calloutTemplateName","label","showLabel","labelSize","labelOrientation","labelPlacement","arguments","length","hasOwnProperty"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/configs/FamItemConfig.js"],"sourcesContent":["import {Enabled, ShapeType, AdviserPlacementType, TextOrientationType, PlacementType, Colors } from '../enums';\r\n\r\n/**\r\n * @class FamItemConfig\r\n * @classdesc Item Configuration Object defines properties of individual node in the family chart hierarchy. See `items` collection property\r\n * of family control configuration object. \r\n * \r\n * @param {FamItemConfig} arg0 Item config properties\r\n * \r\n * @param {string} arg0 Item id\r\n * @param {string[]|undefined} arg1 Parents ids\r\n * @param {string} arg2 Title\r\n * @param {string} arg3 Description \r\n * @param {string} arg4 Image\r\n */\r\nexport default function FamItemConfig(arg0, arg1, arg2, arg3, arg4) {\r\n  var property;\r\n  /**\r\n   * Item id. It should be unique per chart.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.id = null;\r\n\r\n  /**\r\n   * Parents items ids. If this collection is empty then item considered as a root item.\r\n   * @type {string[]}\r\n   */\r\n  this.parents = [];\r\n\r\n  /**\r\n   * Relative item id. This property is used to control items mutual placement in order to keep consistent ordering within levels. Relative item is used \r\n   * for placing given item in diagram. We can place item on left or right side of relative item via setting placementType type property.\r\n   * In case when multiple items use the same relative item then their order can be customized with position property.\r\n   * \r\n   * If this property set to null, family layout algorithm will try to choose elements order via placing connected \r\n   * nodes as close to each other as possible.\r\n   * \r\n   * @group Order\r\n   * @type {string}\r\n   */\r\n  this.relativeItem = null;\r\n\r\n  /**\r\n   * Relative placement type defines Left ot Right side placement of the node relative to the `relativeItem`.\r\n   * \r\n   * @group Order\r\n   * @type {AdviserPlacementType}\r\n   */\r\n  this.placementType = AdviserPlacementType.Right;\r\n\r\n  /**\r\n   * Relative position defines order of elements placed relative to the same relative item on the same side.\r\n   * \r\n   * @group Order\r\n   * @type {number}\r\n   */\r\n  this.position = null;\r\n\r\n  /**\r\n   * Primary parents id. Set this property to place item close to the selected primary parent in `parents` collection.\r\n   * If property set to null or referenced parent does not exists then this property is ignored.\r\n   * \r\n   * @group Order\r\n   * @type {string}\r\n   */\r\n  this.primaryParent = null;\r\n\r\n  /**\r\n   * Title\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.title = null;\r\n\r\n  /**\r\n   * Description\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.description = null;\r\n\r\n  /**\r\n   * Image\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.image = null;\r\n\r\n  /**\r\n   * Context object\r\n   * \r\n   * @group Template\r\n   * @type {object}\r\n   */\r\n  this.context = null;\r\n\r\n  /**\r\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.itemTitleColor = Colors.RoyalBlue;\r\n\r\n  /**\r\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\r\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\r\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\r\n   * So this option sets marker shape for individual node.\r\n   * \r\n   * @group Template\r\n   * @type {ShapeType}\r\n   */\r\n  this.minimizedItemShapeType = null;\r\n\r\n  /**\r\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\r\n   * It gives extra dimension for nodes visual grouping in the diagram.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\r\n  this.groupTitle = null;\r\n\r\n  /**\r\n   * The group title background color.\r\n   * \r\n   * @group Group Title\r\n   * @type {string}\r\n   */\r\n  this.groupTitleColor = Colors.RoyalBlue;\r\n\r\n  /**\r\n   * Matrix id defines grouping of multiple nodes into individual matrixes. By default all applicable nodes grouped into a single matrix.\r\n   * Use this property to split nodes into multiple matrixes.\r\n   * \r\n   * @type {string}\r\n   */\r\n  this.matrixId = null;\r\n\r\n  /**\r\n   * Add to matrix property allows node to be grouped with other nodes into matrix. It is true by default.\r\n   * \r\n   * @type {boolean}\r\n   */\r\n  this.addToMatrix = true;\r\n\r\n  /**\r\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \r\n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\r\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\r\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\r\n   * indicating that upon reaching them diagram would load extra nodes into layout.\r\n   * \r\n   * @type {boolean}\r\n   */\r\n  this.isActive = true;\r\n\r\n  /**\r\n   * Shows selection check box for the node.\r\n   * If Auto then selection check box visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasSelectorCheckbox` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @type {Enabled}\r\n   */\r\n  this.hasSelectorCheckbox = Enabled.Auto;\r\n\r\n  /**\r\n   * Shows context buttons panel for the node.\r\n   * If Auto then context buttons panel visibility depends on control's configuration.\r\n   * \r\n   * Auto - depends on `hasButtons` property of the control\r\n   * True - shown\r\n   * False - hidden\r\n   * \r\n   * @group Template\r\n   * @type {Enabled}\r\n   */\r\n  this.hasButtons = Enabled.Auto;\r\n\r\n  /**\r\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * This option lets individually assign rendering template per individual node of the diagram.\r\n   * \r\n   * @group Template\r\n   * @type {string}\r\n   */\r\n  this.templateName = null;\r\n\r\n  /**\r\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\r\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\r\n   * current template of the node it is rendered for.\r\n   * \r\n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\r\n   * to change their template.\r\n   * \r\n   * Auto - depends on `showCallout` property of the control\r\n   * True - shown regardless of node's visibility\r\n   * False - hidden\r\n   * \r\n   * @group Callout\r\n   * @type {Enabled}\r\n   */\r\n  this.showCallout = Enabled.Auto;\r\n\r\n  /**\r\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\r\n   * per individual node of the diagram.\r\n   * \r\n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\r\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\r\n   * \r\n   * @group Callout\r\n   * @type {string}\r\n   */\r\n  this.calloutTemplateName = null;\r\n\r\n  /**\r\n   * Marker label.\r\n   * \r\n   * @group Label\r\n   * @type {string}\r\n   */\r\n  this.label = null;\r\n\r\n  /**\r\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \r\n   * \r\n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\r\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\r\n   * \r\n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\r\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\r\n   * is going to stay visible.\r\n   * \r\n   * Auto - displays label only when it has space to be rendered.\r\n   * True - shows label regardless, even if it overlaps other labels and nodes.\r\n   * False - hidden.\r\n   * \r\n   * @group Label\r\n   * @type {Enabled}\r\n   */\r\n  this.showLabel = Enabled.Auto;\r\n\r\n  /**\r\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\r\n   * If `null` then it is set to `labelSize` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {Size}\r\n   */\r\n  this.labelSize = null;\r\n\r\n  /**\r\n   * Label orientation.\r\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {TextOrientationType}\r\n   */\r\n  this.labelOrientation = TextOrientationType.Auto;\r\n\r\n  /**\r\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\r\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\r\n   * \r\n   * @group Label\r\n   * @type {PlacementType}\r\n   */\r\n  this.labelPlacement = PlacementType.Auto;\r\n\r\n  switch (arguments.length) {\r\n    case 1:\r\n      for (property in arg0) {\r\n        if (arg0.hasOwnProperty(property)) {\r\n          this[property] = arg0[property];\r\n        }\r\n      }\r\n      break;\r\n    case 5:\r\n      this.id = arg0;\r\n      this.parents = arg1;\r\n      this.title = arg2;\r\n      this.description = arg3;\r\n      this.image = arg4;\r\n      break;\r\n  }\r\n};\r\n"],"mappings":"AAAA,SAAQA,OAAO,EAAEC,SAAS,EAAEC,oBAAoB,EAAEC,mBAAmB,EAAEC,aAAa,EAAEC,MAAM,QAAQ,UAAU;;AAE9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAClE,IAAIC,QAAQ;EACZ;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,EAAE,GAAG,IAAI;;EAEd;AACF;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG,EAAE;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,IAAI;;EAExB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,aAAa,GAAGd,oBAAoB,CAACe,KAAK;;EAE/C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,aAAa,GAAG,IAAI;;EAEzB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI;;EAEvB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG,IAAI;;EAEnB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGnB,MAAM,CAACoB,SAAS;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAG,IAAI;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;;EAEtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGvB,MAAM,CAACoB,SAAS;;EAEvC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI;;EAEvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGhC,OAAO,CAACiC,IAAI;;EAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGlC,OAAO,CAACiC,IAAI;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACE,YAAY,GAAG,IAAI;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAGpC,OAAO,CAACiC,IAAI;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,mBAAmB,GAAG,IAAI;;EAE/B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,SAAS,GAAGvC,OAAO,CAACiC,IAAI;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACO,SAAS,GAAG,IAAI;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAGtC,mBAAmB,CAAC8B,IAAI;;EAEhD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACS,cAAc,GAAGtC,aAAa,CAAC6B,IAAI;EAExC,QAAQU,SAAS,CAACC,MAAM;IACtB,KAAK,CAAC;MACJ,KAAKhC,QAAQ,IAAIL,IAAI,EAAE;QACrB,IAAIA,IAAI,CAACsC,cAAc,CAACjC,QAAQ,CAAC,EAAE;UACjC,IAAI,CAACA,QAAQ,CAAC,GAAGL,IAAI,CAACK,QAAQ,CAAC;QACjC;MACF;MACA;IACF,KAAK,CAAC;MACJ,IAAI,CAACC,EAAE,GAAGN,IAAI;MACd,IAAI,CAACO,OAAO,GAAGN,IAAI;MACnB,IAAI,CAACY,KAAK,GAAGX,IAAI;MACjB,IAAI,CAACY,WAAW,GAAGX,IAAI;MACvB,IAAI,CAACY,KAAK,GAAGX,IAAI;MACjB;EACJ;AACF;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}