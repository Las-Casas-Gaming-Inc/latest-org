{"ast":null,"code":"import PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport PaletteItem from '../../graphics/structs/PaletteItem';\nimport { Layers, ZOrderType } from '../../enums';\nexport default function DrawHighlightPathAnnotationTask(getGraphics, connectorsOptionTask, highlightPathAnnotationOptionTask, connectionsGraphTask, zOrderType) {\n  function process() {\n    var graph = connectionsGraphTask.getGraph(),\n      highlightOptions = connectorsOptionTask.getOptions(),\n      annotations = highlightPathAnnotationOptionTask.getAnnotations(),\n      graphics = getGraphics();\n    switch (zOrderType) {\n      case ZOrderType.Background:\n        //ignore jslint\n        graphics.reset(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n        break;\n      case ZOrderType.Foreground:\n        //ignore jslint\n        graphics.reset(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n        break;\n    }\n    drawAnnotations(graphics, highlightOptions, annotations, graph);\n    return false;\n  }\n  function drawAnnotations(graphics, highlightOptions, annotations, graph) {\n    var index, len, index2, len2, index3, len3, firstItemId, nextItemId, treeItem, path, items, connectorEdge, annotationConfig, panel, buffer, from, to;\n    if (annotations.length > 0) {\n      buffer = new PolylinesBuffer();\n      switch (zOrderType) {\n        case ZOrderType.Background:\n          //ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n          break;\n        case ZOrderType.Foreground:\n          //ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n          break;\n      }\n\n      /* group path segments by from node */\n      var pairs = {};\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n              if (graph.hasNode(nextItemId)) {\n                if (pairs.hasOwnProperty(firstItemId)) {\n                  pairs[firstItemId].push(nextItemId);\n                } else {\n                  pairs[firstItemId] = [nextItemId];\n                }\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n\n      /* get shortest paths */\n      var paths = {};\n      for (from in pairs) {\n        paths[from] = {};\n        if (pairs.hasOwnProperty(from)) {\n          graph.getShortestPath(this, from, pairs[from], function (connectorEdge, fromItem, toItem) {\n            return connectorEdge.weight;\n          }, function (path2, to2) {\n            paths[from][to2] = path2;\n          }); //ignore jslint\n        }\n      }\n\n      /* trace annotations */\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n        var paletteItem = new PaletteItem({\n          lineColor: annotationConfig.color != null ? annotationConfig.color : highlightOptions.highlightLinesColor,\n          lineWidth: annotationConfig.lineWidth != null ? annotationConfig.lineWidth : highlightOptions.highlightLinesWidth,\n          lineType: annotationConfig.lineType != null ? annotationConfig.lineType : highlightOptions.highlightLinesType,\n          fillColor: null,\n          opacity: annotationConfig.opacity\n        });\n        var polyline = buffer.getPolyline(paletteItem);\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n              if (graph.hasNode(nextItemId)) {\n                path = paths[firstItemId][nextItemId] || [];\n                for (index3 = path.length - 2; index3 >= 0; index3 -= 1) {\n                  from = path[index3 + 1];\n                  to = path[index3];\n                  connectorEdge = graph.edge(from, to);\n                  if (connectorEdge.from == from) {\n                    connectorEdge.polyline.clone().mergeTo(polyline);\n                  } else {\n                    polyline.addInverted(connectorEdge.polyline.clone());\n                  }\n                  if (annotationConfig.showArrows) {\n                    if (to == connectorEdge.parentsArrowId || to == connectorEdge.childrenArrowId) {\n                      polyline.addArrow(annotationConfig.lineWidth, function (arrowPolyline) {\n                        arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n                      }); //ignore jslint\n                    }\n                  }\n                }\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n      graphics.polylinesBuffer(buffer);\n    }\n  }\n  return {\n    process: process\n  };\n}\n;","map":{"version":3,"names":["PolylinesBuffer","PaletteItem","Layers","ZOrderType","DrawHighlightPathAnnotationTask","getGraphics","connectorsOptionTask","highlightPathAnnotationOptionTask","connectionsGraphTask","zOrderType","process","graph","getGraph","highlightOptions","getOptions","annotations","getAnnotations","graphics","Background","reset","BackgroundHighlightPathAnnotations","Foreground","ForegroundHighlightPathAnnotations","drawAnnotations","index","len","index2","len2","index3","len3","firstItemId","nextItemId","treeItem","path","items","connectorEdge","annotationConfig","panel","buffer","from","to","length","activate","pairs","slice","hasNode","hasOwnProperty","push","paths","getShortestPath","fromItem","toItem","weight","path2","to2","paletteItem","lineColor","color","highlightLinesColor","lineWidth","highlightLinesWidth","lineType","highlightLinesType","fillColor","opacity","polyline","getPolyline","edge","clone","mergeTo","addInverted","showArrows","parentsArrowId","childrenArrowId","addArrow","arrowPolyline","polylinesBuffer"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/tasks/renders/DrawHighlightPathAnnotationTask.js"],"sourcesContent":["import PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\r\nimport PaletteItem from '../../graphics/structs/PaletteItem';\r\nimport { Layers, ZOrderType } from '../../enums';\r\n\r\nexport default function DrawHighlightPathAnnotationTask(getGraphics, connectorsOptionTask, highlightPathAnnotationOptionTask, connectionsGraphTask, zOrderType) {\r\n  function process() {\r\n    var graph = connectionsGraphTask.getGraph(),\r\n      highlightOptions = connectorsOptionTask.getOptions(),\r\n      annotations = highlightPathAnnotationOptionTask.getAnnotations(),\r\n      graphics = getGraphics();\r\n\r\n    switch (zOrderType) {\r\n      case ZOrderType.Background://ignore jslint\r\n        graphics.reset(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\r\n        break;\r\n      case ZOrderType.Foreground://ignore jslint\r\n        graphics.reset(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\r\n        break;\r\n    }\r\n\r\n    drawAnnotations(graphics, highlightOptions, annotations, graph);\r\n\r\n    return false;\r\n  }\r\n\r\n  function drawAnnotations(graphics, highlightOptions, annotations, graph) {\r\n    var index, len,\r\n      index2, len2,\r\n      index3, len3,\r\n      firstItemId, nextItemId,\r\n      treeItem,\r\n      path,\r\n      items,\r\n      connectorEdge,\r\n      annotationConfig,\r\n      panel, buffer,\r\n      from, to;\r\n\r\n    if (annotations.length > 0) {\r\n      buffer = new PolylinesBuffer();\r\n\r\n      switch (zOrderType) {\r\n        case ZOrderType.Background://ignore jslint\r\n          panel = graphics.activate(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\r\n          break;\r\n        case ZOrderType.Foreground://ignore jslint\r\n          panel = graphics.activate(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\r\n          break;\r\n      }\r\n\r\n      /* group path segments by from node */\r\n      var pairs = {};\r\n      for (index = 0, len = annotations.length; index < len; index += 1) {\r\n        annotationConfig = annotations[index];\r\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\r\n          items = annotationConfig.items.slice(0);\r\n          firstItemId = items[0];\r\n          if (graph.hasNode(firstItemId)) {\r\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\r\n              nextItemId = items[index2];\r\n              if (graph.hasNode(nextItemId)) {\r\n                if (pairs.hasOwnProperty(firstItemId)) {\r\n                  pairs[firstItemId].push(nextItemId);\r\n                } else {\r\n                  pairs[firstItemId] = [nextItemId];\r\n                }\r\n                firstItemId = nextItemId;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /* get shortest paths */\r\n      var paths = {};\r\n      for (from in pairs) {\r\n        paths[from] = {};\r\n        if (pairs.hasOwnProperty(from)) {\r\n          graph.getShortestPath(this, from, pairs[from], function (connectorEdge, fromItem, toItem) {\r\n            return connectorEdge.weight;\r\n          }, function (path2, to2) {\r\n            paths[from][to2] = path2;\r\n          }); //ignore jslint\r\n        }\r\n      }\r\n\r\n      /* trace annotations */\r\n      for (index = 0, len = annotations.length; index < len; index += 1) {\r\n        annotationConfig = annotations[index];\r\n\r\n        var paletteItem = new PaletteItem({\r\n          lineColor: (annotationConfig.color != null ? annotationConfig.color : highlightOptions.highlightLinesColor),\r\n          lineWidth: (annotationConfig.lineWidth != null ? annotationConfig.lineWidth : highlightOptions.highlightLinesWidth),\r\n          lineType: (annotationConfig.lineType != null ? annotationConfig.lineType : highlightOptions.highlightLinesType),\r\n          fillColor: null,\r\n          opacity: annotationConfig.opacity\r\n        });\r\n        var polyline = buffer.getPolyline(paletteItem);\r\n\r\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\r\n          items = annotationConfig.items.slice(0);\r\n          firstItemId = items[0];\r\n\r\n          if (graph.hasNode(firstItemId)) {\r\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\r\n              nextItemId = items[index2];\r\n              if (graph.hasNode(nextItemId)) {\r\n                path = paths[firstItemId][nextItemId] || [];\r\n                for (index3 = path.length - 2; index3 >= 0; index3 -= 1) {\r\n                  from = path[index3 + 1];\r\n                  to = path[index3];\r\n                  connectorEdge = graph.edge(from, to);\r\n                  if (connectorEdge.from == from) {\r\n                    connectorEdge.polyline.clone().mergeTo(polyline);\r\n                  } else {\r\n                    polyline.addInverted(connectorEdge.polyline.clone());\r\n                  }\r\n                  if (annotationConfig.showArrows) {\r\n                    if (to == connectorEdge.parentsArrowId || to == connectorEdge.childrenArrowId) {\r\n                      polyline.addArrow(annotationConfig.lineWidth, function (arrowPolyline) {\r\n                        arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\r\n                      }); //ignore jslint\r\n                    }\r\n                  }\r\n                }\r\n\r\n                firstItemId = nextItemId;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      graphics.polylinesBuffer(buffer);\r\n    }\r\n  }\r\n\r\n  return {\r\n    process: process\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}