{"ast":null,"code":"import Point from '../graphics/structs/Point';\nimport Vector from '../graphics/structs/Vector';\nimport LinkedHashItems from './LinkedHashItems';\n/**\r\n * Callback function to iterate over result shapes\r\n * \r\n * @callback onMergedRectangleItemCallback\r\n * @param {Point[]} points Collection of points tracing margin around result area formed via merge of rectangles.\r\n * The outer shape margin has clock wise sequence of data points. Internal holes inside of the shape are formed by counter clock wise \r\n * sequence of data points.\r\n */\n\n/**\r\n * Merges collection of rectangles into shapes. Calls callback function to pass result sequences of data points.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Rect[]} items Collection of rectangles.\r\n * @param {onMergedRectangleItemCallback} onItem Callback function to pass result sequences of margin data points.\r\n */\nexport default function getMergedRectangles(thisArg, items, onItem) {\n  var index, len, index2, len2, point;\n  items.sort(function (a, b) {\n    if (a.x == b.x) {\n      return a.y - b.y;\n    }\n    return a.x - b.x;\n  });\n  var points = [];\n  var pointsHash = {};\n  for (index = 0, len = items.length; index < len; index += 1) {\n    var item = items[index];\n    var xs = [item.x, item.right()];\n    for (var k = 0; k < xs.length; k += 1) {\n      var x = xs[k];\n      point = pointsHash[x];\n      if (point == null) {\n        point = {\n          x: x,\n          add: [],\n          remove: []\n        };\n        pointsHash[x] = point;\n        points.push(point);\n      }\n      if (x == item.x) {\n        point.add.push(index);\n      } else {\n        point.remove.push(index);\n      }\n    }\n  }\n  points.sort(function (a, b) {\n    return a.x - b.x;\n  });\n  function Range(start, end) {\n    this.start = start;\n    this.startHead = null;\n    this.end = end;\n    this.endHead = null;\n    this.overlap = function (range) {\n      return !(this.end < range.start || this.start > range.end);\n    };\n  }\n  function Stripe(x, ranges) {\n    this.x = x;\n    this.ranges = ranges;\n  }\n  var active = {};\n  var stripes = [];\n  stripes.push(new Stripe(null, []));\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n    for (index2 = 0, len2 = point.add.length; index2 < len2; index2 += 1) {\n      active[point.add[index2]] = true;\n    }\n    for (index2 = 0, len2 = point.remove.length; index2 < len2; index2 += 1) {\n      delete active[point.remove[index2]];\n    }\n    var activeRects = [];\n    for (var key in active) {\n      if (active.hasOwnProperty(key)) {\n        activeRects.push(items[key]);\n      }\n    }\n    activeRects.sort(function (a, b) {\n      return a.y - b.y;\n    });\n    var ranges = [];\n    var start = null;\n    var end = null;\n    for (index2 = 0, len2 = activeRects.length; index2 < len2; index2 += 1) {\n      var activeRect = activeRects[index2];\n      if (start == null) {\n        start = activeRect.y;\n        end = activeRect.bottom();\n      } else {\n        if (end < activeRect.y) {\n          ranges.push(new Range(start, end));\n          start = activeRect.y;\n          end = activeRect.bottom();\n        } else {\n          end = Math.max(end, activeRect.bottom());\n        }\n      }\n    }\n    if (start != null) {\n      ranges.push(new Range(start, end));\n    }\n    stripes.push(new Stripe(point.x, ranges));\n  }\n  var lists = [];\n  var heads = {};\n  var counter = 1;\n  function Head(isHead, list) {\n    this.isHead = isHead;\n    this.list = list;\n    if (!heads.hasOwnProperty(list)) {\n      heads[list] = [];\n    }\n    heads[list].push(this);\n    this.add = function (segment) {\n      if (!segment.from.equalTo(segment.to)) {\n        if (this.isHead) {\n          lists[this.list].add(counter, segment);\n          counter += 1;\n        } else {\n          lists[this.list].unshift(counter, segment);\n          counter += 1;\n        }\n      }\n    };\n    this.getTail = function () {\n      return new Head(!this.isHead, this.list);\n    };\n    this.attach = function (head) {\n      if (this.list != head.list) {\n        lists[this.list].attach(lists[head.list]);\n        var refs = heads[head.list];\n        delete heads[head.list];\n        if (refs != null) {\n          for (var index = 0, len = refs.length; index < len; index += 1) {\n            var ref = refs[index];\n            if (ref != head) {\n              ref.list = this.list;\n              heads[this.list].push(ref);\n            }\n          }\n        }\n      }\n    };\n  }\n  function createHead(isHead) {\n    lists.push(new LinkedHashItems());\n    return new Head(isHead, lists.length - 1);\n  }\n  for (index = 1, len = stripes.length; index < len; index += 1) {\n    var prev = stripes[index - 1];\n    var curr = stripes[index];\n    var pi = 0,\n      ci = 0;\n    while (pi < prev.ranges.length || ci < curr.ranges.length) {\n      var pr = pi < prev.ranges.length ? prev.ranges[pi] : null;\n      var cr = ci < curr.ranges.length ? curr.ranges[ci] : null;\n      if (cr == null) {\n        // close pr\n        points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, pr.start), new Point(prev.x, pr.start)];\n        for (var pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n        pr.endHead.attach(pr.startHead);\n        pi += 1;\n        continue;\n      }\n      if (pr == null) {\n        // open cr\n        cr.endHead = createHead(true);\n        cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n        cr.startHead = cr.endHead.getTail();\n        ci += 1;\n        continue;\n      }\n      if (!cr.overlap(pr)) {\n        if (pr.start < cr.start) {\n          // close pr\n          points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, pr.start), new Point(prev.x, pr.start)];\n          for (pindex = 1; pindex < points.length; pindex += 1) {\n            pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n          }\n          pr.endHead.attach(pr.startHead);\n          pi += 1;\n          continue;\n        } else {\n          // open cr\n          cr.endHead = createHead(true);\n          cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n          cr.startHead = cr.endHead.getTail();\n          ci += 1;\n          continue;\n        }\n      } else {\n        // ovelaps\n        // extend pr.start to cr.start\n        points = [new Point(prev.x, pr.start), new Point(curr.x, pr.start), new Point(curr.x, cr.start)];\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.startHead.add(new Vector(points[pindex], points[pindex - 1]));\n        }\n        cr.startHead = pr.startHead;\n        var loop = true;\n        while (loop) {\n          loop = false;\n          if (pr.end > cr.end) {\n            var nextcr = ci + 1 < curr.ranges.length ? curr.ranges[ci + 1] : null;\n            if (nextcr != null && nextcr.overlap(pr)) {\n              // open loop cr.end to nextcr.start\n              var p1 = new Point(curr.x, nextcr.start);\n              var p2 = new Point(curr.x, cr.end);\n              cr.endHead = createHead(true);\n              cr.endHead.add(new Vector(p1, p2));\n              nextcr.startHead = cr.endHead.getTail();\n              ci += 1;\n              cr = nextcr;\n              loop = true;\n            }\n          } else {\n            var nextpr = pi + 1 < prev.ranges.length ? prev.ranges[pi + 1] : null;\n            if (nextpr != null && nextpr.overlap(cr)) {\n              // close loop pr.end to nextpr.start\n              points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, nextpr.start), new Point(prev.x, nextpr.start)];\n              for (pindex = 1; pindex < points.length; pindex += 1) {\n                pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n              }\n              pr.endHead.attach(nextpr.startHead);\n              pi += 1;\n              pr = nextpr;\n              loop = true;\n            }\n          }\n        }\n        // extend pr.end to cr.end\n        points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, cr.end)];\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n        cr.endHead = pr.endHead;\n        pi += 1;\n        ci += 1;\n      }\n    }\n  }\n  if (onItem != null) {\n    for (index = 0; index < lists.length; index += 1) {\n      if (heads.hasOwnProperty(index)) {\n        var list = lists[index];\n        points = [];\n        list.iterate(function (segment, key) {\n          if (points.length == 0) {\n            points.push(segment.from);\n            points.push(segment.to);\n          } else {\n            points.push(segment.to);\n          }\n        });\n        onItem.call(thisArg, points);\n      }\n    }\n  }\n}\n;","map":{"version":3,"names":["Point","Vector","LinkedHashItems","getMergedRectangles","thisArg","items","onItem","index","len","index2","len2","point","sort","a","b","x","y","points","pointsHash","length","item","xs","right","k","add","remove","push","Range","start","end","startHead","endHead","overlap","range","Stripe","ranges","active","stripes","activeRects","key","hasOwnProperty","activeRect","bottom","Math","max","lists","heads","counter","Head","isHead","list","segment","from","equalTo","to","unshift","getTail","attach","head","refs","ref","createHead","prev","curr","pi","ci","pr","cr","pindex","loop","nextcr","p1","p2","nextpr","iterate","call"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/algorithms/getMergedRectangles.js"],"sourcesContent":["import Point from '../graphics/structs/Point';\r\nimport Vector from '../graphics/structs/Vector';\r\nimport LinkedHashItems from './LinkedHashItems';\r\n/**\r\n * Callback function to iterate over result shapes\r\n * \r\n * @callback onMergedRectangleItemCallback\r\n * @param {Point[]} points Collection of points tracing margin around result area formed via merge of rectangles.\r\n * The outer shape margin has clock wise sequence of data points. Internal holes inside of the shape are formed by counter clock wise \r\n * sequence of data points.\r\n */\r\n\r\n/**\r\n * Merges collection of rectangles into shapes. Calls callback function to pass result sequences of data points.\r\n * \r\n * @param {Object} thisArg The callback function invocation context\r\n * @param {Rect[]} items Collection of rectangles.\r\n * @param {onMergedRectangleItemCallback} onItem Callback function to pass result sequences of margin data points.\r\n */\r\nexport default function getMergedRectangles(thisArg, items, onItem) {\r\n  var index, len,\r\n    index2, len2,\r\n    point;\r\n\r\n  items.sort(function (a, b) {\r\n    if (a.x == b.x) {\r\n      return a.y - b.y;\r\n    }\r\n    return a.x - b.x;\r\n  });\r\n\r\n  var points = [];\r\n  var pointsHash = {};\r\n\r\n  for (index = 0, len = items.length; index < len; index += 1) {\r\n    var item = items[index];\r\n    var xs = [item.x, item.right()];\r\n    for (var k = 0; k < xs.length; k += 1) {\r\n      var x = xs[k];\r\n      point = pointsHash[x];\r\n      if (point == null) {\r\n        point = {\r\n          x: x,\r\n          add: [],\r\n          remove: []\r\n        };\r\n        pointsHash[x] = point;\r\n        points.push(point);\r\n      }\r\n      if (x == item.x) {\r\n        point.add.push(index);\r\n      } else {\r\n        point.remove.push(index);\r\n      }\r\n    }\r\n  }\r\n\r\n  points.sort(function (a, b) {\r\n    return a.x - b.x;\r\n  });\r\n\r\n  function Range(start, end) {\r\n    this.start = start;\r\n    this.startHead = null;\r\n\r\n    this.end = end;\r\n    this.endHead = null;\r\n\r\n    this.overlap = function (range) {\r\n      return !(this.end < range.start || this.start > range.end);\r\n    };\r\n  }\r\n\r\n  function Stripe(x, ranges) {\r\n    this.x = x;\r\n    this.ranges = ranges;\r\n  }\r\n\r\n  var active = {};\r\n  var stripes = [];\r\n  stripes.push(new Stripe(null, []));\r\n\r\n  for (index = 0, len = points.length; index < len; index += 1) {\r\n    point = points[index];\r\n\r\n    for (index2 = 0, len2 = point.add.length; index2 < len2; index2 += 1) {\r\n      active[point.add[index2]] = true;\r\n    }\r\n    for (index2 = 0, len2 = point.remove.length; index2 < len2; index2 += 1) {\r\n      delete active[point.remove[index2]];\r\n    }\r\n\r\n    var activeRects = [];\r\n    for (var key in active) {\r\n      if (active.hasOwnProperty(key)) {\r\n        activeRects.push(items[key]);\r\n      }\r\n    }\r\n\r\n    activeRects.sort(function (a, b) {\r\n      return a.y - b.y;\r\n    });\r\n\r\n    var ranges = [];\r\n\r\n    var start = null;\r\n    var end = null;\r\n\r\n    for (index2 = 0, len2 = activeRects.length; index2 < len2; index2 += 1) {\r\n      var activeRect = activeRects[index2];\r\n\r\n      if (start == null) {\r\n        start = activeRect.y;\r\n        end = activeRect.bottom();\r\n      } else {\r\n        if (end < activeRect.y) {\r\n          ranges.push(new Range(start, end));\r\n          start = activeRect.y;\r\n          end = activeRect.bottom();\r\n        } else {\r\n          end = Math.max(end, activeRect.bottom());\r\n        }\r\n      }\r\n    }\r\n    if (start != null) {\r\n      ranges.push(new Range(start, end));\r\n    }\r\n\r\n    stripes.push(new Stripe(point.x, ranges));\r\n  }\r\n\r\n  var lists = [];\r\n  var heads = {};\r\n  var counter = 1;\r\n\r\n  function Head(isHead, list) {\r\n    this.isHead = isHead;\r\n    this.list = list;\r\n\r\n    if (!heads.hasOwnProperty(list)) {\r\n      heads[list] = [];\r\n    }\r\n    heads[list].push(this);\r\n\r\n    this.add = function (segment) {\r\n      if (!segment.from.equalTo(segment.to)) {\r\n        if (this.isHead) {\r\n          lists[this.list].add(counter, segment);\r\n          counter += 1;\r\n        } else {\r\n          lists[this.list].unshift(counter, segment);\r\n          counter += 1;\r\n        }\r\n      }\r\n    };\r\n\r\n    this.getTail = function () {\r\n      return new Head(!this.isHead, this.list);\r\n    };\r\n\r\n    this.attach = function (head) {\r\n      if (this.list != head.list) {\r\n        lists[this.list].attach(lists[head.list]);\r\n\r\n        var refs = heads[head.list];\r\n        delete heads[head.list];\r\n        if (refs != null) {\r\n          for (var index = 0, len = refs.length; index < len; index += 1) {\r\n            var ref = refs[index];\r\n            if (ref != head) {\r\n              ref.list = this.list;\r\n              heads[this.list].push(ref);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  function createHead(isHead) {\r\n    lists.push(new LinkedHashItems());\r\n    return new Head(isHead, lists.length - 1);\r\n  }\r\n\r\n  for (index = 1, len = stripes.length; index < len; index += 1) {\r\n    var prev = stripes[index - 1];\r\n    var curr = stripes[index];\r\n\r\n    var pi = 0, ci = 0;\r\n    while (pi < prev.ranges.length || ci < curr.ranges.length) {\r\n      var pr = pi < prev.ranges.length ? prev.ranges[pi] : null;\r\n      var cr = ci < curr.ranges.length ? curr.ranges[ci] : null;\r\n\r\n      if (cr == null) {\r\n        // close pr\r\n        points = [\r\n          new Point(prev.x, pr.end),\r\n          new Point(curr.x, pr.end),\r\n          new Point(curr.x, pr.start),\r\n          new Point(prev.x, pr.start)\r\n        ];\r\n        for (var pindex = 1; pindex < points.length; pindex += 1) {\r\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\r\n        }\r\n        pr.endHead.attach(pr.startHead);\r\n        pi += 1;\r\n        continue;\r\n      }\r\n\r\n      if (pr == null) {\r\n        // open cr\r\n        cr.endHead = createHead(true);\r\n        cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\r\n        cr.startHead = cr.endHead.getTail();\r\n        ci += 1;\r\n        continue;\r\n      }\r\n\r\n      if (!cr.overlap(pr)) {\r\n        if (pr.start < cr.start) {\r\n          // close pr\r\n          points = [\r\n            new Point(prev.x, pr.end),\r\n            new Point(curr.x, pr.end),\r\n            new Point(curr.x, pr.start),\r\n            new Point(prev.x, pr.start)\r\n          ];\r\n          for (pindex = 1; pindex < points.length; pindex += 1) {\r\n            pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\r\n          }\r\n          pr.endHead.attach(pr.startHead);\r\n          pi += 1;\r\n          continue;\r\n        } else {\r\n          // open cr\r\n          cr.endHead = createHead(true);\r\n          cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\r\n          cr.startHead = cr.endHead.getTail();\r\n          ci += 1;\r\n          continue;\r\n        }\r\n      } else {\r\n        // ovelaps\r\n        // extend pr.start to cr.start\r\n        points = [\r\n          new Point(prev.x, pr.start),\r\n          new Point(curr.x, pr.start),\r\n          new Point(curr.x, cr.start)\r\n        ];\r\n        for (pindex = 1; pindex < points.length; pindex += 1) {\r\n          pr.startHead.add(new Vector(points[pindex], points[pindex - 1]));\r\n        }\r\n        cr.startHead = pr.startHead;\r\n\r\n        var loop = true;\r\n        while (loop) {\r\n          loop = false;\r\n\r\n          if (pr.end > cr.end) {\r\n            var nextcr = (ci + 1) < curr.ranges.length ? curr.ranges[ci + 1] : null;\r\n            if (nextcr != null && nextcr.overlap(pr)) {\r\n              // open loop cr.end to nextcr.start\r\n              var p1 = new Point(curr.x, nextcr.start);\r\n              var p2 = new Point(curr.x, cr.end);\r\n              cr.endHead = createHead(true);\r\n              cr.endHead.add(new Vector(p1, p2));\r\n              nextcr.startHead = cr.endHead.getTail();\r\n\r\n              ci += 1;\r\n              cr = nextcr;\r\n              loop = true;\r\n            }\r\n          } else {\r\n            var nextpr = (pi + 1) < prev.ranges.length ? prev.ranges[pi + 1] : null;\r\n            if (nextpr != null && nextpr.overlap(cr)) {\r\n              // close loop pr.end to nextpr.start\r\n              points = [\r\n                new Point(prev.x, pr.end),\r\n                new Point(curr.x, pr.end),\r\n                new Point(curr.x, nextpr.start),\r\n                new Point(prev.x, nextpr.start)\r\n              ];\r\n              for (pindex = 1; pindex < points.length; pindex += 1) {\r\n                pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\r\n              }\r\n              pr.endHead.attach(nextpr.startHead);\r\n              pi += 1;\r\n              pr = nextpr;\r\n              loop = true;\r\n            }\r\n          }\r\n        }\r\n        // extend pr.end to cr.end\r\n        points = [\r\n          new Point(prev.x, pr.end),\r\n          new Point(curr.x, pr.end),\r\n          new Point(curr.x, cr.end)\r\n        ];\r\n        for (pindex = 1; pindex < points.length; pindex += 1) {\r\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\r\n        }\r\n        cr.endHead = pr.endHead;\r\n        pi += 1;\r\n        ci += 1;\r\n      }\r\n    }\r\n  }\r\n  if (onItem != null) {\r\n    for (index = 0; index < lists.length; index += 1) {\r\n      if (heads.hasOwnProperty(index)) {\r\n        var list = lists[index];\r\n        points = [];\r\n        list.iterate(function (segment, key) {\r\n          if (points.length == 0) {\r\n            points.push(segment.from);\r\n            points.push(segment.to);\r\n          } else {\r\n            points.push(segment.to);\r\n          }\r\n        });\r\n        onItem.call(thisArg, points);\r\n      }\r\n    }\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}