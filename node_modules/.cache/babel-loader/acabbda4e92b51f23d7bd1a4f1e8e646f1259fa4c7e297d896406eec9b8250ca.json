{"ast":null,"code":"import BaseConnectorBundle from './BaseConnectorBundle';\nimport { ConnectorType, Visibility } from '../enums';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nexport default function VerticalConnectorBundle(fromItems, toItems, dotId) {\n  this.fromItems = fromItems;\n  this.toItems = toItems;\n  this.dotId = dotId || null;\n  this.fromOffset = 0;\n  this.fromStackSize = 0;\n}\n;\nVerticalConnectorBundle.prototype = new BaseConnectorBundle();\nVerticalConnectorBundle.prototype.trace = function (data, params, options) {\n  var parents,\n    children,\n    items,\n    treeItemId,\n    treeItemPosition,\n    index,\n    len,\n    isSquared,\n    hasSquared,\n    parentHorizontalCenter,\n    parentsConnectorOffset,\n    childrenConnectorOffset,\n    connectorPoint,\n    connectorStep,\n    chartHasSquaredConnectors = options.connectorType === ConnectorType.Squared;\n\n  /* Draw fork for parents */\n  parents = [];\n  if (this.fromItems.length > 0) {\n    items = this.fromItems;\n    for (index = 0, len = items.length; index < len; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n      connectorPoint = new this.ConnectorDestination({\n        id: params.nestedLayoutBottomConnectorIds.hasOwnProperty(treeItemId) ? params.nestedLayoutBottomConnectorIds[treeItemId] : treeItemId,\n        bundleid: this.getId(data),\n        x: treeItemPosition.actualPosition.horizontalCenter(),\n        y: treeItemPosition.actualPosition.bottom(),\n        isSquared: true,\n        visibility: treeItemPosition.actualVisibility\n      });\n      parents.push(connectorPoint);\n    }\n    parents.sort(function (a, b) {\n      return a.x - b.x;\n    });\n\n    /* Find offset of horizontal connector line between parents */\n    parentsConnectorOffset = treeItemPosition.bottomConnectorShift - treeItemPosition.bottomConnectorInterval * (this.fromStackSize - this.fromOffset + 1);\n  }\n  children = [];\n  if (this.toItems.length > 0) {\n    hasSquared = false;\n    items = this.toItems;\n    for (index = 0; index < items.length; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n      isSquared = true;\n      switch (treeItemPosition.actualVisibility) {\n        case Visibility.Dot:\n        case Visibility.Line:\n          isSquared = chartHasSquaredConnectors;\n          break;\n      }\n      connectorStep = 0;\n      connectorPoint = new this.ConnectorDestination({\n        id: treeItemId,\n        bundleid: this.getId(data),\n        x: treeItemPosition.actualPosition.horizontalCenter() + connectorStep,\n        y: treeItemPosition.actualPosition.top(),\n        isSquared: isSquared,\n        visibility: treeItemPosition.actualVisibility\n      });\n      children.push(connectorPoint);\n\n      /* is true if any child point has squared connector */\n      hasSquared = hasSquared || connectorPoint.isSquared;\n    }\n    children.sort(function (a, b) {\n      return a.x - b.x;\n    });\n\n    /* Find offset of horizontal connector line between children */\n    childrenConnectorOffset = treeItemPosition.topConnectorShift;\n  }\n  if (children.length == 1) {\n    parentHorizontalCenter = children[0].x;\n  } else if (parents.length == 1) {\n    parentHorizontalCenter = parents[0].x;\n  } else if (children.length > 0 && parents.length > 0) {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x + children[0].x + children[children.length - 1].x) / 4.0;\n  } else if (children.length > 0) {\n    parentHorizontalCenter = (children[0].x + children[children.length - 1].x) / 2.0;\n  } else {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x) / 2.0;\n  }\n  var topCenterPoint = null;\n  if (parents.length > 0) {\n    topCenterPoint = new this.ConnectorDestination({\n      id: children.length == 0 && this.dotId ? this.dotId : this.getId(data),\n      x: parentHorizontalCenter,\n      y: parentsConnectorOffset\n    });\n    this.traceFork(data, params, options, topCenterPoint, parents, true, true, this.fromOffset, options.showExtraArrows);\n  }\n  var bottomCenterPoint = null;\n  if (children.length > 0) {\n    bottomCenterPoint = new this.ConnectorDestination({\n      id: parents.length == 0 && this.dotId ? this.dotId : this.getId(data),\n      x: parentHorizontalCenter,\n      y: childrenConnectorOffset\n    });\n    if (topCenterPoint != null && bottomCenterPoint.y == topCenterPoint.y) {\n      bottomCenterPoint = topCenterPoint;\n    }\n    this.traceFork(data, params, options, bottomCenterPoint, children, hasSquared, false, 0, options.showExtraArrows);\n  }\n\n  /* draw connector line between children and parents */\n  if (topCenterPoint != null && bottomCenterPoint != null && topCenterPoint.id != bottomCenterPoint.id) {\n    params.transform.transformPoints(topCenterPoint.x, topCenterPoint.y, bottomCenterPoint.x, bottomCenterPoint.y, true, this, function (fromX, fromY, toX, toY) {\n      var polyline = new Polyline();\n      polyline.addSegment(new MoveSegment(fromX, fromY));\n      polyline.addSegment(new LineSegment(toX, toY));\n      data.graph.addEdge(topCenterPoint.id, bottomCenterPoint.id, new this.ConnectorEdge(topCenterPoint.id, bottomCenterPoint.id, polyline, null, null, null, 0 /* weight */));\n    });\n  }\n};","map":{"version":3,"names":["BaseConnectorBundle","ConnectorType","Visibility","Polyline","MoveSegment","LineSegment","VerticalConnectorBundle","fromItems","toItems","dotId","fromOffset","fromStackSize","prototype","trace","data","params","options","parents","children","items","treeItemId","treeItemPosition","index","len","isSquared","hasSquared","parentHorizontalCenter","parentsConnectorOffset","childrenConnectorOffset","connectorPoint","connectorStep","chartHasSquaredConnectors","connectorType","Squared","length","treeItemsPositions","ConnectorDestination","id","nestedLayoutBottomConnectorIds","hasOwnProperty","bundleid","getId","x","actualPosition","horizontalCenter","y","bottom","visibility","actualVisibility","push","sort","a","b","bottomConnectorShift","bottomConnectorInterval","Dot","Line","top","topConnectorShift","topCenterPoint","traceFork","showExtraArrows","bottomCenterPoint","transform","transformPoints","fromX","fromY","toX","toY","polyline","addSegment","graph","addEdge","ConnectorEdge"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/connectors/VerticalConnectorBundle.js"],"sourcesContent":["import BaseConnectorBundle from './BaseConnectorBundle';\r\nimport { ConnectorType, Visibility } from '../enums';\r\nimport Polyline from '../graphics/structs/Polyline';\r\nimport MoveSegment from '../graphics/structs/MoveSegment';\r\nimport LineSegment from '../graphics/structs/LineSegment';\r\n\r\nexport default function VerticalConnectorBundle(fromItems, toItems, dotId) {\r\n  this.fromItems = fromItems;\r\n  this.toItems = toItems;\r\n\r\n  this.dotId = dotId || null;\r\n\r\n  this.fromOffset = 0;\r\n  this.fromStackSize = 0;\r\n};\r\n\r\nVerticalConnectorBundle.prototype = new BaseConnectorBundle();\r\n\r\nVerticalConnectorBundle.prototype.trace = function (data, params, options) {\r\n  var parents, children, items,\r\n    treeItemId, treeItemPosition,\r\n    index, len,\r\n    isSquared, hasSquared,\r\n    parentHorizontalCenter,\r\n    parentsConnectorOffset,\r\n    childrenConnectorOffset,\r\n    connectorPoint,\r\n    connectorStep,\r\n    chartHasSquaredConnectors = (options.connectorType === ConnectorType.Squared);\r\n\r\n  /* Draw fork for parents */\r\n  parents = [];\r\n  if (this.fromItems.length > 0) {\r\n    items = this.fromItems;\r\n    for (index = 0, len = items.length; index < len; index += 1) {\r\n      treeItemId = items[index];\r\n      treeItemPosition = params.treeItemsPositions[treeItemId];\r\n\r\n      connectorPoint = new this.ConnectorDestination({\r\n        id: params.nestedLayoutBottomConnectorIds.hasOwnProperty(treeItemId) ? params.nestedLayoutBottomConnectorIds[treeItemId] : treeItemId,\r\n        bundleid: this.getId(data),\r\n        x: treeItemPosition.actualPosition.horizontalCenter(),\r\n        y: treeItemPosition.actualPosition.bottom(),\r\n        isSquared: true,\r\n        visibility: treeItemPosition.actualVisibility\r\n      });\r\n      parents.push(connectorPoint);\r\n    }\r\n    parents.sort(function (a, b) { return a.x - b.x; });\r\n\r\n    /* Find offset of horizontal connector line between parents */\r\n    parentsConnectorOffset = treeItemPosition.bottomConnectorShift - treeItemPosition.bottomConnectorInterval * (this.fromStackSize - this.fromOffset + 1);\r\n  }\r\n\r\n  children = [];\r\n  if (this.toItems.length > 0) {\r\n    hasSquared = false;\r\n\r\n    items = this.toItems;\r\n    for (index = 0; index < items.length; index += 1) {\r\n      treeItemId = items[index];\r\n      treeItemPosition = params.treeItemsPositions[treeItemId];\r\n\r\n      isSquared = true;\r\n      switch (treeItemPosition.actualVisibility) {\r\n        case Visibility.Dot:\r\n        case Visibility.Line:\r\n          isSquared = chartHasSquaredConnectors;\r\n          break;\r\n      }\r\n      connectorStep = 0;\r\n      connectorPoint = new this.ConnectorDestination({\r\n        id: treeItemId,\r\n        bundleid: this.getId(data),\r\n        x: (treeItemPosition.actualPosition.horizontalCenter() + connectorStep),\r\n        y: treeItemPosition.actualPosition.top(),\r\n        isSquared: isSquared,\r\n        visibility: treeItemPosition.actualVisibility\r\n      });\r\n      children.push(connectorPoint);\r\n\r\n      /* is true if any child point has squared connector */\r\n      hasSquared = hasSquared || connectorPoint.isSquared;\r\n    }\r\n    children.sort(function (a, b) { return a.x - b.x; });\r\n\r\n    /* Find offset of horizontal connector line between children */\r\n    childrenConnectorOffset = treeItemPosition.topConnectorShift;\r\n  }\r\n\r\n  if (children.length == 1) {\r\n    parentHorizontalCenter = children[0].x;\r\n  } else if (parents.length == 1) {\r\n    parentHorizontalCenter = parents[0].x;\r\n  } else if (children.length > 0 && parents.length > 0) {\r\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x + children[0].x + children[children.length - 1].x) / 4.0;\r\n  } else if (children.length > 0) {\r\n    parentHorizontalCenter = (children[0].x + children[children.length - 1].x) / 2.0;\r\n  } else {\r\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x) / 2.0;\r\n  }\r\n\r\n  var topCenterPoint = null;\r\n  if (parents.length > 0) {\r\n    topCenterPoint = new this.ConnectorDestination({\r\n      id: (children.length == 0 && this.dotId ? this.dotId : this.getId(data)),\r\n      x: parentHorizontalCenter,\r\n      y: parentsConnectorOffset\r\n    });\r\n    this.traceFork(data, params, options, topCenterPoint, parents, true, true, this.fromOffset, options.showExtraArrows);\r\n  }\r\n\r\n  var bottomCenterPoint = null;\r\n  if (children.length > 0) {\r\n    bottomCenterPoint = new this.ConnectorDestination({\r\n      id: (parents.length == 0 && this.dotId ?  this.dotId : this.getId(data)),\r\n      x: parentHorizontalCenter,\r\n      y: childrenConnectorOffset\r\n    });\r\n    if (topCenterPoint != null && bottomCenterPoint.y == topCenterPoint.y) {\r\n      bottomCenterPoint = topCenterPoint;\r\n    }\r\n    this.traceFork(data, params, options, bottomCenterPoint, children, hasSquared, false, 0, options.showExtraArrows);\r\n  }\r\n\r\n  /* draw connector line between children and parents */\r\n  if (topCenterPoint != null && bottomCenterPoint != null && topCenterPoint.id != bottomCenterPoint.id) {\r\n    params.transform.transformPoints(topCenterPoint.x, topCenterPoint.y, bottomCenterPoint.x, bottomCenterPoint.y,\r\n      true, this, function (fromX, fromY, toX, toY) {\r\n        var polyline = new Polyline();\r\n        polyline.addSegment(new MoveSegment(fromX, fromY));\r\n        polyline.addSegment(new LineSegment(toX, toY));\r\n\r\n        data.graph.addEdge(topCenterPoint.id, bottomCenterPoint.id, new this.ConnectorEdge(topCenterPoint.id, bottomCenterPoint.id, polyline,\r\n          null,\r\n          null,\r\n          null, 0/* weight */));\r\n      });\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}