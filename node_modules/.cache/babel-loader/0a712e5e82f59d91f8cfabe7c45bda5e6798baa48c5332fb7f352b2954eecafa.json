{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\nexport default function ConnectorOffbeat() {}\n;\nConnectorOffbeat.prototype = new BaseShape();\nConnectorOffbeat.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var minimalGap,\n    connectorRect,\n    fromPoint,\n    toPoint,\n    snapPoint,\n    index,\n    len,\n    offsets,\n    tempOffset,\n    invertX,\n    invertY,\n    fromLabelPlacement = PlacementType.Auto,\n    toLabelPlacement = PlacementType.Auto,\n    labelPlacement = null,\n    polyline,\n    bothWay;\n  polyline = buffer.getPolyline(linePaletteItem);\n  offsets = [];\n  switch (connectorShapeType) {\n    case ConnectorShapeType.TwoWay:\n      offsets = [-linesOffset / 2, linesOffset / 2];\n      bothWay = false;\n      break;\n    case ConnectorShapeType.OneWay:\n      offsets = [0];\n      bothWay = false;\n      break;\n    case ConnectorShapeType.BothWay:\n      offsets = [0];\n      bothWay = true;\n      break;\n  }\n  minimalGap = Math.max(hasLabel ? labelSize.width : 0, linesOffset * 5);\n  if (fromRect.right() + minimalGap < toRect.left() || fromRect.left() > toRect.right() + minimalGap) {\n    if (fromRect.left() > toRect.right()) {\n      fromPoint = new Point(fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.right(), toRect.verticalCenter());\n    } else {\n      fromPoint = new Point(fromRect.right(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.left(), toRect.verticalCenter());\n    }\n    if (hasLabel) {\n      if (fromRect.left() > toRect.right()) {\n        fromLabelPlacement = PlacementType.Left;\n        toLabelPlacement = PlacementType.Right;\n      } else {\n        fromLabelPlacement = PlacementType.Right;\n        toLabelPlacement = PlacementType.Left;\n      }\n    }\n    connectorRect = new Rect(fromPoint, toPoint);\n    invertY = fromPoint.y <= toPoint.y;\n    invertX = fromPoint.x < toPoint.x;\n    if (connectorRect.height < connectorRect.width) {\n      /* horizontal single bended connector between boxes from right side to left side */\n      if (connectorRect.height < linesOffset * 2) {\n        connectorRect.offset(0, invertY ? linesOffset * 2 : 0, 0, invertY ? 0 : linesOffset * 2);\n      }\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset, toPoint.x, toPoint.y + tempOffset));\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n      if (hasLabel) {\n        if (labelSize.width < connectorRect.width / 5 * 2) {\n          snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), invertY ? connectorRect.top() : connectorRect.bottom(), toPoint.x, toPoint.y, 0.5);\n        } else {\n          snapPoint = new Point(fromPoint.x, invertY ? connectorRect.top() : connectorRect.bottom());\n        }\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset : -labelSize.width - linesOffset), invertY ? snapPoint.y - labelSize.height - linesOffset : snapPoint.y + linesOffset, labelSize.width, labelSize.height);\n      }\n    } else {\n      /* horizontal double bended connector between boxes from right side to left side */\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset, connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), connectorRect.verticalCenter() + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.bottom() : connectorRect.top()) + tempOffset, toPoint.x, toPoint.y + tempOffset));\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n      if (hasLabel) {\n        labelPlacement = new Rect(connectorRect.horizontalCenter() + (invertY != invertX ? linesOffset : -(linesOffset + labelSize.width)), connectorRect.verticalCenter() - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    }\n  } else {\n    if (fromRect.verticalCenter() < toRect.top() || fromRect.verticalCenter() > toRect.bottom()) {\n      /* vertical single bended connector between boxes from right side to right side */\n      invertX = fromRect.x < panelSize.width / 2;\n      fromPoint = new Point(invertX ? fromRect.right() : fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(invertX ? toRect.right() : toRect.left(), toRect.verticalCenter());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(linesOffset * 10, 0, linesOffset * 10, 0);\n      invertY = fromPoint.y <= toPoint.y;\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(invertX ? connectorRect.right() + tempOffset * (invertY ? -1 : 1) : connectorRect.left() - tempOffset * (invertY ? -1 : 1), connectorRect.verticalCenter(), invertX ? toRect.right() : toRect.left(), toRect.verticalCenter() - tempOffset));\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n      if (hasLabel) {\n        fromLabelPlacement = invertX ? PlacementType.Right : PlacementType.Left;\n        toLabelPlacement = fromLabelPlacement;\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, invertX ? connectorRect.right() : connectorRect.left(), connectorRect.verticalCenter(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset / 2 : -linesOffset / 2 - labelSize.width), snapPoint.y - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    } else {\n      fromPoint = new Point(fromRect.horizontalCenter(), fromRect.top());\n      toPoint = new Point(toRect.horizontalCenter(), toRect.top());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(0, linesOffset * 7, 0, 0);\n      invertX = fromPoint.x < toPoint.x;\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x + tempOffset, fromPoint.y));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), connectorRect.top() - tempOffset * (invertX ? -1 : 1), toRect.horizontalCenter() - tempOffset, toRect.top()));\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n      if (hasLabel) {\n        fromLabelPlacement = PlacementType.Top;\n        toLabelPlacement = PlacementType.Top;\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), connectorRect.top(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x - labelSize.width / 2, snapPoint.y - (labelOffset + labelSize.height), labelSize.width, labelSize.height);\n      }\n    }\n  }\n  if (hasLabel) {\n    /* end points labels placement */\n    switch (labelPlacementType) {\n      case ConnectorLabelPlacementType.From:\n        labelPlacement = this._getLabelPosition(fromRect.x, fromRect.y, fromRect.width, fromRect.height, labelPlacement.width, labelPlacement.height, labelOffset, fromLabelPlacement);\n        break;\n      case ConnectorLabelPlacementType.To:\n        labelPlacement = this._getLabelPosition(toRect.x, toRect.y, toRect.width, toRect.height, labelPlacement.width, labelPlacement.height, labelOffset, toLabelPlacement);\n        break;\n      default:\n        break;\n    }\n  }\n  if (onLabelPlacement != null) {\n    onLabelPlacement(labelPlacement, labelConfig);\n  }\n};","map":{"version":3,"names":["BaseShape","Point","Rect","MoveSegment","QuadraticArcSegment","PlacementType","ConnectorShapeType","ConnectorLabelPlacementType","ConnectorOffbeat","prototype","draw","buffer","linePaletteItem","fromRect","toRect","linesOffset","bundleOffset","labelSize","panelSize","connectorShapeType","labelOffset","labelPlacementType","hasLabel","connectorAnnotationOffsetResolver","onLabelPlacement","labelConfig","minimalGap","connectorRect","fromPoint","toPoint","snapPoint","index","len","offsets","tempOffset","invertX","invertY","fromLabelPlacement","Auto","toLabelPlacement","labelPlacement","polyline","bothWay","getPolyline","TwoWay","OneWay","BothWay","Math","max","width","right","left","verticalCenter","Left","Right","y","x","height","offset","length","addInverted","invertedBuffer","addSegment","horizontalCenter","top","bottom","addArrow","lineWidth","mergeTo","paletteItem","offsetPoint","Top","From","_getLabelPosition","To"],"sources":["C:/Users/LCGI_15/Desktop/projects/nesty-orgchart/orgchart/node_modules/basicprimitives/src/graphics/shapes/ConnectorOffbeat.js"],"sourcesContent":["import BaseShape from './BaseShape';\r\nimport Point from '../structs/Point';\r\nimport Rect from '../structs/Rect';\r\nimport MoveSegment from '../structs/MoveSegment';\r\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\r\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\r\n\r\nexport default function ConnectorOffbeat() {\r\n\r\n};\r\n\r\nConnectorOffbeat.prototype = new BaseShape();\r\n\r\nConnectorOffbeat.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel,\r\n  connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\r\n  var minimalGap,\r\n    connectorRect,\r\n    fromPoint, toPoint,\r\n    snapPoint,\r\n    index, len,\r\n    offsets, tempOffset,\r\n    invertX, invertY,\r\n    fromLabelPlacement = PlacementType.Auto,\r\n    toLabelPlacement = PlacementType.Auto,\r\n    labelPlacement = null,\r\n    polyline,\r\n    bothWay;\r\n\r\n  polyline = buffer.getPolyline(linePaletteItem);\r\n\r\n  offsets = [];\r\n  switch (connectorShapeType) {\r\n    case ConnectorShapeType.TwoWay:\r\n      offsets = [-linesOffset / 2, linesOffset / 2];\r\n      bothWay = false;\r\n      break;\r\n    case ConnectorShapeType.OneWay:\r\n      offsets = [0];\r\n      bothWay = false;\r\n      break;\r\n    case ConnectorShapeType.BothWay:\r\n      offsets = [0];\r\n      bothWay = true;\r\n      break;\r\n  }\r\n\r\n  minimalGap = Math.max(hasLabel ? labelSize.width : 0, linesOffset * 5);\r\n  if (fromRect.right() + minimalGap < toRect.left() || fromRect.left() > toRect.right() + minimalGap) {\r\n    if (fromRect.left() > toRect.right()) {\r\n      fromPoint = new Point(fromRect.left(), fromRect.verticalCenter());\r\n      toPoint = new Point(toRect.right(), toRect.verticalCenter());\r\n    } else {\r\n      fromPoint = new Point(fromRect.right(), fromRect.verticalCenter());\r\n      toPoint = new Point(toRect.left(), toRect.verticalCenter());\r\n    }\r\n    if (hasLabel) {\r\n      if (fromRect.left() > toRect.right()) {\r\n        fromLabelPlacement = PlacementType.Left;\r\n        toLabelPlacement = PlacementType.Right;\r\n      } else {\r\n        fromLabelPlacement = PlacementType.Right;\r\n        toLabelPlacement = PlacementType.Left;\r\n      }\r\n    }\r\n    connectorRect = new Rect(fromPoint, toPoint);\r\n    invertY = (fromPoint.y <= toPoint.y);\r\n    invertX = (fromPoint.x < toPoint.x);\r\n    if (connectorRect.height < connectorRect.width) {\r\n      /* horizontal single bended connector between boxes from right side to left side */\r\n      if (connectorRect.height < linesOffset * 2) {\r\n        connectorRect.offset(0, invertY ? linesOffset * 2 : 0, 0, invertY ? 0 : linesOffset * 2);\r\n      }\r\n\r\n      for (index = 0, len = offsets.length; index < len; index += 1) {\r\n        tempOffset = offsets[index];\r\n        buffer.addInverted(function (invertedBuffer) {\r\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\r\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\r\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,\r\n            toPoint.x, toPoint.y + tempOffset));\r\n\r\n          if (bothWay) {\r\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n            });//ignore jslint\r\n          }\r\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\r\n\r\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n        }); //ignore jslint\r\n      }\r\n\r\n      if (hasLabel) {\r\n        if (labelSize.width < connectorRect.width / 5 * 2) {\r\n          snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()), toPoint.x, toPoint.y, 0.5);\r\n        } else {\r\n          snapPoint = new Point(fromPoint.x, invertY ? connectorRect.top() : connectorRect.bottom());\r\n        }\r\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset : -labelSize.width - linesOffset), (invertY ? snapPoint.y - labelSize.height - linesOffset : snapPoint.y + linesOffset), labelSize.width, labelSize.height);\r\n      }\r\n    } else {\r\n      /* horizontal double bended connector between boxes from right side to left side */\r\n      for (index = 0, len = offsets.length; index < len; index += 1) {\r\n        tempOffset = offsets[index];\r\n        buffer.addInverted(function (invertedBuffer) {\r\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\r\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\r\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,\r\n            connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), connectorRect.verticalCenter() + tempOffset));\r\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.bottom() : connectorRect.top()) + tempOffset,\r\n            toPoint.x, toPoint.y + tempOffset));\r\n\r\n          if (bothWay) {\r\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n            });//ignore jslint\r\n          }\r\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\r\n\r\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n        }); //ignore jslint\r\n      }\r\n\r\n      if (hasLabel) {\r\n        labelPlacement = new Rect(connectorRect.horizontalCenter() + (invertY != invertX ? linesOffset : -(linesOffset + labelSize.width)),\r\n          connectorRect.verticalCenter() - labelSize.height / 2, labelSize.width, labelSize.height);\r\n      }\r\n    }\r\n  } else {\r\n    if (fromRect.verticalCenter() < toRect.top() || fromRect.verticalCenter() > toRect.bottom()) {\r\n      /* vertical single bended connector between boxes from right side to right side */\r\n      invertX = fromRect.x < panelSize.width / 2;\r\n      fromPoint = new Point(invertX ? fromRect.right() : fromRect.left(), fromRect.verticalCenter());\r\n      toPoint = new Point(invertX ? toRect.right() : toRect.left(), toRect.verticalCenter());\r\n      connectorRect = new Rect(fromPoint, toPoint);\r\n      connectorRect.offset(linesOffset * 10, 0, linesOffset * 10, 0);\r\n      invertY = (fromPoint.y <= toPoint.y);\r\n      for (index = 0, len = offsets.length; index < len; index += 1) {\r\n        tempOffset = offsets[index];\r\n        buffer.addInverted(function (invertedBuffer) {\r\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\r\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\r\n          polyline.addSegment(new QuadraticArcSegment(invertX ? connectorRect.right() + tempOffset * (invertY ? -1 : 1) : connectorRect.left() - tempOffset * (invertY ? -1 : 1), connectorRect.verticalCenter(),\r\n            invertX ? toRect.right() : toRect.left(), toRect.verticalCenter() - tempOffset));\r\n\r\n          if (bothWay) {\r\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n            });//ignore jslint\r\n          }\r\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\r\n\r\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n        });//ignore jslint\r\n      }\r\n\r\n      if (hasLabel) {\r\n        fromLabelPlacement = invertX ? PlacementType.Right : PlacementType.Left;\r\n        toLabelPlacement = fromLabelPlacement;\r\n\r\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, (invertX ? connectorRect.right() : connectorRect.left()), connectorRect.verticalCenter(), toPoint.x, toPoint.y, 0.5);\r\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset / 2 : -linesOffset / 2 - labelSize.width), snapPoint.y - labelSize.height / 2, labelSize.width, labelSize.height);\r\n      }\r\n    } else {\r\n      fromPoint = new Point(fromRect.horizontalCenter(), fromRect.top());\r\n      toPoint = new Point(toRect.horizontalCenter(), toRect.top());\r\n      connectorRect = new Rect(fromPoint, toPoint);\r\n      connectorRect.offset(0, linesOffset * 7, 0, 0);\r\n      invertX = (fromPoint.x < toPoint.x);\r\n      for (index = 0, len = offsets.length; index < len; index += 1) {\r\n        tempOffset = offsets[index];\r\n        buffer.addInverted(function (invertedBuffer) {\r\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\r\n          polyline.addSegment(new MoveSegment(fromPoint.x + tempOffset, fromPoint.y));\r\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), connectorRect.top() - tempOffset * (invertX ? -1 : 1),\r\n            toRect.horizontalCenter() - tempOffset, toRect.top()));\r\n\r\n          if (bothWay) {\r\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n            });//ignore jslint\r\n          }\r\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\r\n\r\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\r\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\r\n        }); //ignore jslint\r\n      }\r\n\r\n      if (hasLabel) {\r\n        fromLabelPlacement = PlacementType.Top;\r\n        toLabelPlacement = PlacementType.Top;\r\n\r\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), connectorRect.top(), toPoint.x, toPoint.y, 0.5);\r\n        labelPlacement = new Rect(snapPoint.x - labelSize.width / 2, snapPoint.y - (labelOffset + labelSize.height), labelSize.width, labelSize.height);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (hasLabel) {\r\n    /* end points labels placement */\r\n    switch (labelPlacementType) {\r\n      case ConnectorLabelPlacementType.From:\r\n        labelPlacement = this._getLabelPosition(fromRect.x, fromRect.y, fromRect.width, fromRect.height, labelPlacement.width, labelPlacement.height, labelOffset, fromLabelPlacement);\r\n        break;\r\n      case ConnectorLabelPlacementType.To:\r\n        labelPlacement = this._getLabelPosition(toRect.x, toRect.y, toRect.width, toRect.height, labelPlacement.width, labelPlacement.height, labelOffset, toLabelPlacement);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  if (onLabelPlacement != null) {\r\n    onLabelPlacement(labelPlacement, labelConfig);\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}