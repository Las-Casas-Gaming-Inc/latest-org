{"ast":null,"code":"import getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\nexport default function FamLogicalLevelsPlacementTask(orderFamilyNodesTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n  function createPositions() {\n    var intervals = [],\n      treeLevels = orderFamilyNodesTask.getTreeLevels(),\n      itemsPositions = alignDiagramTask.getItemsPositions(),\n      index = 0;\n    treeLevels.loopLevels(this, function (levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeId, node, position) {\n        if (node.isVisible && node.isActive) {\n          var itemPosition = itemsPositions[nodeId];\n          if (itemPosition) {\n            var interval = new Interval(itemPosition.topConnectorShift || itemPosition.actualPosition.y, itemPosition.bottomConnectorShift - 1, index++);\n            intervals.push(interval);\n          }\n          return true; /* only one item per level is needed */\n        }\n      });\n    });\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function (interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n\n    /* merge intervals having equal logical levels */\n    mergedIntervals = [];\n    var currentInterval = null;\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      if (!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if (currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n    intervals = mergedIntervals;\n\n    /* extend first level to the top */\n    if (intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n\n    /* fill gaps between levels */\n    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n      prev.to = next.from;\n    }\n\n    /* find minimal level */\n    var minLevelIndex = null;\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n\n    /* group intervals by logical levels */\n    var result = {};\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n      if (!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n    return result;\n  }\n  function getPositions() {\n    if (!_data.positions) {\n      _data.positions = createPositions();\n    }\n    return _data.positions;\n  }\n  return {\n    getPositions: getPositions,\n    process: process\n  };\n}\n;","map":{"version":3,"names":["getMergedIntervals","Interval","FamLogicalLevelsPlacementTask","orderFamilyNodesTask","alignDiagramTask","_data","positions","process","createPositions","intervals","treeLevels","getTreeLevels","itemsPositions","getItemsPositions","index","loopLevels","levelIndex","level","loopLevelItems","nodeId","node","position","isVisible","isActive","itemPosition","interval","topConnectorShift","actualPosition","y","bottomConnectorShift","push","mergedIntervals","currentInterval","len","length","context","to","from","prev","next","minLevelIndex","Math","min","result","logicalLevelPosition","getPositions"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/tasks/layout/FamLogicalLevelsPlacementTask.js"],"sourcesContent":["import getMergedIntervals from '../../algorithms/getMergedIntervals';\r\nimport Interval from '../../graphics/structs/Interval';\r\n\r\nexport default function FamLogicalLevelsPlacementTask(orderFamilyNodesTask, alignDiagramTask) {\r\n  var _data = {\r\n    positions: []\r\n  };\r\n\r\n  function process() {\r\n    _data.positions = null;\r\n    return true;\r\n  }\r\n\r\n  function createPositions() {\r\n    var intervals = [],\r\n      treeLevels = orderFamilyNodesTask.getTreeLevels(),\r\n      itemsPositions = alignDiagramTask.getItemsPositions(),\r\n      index = 0;\r\n    treeLevels.loopLevels(this, function(levelIndex, level) {\r\n      treeLevels.loopLevelItems(this, levelIndex, function(nodeId, node, position) {\r\n        if(node.isVisible && node.isActive) {\r\n          var itemPosition = itemsPositions[nodeId];\r\n          if(itemPosition) {\r\n            var interval = new Interval(itemPosition.topConnectorShift || itemPosition.actualPosition.y, itemPosition.bottomConnectorShift - 1, index++)\r\n            intervals.push(interval);\r\n          }\r\n          return true; /* only one item per level is needed */\r\n        }\r\n      })\r\n    });\r\n\r\n    var mergedIntervals = [];\r\n    getMergedIntervals(this, intervals, function(interval) {\r\n      mergedIntervals.push(interval);\r\n    });\r\n    intervals = mergedIntervals;\r\n\r\n    /* merge intervals having equal logical levels */\r\n    mergedIntervals = [];\r\n    var currentInterval = null;\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      if(!currentInterval) {\r\n        currentInterval = interval;\r\n        mergedIntervals.push(interval);\r\n      } else {\r\n        if(currentInterval.context === interval.context) {\r\n          currentInterval.to = interval.to;\r\n        } else {\r\n          currentInterval = interval;\r\n          mergedIntervals.push(interval);\r\n        }\r\n      }\r\n    }\r\n    intervals = mergedIntervals;\r\n\r\n    /* extend first level to the top */\r\n    if(intervals.length > 0) {\r\n      intervals[0].from = 0;\r\n    }\r\n\r\n    /* fill gaps between levels */\r\n    for(var index = 0, len = intervals.length - 1; index < len; index+=1) {\r\n      var prev = intervals[index];\r\n      var next = intervals[index + 1];\r\n\r\n      prev.to = next.from;\r\n    }\r\n\r\n    /* find minimal level */\r\n    var minLevelIndex = null;\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      minLevelIndex = (minLevelIndex === null) ? interval.context : Math.min(minLevelIndex, interval.context);\r\n    }\r\n\r\n    /* group intervals by logical levels */ \r\n    var result = {};\r\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\r\n      var interval = intervals[index];\r\n      var levelIndex = interval.context - minLevelIndex;\r\n      var logicalLevelPosition = result[levelIndex];\r\n      if(!logicalLevelPosition) {\r\n        result[levelIndex] = [interval];\r\n      } else {\r\n        logicalLevelPosition.push(interval);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  function getPositions() {\r\n    if(!_data.positions) {\r\n      _data.positions = createPositions();\r\n    }\r\n    return _data.positions;\r\n  }\r\n\r\n  return {\r\n    getPositions:getPositions,\r\n    process: process\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}