{"ast":null,"code":"import { Layers, ConnectorStyleType, GroupByType, ElbowType } from '../../enums';\nimport PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport DotSegment from '../../graphics/structs/DotSegment';\nexport default function DrawConnectorsTask(getGraphics, connectionsGraphTask, connectorsOptionTask, showElbowDots, paletteManagerTask) {\n  function process() {\n    var graphics = getGraphics();\n    var graph = connectionsGraphTask.getGraph();\n    var connectorsOptions = connectorsOptionTask.getOptions();\n    var paletteManager = paletteManagerTask.getPaletteManager();\n    graphics.reset(\"placeholder\", Layers.Connector);\n    graphics.activate(\"placeholder\", Layers.Connector);\n    var buffer = new PolylinesBuffer();\n    var elbowDotRadius = Math.round(connectorsOptions.elbowDotSize / 2);\n    var processed = {};\n    var processedDots = {};\n    graph.loopNodes(this, null, function (itemid) {\n      graph.loopNodeEdges(this, itemid, function (to, connectorEdge) {\n        if (!processed.hasOwnProperty(to)) {\n          var paletteItem = null;\n          if (connectorEdge.fromOffset <= 1) {\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Regular);\n          } else {\n            paletteManager.selectPalette(connectorEdge.fromOffset);\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Extra);\n          }\n          var polyline = buffer.getPolyline(paletteItem);\n\n          /* draw intersection dots */\n          if (showElbowDots && connectorEdge.dotId != null && connectorsOptions.elbowType != ElbowType.None && !processedDots.hasOwnProperty(connectorEdge.dotId)) {\n            var dotPolyline = buffer.getPolyline(polyline.arrowPaletteItem);\n            var dotPoint = connectorEdge.dotId == connectorEdge.from ? connectorEdge.polyline.getStartPoint() : connectorEdge.polyline.getEndPoint();\n            dotPolyline.addSegment(new DotSegment(dotPoint.x - elbowDotRadius, dotPoint.y - elbowDotRadius, elbowDotRadius * 2, elbowDotRadius * 2, elbowDotRadius));\n            processedDots[connectorEdge.dotId] = true;\n          }\n          var arrowId = null;\n          if (connectorEdge.hasArrow) {\n            switch (connectorsOptions.arrowsDirection) {\n              case GroupByType.Parents:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.parentsArrowId : connectorEdge.childrenArrowId;\n                break;\n              case GroupByType.Children:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.childrenArrowId : connectorEdge.parentsArrowId;\n                break;\n            }\n          }\n          if (arrowId == null) {\n            var newSegment = connectorEdge.polyline.clone();\n            if (connectorEdge.hasMiddle && connectorsOptions.arrowsDirection != GroupByType.None) {\n              var isForward = true;\n              if (connectorEdge.from == connectorEdge.middleParent) {\n                isForward = connectorsOptions.arrowsDirection == GroupByType.Children;\n              } else {\n                isForward = connectorsOptions.arrowsDirection == GroupByType.Parents;\n              }\n              if (connectorEdge.isOppositeFlow) {\n                isForward = !isForward;\n              }\n              newSegment.addOffsetArrow(isForward, connectorsOptions.linesWidth, 0.4, connectorsOptions.extraArrowsMinimumSpace, function (arrowPolyline) {\n                arrowPolyline.mergeTo(buffer.getPolyline(polyline.arrowPaletteItem));\n              }); //ignore jslint\n            }\n            if (connectorEdge.from == itemid) {\n              newSegment.mergeTo(polyline);\n            } else {\n              polyline.addInverted(newSegment);\n            }\n          } else {\n            if (arrowId == connectorEdge.to) {\n              connectorEdge.polyline.clone().mergeTo(polyline);\n            } else {\n              polyline.addInverted(connectorEdge.polyline.clone());\n            }\n            polyline.addArrow(connectorsOptions.linesWidth, function (arrowPolyline) {\n              arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n            }); //ignore jslint\n          }\n        }\n      });\n      processed[itemid] = true;\n    });\n    graphics.polylinesBuffer(buffer);\n    return false;\n  }\n  return {\n    process: process\n  };\n}\n;","map":{"version":3,"names":["Layers","ConnectorStyleType","GroupByType","ElbowType","PolylinesBuffer","DotSegment","DrawConnectorsTask","getGraphics","connectionsGraphTask","connectorsOptionTask","showElbowDots","paletteManagerTask","process","graphics","graph","getGraph","connectorsOptions","getOptions","paletteManager","getPaletteManager","reset","Connector","activate","buffer","elbowDotRadius","Math","round","elbowDotSize","processed","processedDots","loopNodes","itemid","loopNodeEdges","to","connectorEdge","hasOwnProperty","paletteItem","fromOffset","getPalette","Regular","selectPalette","Extra","polyline","getPolyline","dotId","elbowType","None","dotPolyline","arrowPaletteItem","dotPoint","from","getStartPoint","getEndPoint","addSegment","x","y","arrowId","hasArrow","arrowsDirection","Parents","isOppositeFlow","parentsArrowId","childrenArrowId","Children","newSegment","clone","hasMiddle","isForward","middleParent","addOffsetArrow","linesWidth","extraArrowsMinimumSpace","arrowPolyline","mergeTo","addInverted","addArrow","polylinesBuffer"],"sources":["/Users/iamnestyyy/ReactProjects/orgchart/node_modules/basicprimitives/src/tasks/renders/DrawConnectorsTask.js"],"sourcesContent":["import { Layers, ConnectorStyleType, GroupByType, ElbowType } from '../../enums';\r\nimport PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\r\nimport DotSegment from '../../graphics/structs/DotSegment';\r\n\r\n\r\nexport default function DrawConnectorsTask(getGraphics, connectionsGraphTask, connectorsOptionTask, showElbowDots, paletteManagerTask) {\r\n  function process() {\r\n    var graphics = getGraphics();\r\n    var graph = connectionsGraphTask.getGraph();\r\n    var connectorsOptions = connectorsOptionTask.getOptions();\r\n    var paletteManager = paletteManagerTask.getPaletteManager();\r\n\r\n    graphics.reset(\"placeholder\", Layers.Connector);\r\n    graphics.activate(\"placeholder\", Layers.Connector);\r\n\r\n    var buffer = new PolylinesBuffer();\r\n\r\n    var elbowDotRadius = Math.round(connectorsOptions.elbowDotSize / 2);\r\n\r\n    var processed = {};\r\n    var processedDots = {};\r\n    graph.loopNodes(this, null, function (itemid) {\r\n      graph.loopNodeEdges(this, itemid, function (to, connectorEdge) {\r\n        if (!processed.hasOwnProperty(to)) {\r\n          var paletteItem = null;\r\n          if (connectorEdge.fromOffset <= 1) {\r\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Regular);\r\n          } else {\r\n            paletteManager.selectPalette(connectorEdge.fromOffset);\r\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Extra);\r\n          }\r\n          var polyline = buffer.getPolyline(paletteItem);\r\n\r\n          /* draw intersection dots */\r\n          if (showElbowDots && connectorEdge.dotId != null && connectorsOptions.elbowType != ElbowType.None && !processedDots.hasOwnProperty(connectorEdge.dotId)) {\r\n            var dotPolyline = buffer.getPolyline(polyline.arrowPaletteItem);\r\n            var dotPoint = (connectorEdge.dotId == connectorEdge.from) ? connectorEdge.polyline.getStartPoint() : connectorEdge.polyline.getEndPoint();\r\n            dotPolyline.addSegment(new DotSegment(dotPoint.x - elbowDotRadius, dotPoint.y - elbowDotRadius, elbowDotRadius * 2, elbowDotRadius * 2, elbowDotRadius));\r\n            processedDots[connectorEdge.dotId] = true;\r\n          }\r\n\r\n          var arrowId = null;\r\n\r\n          if (connectorEdge.hasArrow) {\r\n            switch (connectorsOptions.arrowsDirection) {\r\n              case GroupByType.Parents:\r\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.parentsArrowId : connectorEdge.childrenArrowId;\r\n                break;\r\n              case GroupByType.Children:\r\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.childrenArrowId : connectorEdge.parentsArrowId;\r\n                break;\r\n            }\r\n          }\r\n\r\n          if (arrowId == null) {\r\n            var newSegment = connectorEdge.polyline.clone();\r\n\r\n            if (connectorEdge.hasMiddle && connectorsOptions.arrowsDirection != GroupByType.None) {\r\n              var isForward = true;\r\n              if (connectorEdge.from == connectorEdge.middleParent) {\r\n                isForward = (connectorsOptions.arrowsDirection == GroupByType.Children);\r\n              } else {\r\n                isForward = (connectorsOptions.arrowsDirection == GroupByType.Parents);\r\n              }\r\n              if (connectorEdge.isOppositeFlow) {\r\n                isForward = !isForward;\r\n              }\r\n              newSegment.addOffsetArrow(isForward, connectorsOptions.linesWidth, 0.4, connectorsOptions.extraArrowsMinimumSpace, function (arrowPolyline) {\r\n                arrowPolyline.mergeTo(buffer.getPolyline(polyline.arrowPaletteItem));\r\n              }); //ignore jslint\r\n            }\r\n\r\n            if (connectorEdge.from == itemid) {\r\n              newSegment.mergeTo(polyline);\r\n            } else {\r\n              polyline.addInverted(newSegment);\r\n            }\r\n          } else {\r\n            if (arrowId == connectorEdge.to) {\r\n              connectorEdge.polyline.clone().mergeTo(polyline);\r\n            } else {\r\n              polyline.addInverted(connectorEdge.polyline.clone());\r\n            }\r\n            polyline.addArrow(connectorsOptions.linesWidth, function (arrowPolyline) {\r\n              arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\r\n            }); //ignore jslint\r\n          }\r\n        }\r\n      });\r\n      processed[itemid] = true;\r\n    });\r\n\r\n    graphics.polylinesBuffer(buffer);\r\n\r\n    return false;\r\n  }\r\n\r\n  return {\r\n    process: process\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}